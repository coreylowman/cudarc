/* automatically generated by rust-bindgen 0.69.4 */

pub const CUDA_VERSION: u32 = 12030;
pub const CU_IPC_HANDLE_SIZE: u32 = 64;
pub const CU_COMPUTE_ACCELERATED_TARGET_BASE: u32 = 65536;
pub const CU_GRAPH_COND_ASSIGN_DEFAULT: u32 = 1;
pub const CU_GRAPH_KERNEL_NODE_PORT_DEFAULT: u32 = 0;
pub const CU_GRAPH_KERNEL_NODE_PORT_PROGRAMMATIC: u32 = 1;
pub const CU_GRAPH_KERNEL_NODE_PORT_LAUNCH_ORDER: u32 = 2;
pub const CU_MEMHOSTALLOC_PORTABLE: u32 = 1;
pub const CU_MEMHOSTALLOC_DEVICEMAP: u32 = 2;
pub const CU_MEMHOSTALLOC_WRITECOMBINED: u32 = 4;
pub const CU_MEMHOSTREGISTER_PORTABLE: u32 = 1;
pub const CU_MEMHOSTREGISTER_DEVICEMAP: u32 = 2;
pub const CU_MEMHOSTREGISTER_IOMEMORY: u32 = 4;
pub const CU_MEMHOSTREGISTER_READ_ONLY: u32 = 8;
pub const CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL: u32 = 1;
pub const CU_TENSOR_MAP_NUM_QWORDS: u32 = 16;
pub const CUDA_EXTERNAL_MEMORY_DEDICATED: u32 = 1;
pub const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC: u32 = 1;
pub const CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC: u32 = 2;
pub const CUDA_NVSCISYNC_ATTR_SIGNAL: u32 = 1;
pub const CUDA_NVSCISYNC_ATTR_WAIT: u32 = 2;
pub const CU_MEM_CREATE_USAGE_TILE_POOL: u32 = 1;
pub const CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC: u32 = 1;
pub const CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC: u32 = 2;
pub const CUDA_ARRAY3D_LAYERED: u32 = 1;
pub const CUDA_ARRAY3D_2DARRAY: u32 = 1;
pub const CUDA_ARRAY3D_SURFACE_LDST: u32 = 2;
pub const CUDA_ARRAY3D_CUBEMAP: u32 = 4;
pub const CUDA_ARRAY3D_TEXTURE_GATHER: u32 = 8;
pub const CUDA_ARRAY3D_DEPTH_TEXTURE: u32 = 16;
pub const CUDA_ARRAY3D_COLOR_ATTACHMENT: u32 = 32;
pub const CUDA_ARRAY3D_SPARSE: u32 = 64;
pub const CUDA_ARRAY3D_DEFERRED_MAPPING: u32 = 128;
pub const CU_TRSA_OVERRIDE_FORMAT: u32 = 1;
pub const CU_TRSF_READ_AS_INTEGER: u32 = 1;
pub const CU_TRSF_NORMALIZED_COORDINATES: u32 = 2;
pub const CU_TRSF_SRGB: u32 = 16;
pub const CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION: u32 = 32;
pub const CU_TRSF_SEAMLESS_CUBEMAP: u32 = 64;
pub const CU_LAUNCH_PARAM_END_AS_INT: u32 = 0;
pub const CU_LAUNCH_PARAM_BUFFER_POINTER_AS_INT: u32 = 1;
pub const CU_LAUNCH_PARAM_BUFFER_SIZE_AS_INT: u32 = 2;
pub const CU_PARAM_TR_DEFAULT: i32 = -1;
pub type cuuint32_t = u32;
pub type cuuint64_t = u64;
pub type CUdeviceptr_v2 = ::core::ffi::c_ulonglong;
pub type CUdeviceptr = CUdeviceptr_v2;
pub type CUdevice_v1 = ::core::ffi::c_int;
pub type CUdevice = CUdevice_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctx_st {
    _unused: [u8; 0],
}
pub type CUcontext = *mut CUctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmod_st {
    _unused: [u8; 0],
}
pub type CUmodule = *mut CUmod_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUfunc_st {
    _unused: [u8; 0],
}
pub type CUfunction = *mut CUfunc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlib_st {
    _unused: [u8; 0],
}
pub type CUlibrary = *mut CUlib_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUkern_st {
    _unused: [u8; 0],
}
pub type CUkernel = *mut CUkern_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUarray_st {
    _unused: [u8; 0],
}
pub type CUarray = *mut CUarray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmipmappedArray_st {
    _unused: [u8; 0],
}
pub type CUmipmappedArray = *mut CUmipmappedArray_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUtexref_st {
    _unused: [u8; 0],
}
pub type CUtexref = *mut CUtexref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUsurfref_st {
    _unused: [u8; 0],
}
pub type CUsurfref = *mut CUsurfref_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
pub type CUevent = *mut CUevent_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type CUstream = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphicsResource_st {
    _unused: [u8; 0],
}
pub type CUgraphicsResource = *mut CUgraphicsResource_st;
pub type CUtexObject_v1 = ::core::ffi::c_ulonglong;
pub type CUtexObject = CUtexObject_v1;
pub type CUsurfObject_v1 = ::core::ffi::c_ulonglong;
pub type CUsurfObject = CUsurfObject_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextMemory_st {
    _unused: [u8; 0],
}
pub type CUexternalMemory = *mut CUextMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUextSemaphore_st {
    _unused: [u8; 0],
}
pub type CUexternalSemaphore = *mut CUextSemaphore_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
pub type CUgraph = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
pub type CUgraphNode = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
pub type CUgraphExec = *mut CUgraphExec_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUmemPoolHandle_st {
    _unused: [u8; 0],
}
pub type CUmemoryPool = *mut CUmemPoolHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUuserObject_st {
    _unused: [u8; 0],
}
pub type CUuserObject = *mut CUuserObject_st;
pub type CUgraphConditionalHandle = cuuint64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUuuid_st {
    pub bytes: [::core::ffi::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_CUuuid_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUuuid_st> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUuuid_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUuuid_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUuuid_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUuuid_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUuuid_st),
            "::",
            stringify!(bytes)
        )
    );
}
pub type CUuuid = CUuuid_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUmemFabricHandle_st {
    pub data: [::core::ffi::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_CUmemFabricHandle_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUmemFabricHandle_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUmemFabricHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUmemFabricHandle_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUmemFabricHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUmemFabricHandle_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemFabricHandle_st),
            "::",
            stringify!(data)
        )
    );
}
impl Default for CUmemFabricHandle_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUmemFabricHandle_v1 = CUmemFabricHandle_st;
pub type CUmemFabricHandle = CUmemFabricHandle_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUipcEventHandle_st {
    pub reserved: [::core::ffi::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CUipcEventHandle_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUipcEventHandle_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUipcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUipcEventHandle_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUipcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUipcEventHandle_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUipcEventHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUipcEventHandle_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUipcEventHandle_v1 = CUipcEventHandle_st;
pub type CUipcEventHandle = CUipcEventHandle_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUipcMemHandle_st {
    pub reserved: [::core::ffi::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CUipcMemHandle_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUipcMemHandle_st> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUipcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUipcMemHandle_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUipcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUipcMemHandle_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUipcMemHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUipcMemHandle_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUipcMemHandle_v1 = CUipcMemHandle_st;
pub type CUipcMemHandle = CUipcMemHandle_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUipcMem_flags_enum {
    CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 1,
}
pub use self::CUipcMem_flags_enum as CUipcMem_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemAttach_flags_enum {
    CU_MEM_ATTACH_GLOBAL = 1,
    CU_MEM_ATTACH_HOST = 2,
    CU_MEM_ATTACH_SINGLE = 4,
}
pub use self::CUmemAttach_flags_enum as CUmemAttach_flags;
impl CUctx_flags_enum {
    pub const CU_CTX_BLOCKING_SYNC: CUctx_flags_enum = CUctx_flags_enum::CU_CTX_SCHED_BLOCKING_SYNC;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUctx_flags_enum {
    CU_CTX_SCHED_AUTO = 0,
    CU_CTX_SCHED_SPIN = 1,
    CU_CTX_SCHED_YIELD = 2,
    CU_CTX_SCHED_BLOCKING_SYNC = 4,
    CU_CTX_SCHED_MASK = 7,
    CU_CTX_MAP_HOST = 8,
    CU_CTX_LMEM_RESIZE_TO_MAX = 16,
    CU_CTX_COREDUMP_ENABLE = 32,
    CU_CTX_USER_COREDUMP_ENABLE = 64,
    CU_CTX_SYNC_MEMOPS = 128,
    CU_CTX_FLAGS_MASK = 255,
}
pub use self::CUctx_flags_enum as CUctx_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUevent_sched_flags_enum {
    CU_EVENT_SCHED_AUTO = 0,
    CU_EVENT_SCHED_SPIN = 1,
    CU_EVENT_SCHED_YIELD = 2,
    CU_EVENT_SCHED_BLOCKING_SYNC = 4,
}
pub use self::CUevent_sched_flags_enum as CUevent_sched_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstream_flags_enum {
    CU_STREAM_DEFAULT = 0,
    CU_STREAM_NON_BLOCKING = 1,
}
pub use self::CUstream_flags_enum as CUstream_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUevent_flags_enum {
    CU_EVENT_DEFAULT = 0,
    CU_EVENT_BLOCKING_SYNC = 1,
    CU_EVENT_DISABLE_TIMING = 2,
    CU_EVENT_INTERPROCESS = 4,
}
pub use self::CUevent_flags_enum as CUevent_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUevent_record_flags_enum {
    CU_EVENT_RECORD_DEFAULT = 0,
    CU_EVENT_RECORD_EXTERNAL = 1,
}
pub use self::CUevent_record_flags_enum as CUevent_record_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUevent_wait_flags_enum {
    CU_EVENT_WAIT_DEFAULT = 0,
    CU_EVENT_WAIT_EXTERNAL = 1,
}
pub use self::CUevent_wait_flags_enum as CUevent_wait_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamWaitValue_flags_enum {
    CU_STREAM_WAIT_VALUE_GEQ = 0,
    CU_STREAM_WAIT_VALUE_EQ = 1,
    CU_STREAM_WAIT_VALUE_AND = 2,
    CU_STREAM_WAIT_VALUE_NOR = 3,
    CU_STREAM_WAIT_VALUE_FLUSH = 1073741824,
}
pub use self::CUstreamWaitValue_flags_enum as CUstreamWaitValue_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamWriteValue_flags_enum {
    CU_STREAM_WRITE_VALUE_DEFAULT = 0,
    CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER = 1,
}
pub use self::CUstreamWriteValue_flags_enum as CUstreamWriteValue_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamBatchMemOpType_enum {
    CU_STREAM_MEM_OP_WAIT_VALUE_32 = 1,
    CU_STREAM_MEM_OP_WRITE_VALUE_32 = 2,
    CU_STREAM_MEM_OP_WAIT_VALUE_64 = 4,
    CU_STREAM_MEM_OP_WRITE_VALUE_64 = 5,
    CU_STREAM_MEM_OP_BARRIER = 6,
    CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = 3,
}
pub use self::CUstreamBatchMemOpType_enum as CUstreamBatchMemOpType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamMemoryBarrier_flags_enum {
    CU_STREAM_MEMORY_BARRIER_TYPE_SYS = 0,
    CU_STREAM_MEMORY_BARRIER_TYPE_GPU = 1,
}
pub use self::CUstreamMemoryBarrier_flags_enum as CUstreamMemoryBarrier_flags;
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union {
    pub operation: CUstreamBatchMemOpType,
    pub waitValue: CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st,
    pub writeValue: CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st,
    pub flushRemoteWrites: CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
    pub memoryBarrier: CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st,
    pub pad: [cuuint64_t; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
    pub flags: ::core::ffi::c_uint,
    pub alias: CUdeviceptr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1 {
    pub value: cuuint32_t,
    pub value64: cuuint64_t,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1(
) {
    const UNINIT: ::core::mem::MaybeUninit<
        CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::core::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value64)
        )
    );
}
impl Default for CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st() {
    const UNINIT: ::core::mem::MaybeUninit<
        CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st),
            "::",
            stringify!(alias)
        )
    );
}
impl Default for CUstreamBatchMemOpParams_union_CUstreamMemOpWaitValueParams_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub address: CUdeviceptr,
    pub __bindgen_anon_1:
        CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
    pub flags: ::core::ffi::c_uint,
    pub alias: CUdeviceptr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1 {
    pub value: cuuint32_t,
    pub value64: cuuint64_t,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1(
) {
    const UNINIT: ::core::mem::MaybeUninit<
        CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::core::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1
            ),
            "::",
            stringify!(value64)
        )
    );
}
impl Default for CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st() {
    const UNINIT: ::core::mem::MaybeUninit<
        CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st),
            "::",
            stringify!(alias)
        )
    );
}
impl Default for CUstreamBatchMemOpParams_union_CUstreamMemOpWriteValueParams_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub flags: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st() {
    const UNINIT: ::core::mem::MaybeUninit<
        CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<
            CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for CUstreamBatchMemOpParams_union_CUstreamMemOpFlushRemoteWritesParams_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st {
    pub operation: CUstreamBatchMemOpType,
    pub flags: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st() {
    const UNINIT: ::core::mem::MaybeUninit<
        CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for CUstreamBatchMemOpParams_union_CUstreamMemOpMemoryBarrierParams_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUstreamBatchMemOpParams_union() {
    const UNINIT: ::core::mem::MaybeUninit<CUstreamBatchMemOpParams_union> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUstreamBatchMemOpParams_union>(),
        48usize,
        concat!("Size of: ", stringify!(CUstreamBatchMemOpParams_union))
    );
    assert_eq!(
        ::core::mem::align_of::<CUstreamBatchMemOpParams_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUstreamBatchMemOpParams_union))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waitValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(waitValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writeValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(writeValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flushRemoteWrites) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(flushRemoteWrites)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memoryBarrier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(memoryBarrier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUstreamBatchMemOpParams_union),
            "::",
            stringify!(pad)
        )
    );
}
impl Default for CUstreamBatchMemOpParams_union {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUstreamBatchMemOpParams_v1 = CUstreamBatchMemOpParams_union;
pub type CUstreamBatchMemOpParams = CUstreamBatchMemOpParams_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st {
    pub ctx: CUcontext,
    pub count: ::core::ffi::c_uint,
    pub paramArray: *mut CUstreamBatchMemOpParams,
    pub flags: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).paramArray) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st),
            "::",
            stringify!(paramArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_BATCH_MEM_OP_NODE_PARAMS_v1 = CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st;
pub type CUDA_BATCH_MEM_OP_NODE_PARAMS = CUDA_BATCH_MEM_OP_NODE_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st {
    pub ctx: CUcontext,
    pub count: ::core::ffi::c_uint,
    pub paramArray: *mut CUstreamBatchMemOpParams,
    pub flags: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).paramArray) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st),
            "::",
            stringify!(paramArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_BATCH_MEM_OP_NODE_PARAMS_v2 = CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUoccupancy_flags_enum {
    CU_OCCUPANCY_DEFAULT = 0,
    CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE = 1,
}
pub use self::CUoccupancy_flags_enum as CUoccupancy_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamUpdateCaptureDependencies_flags_enum {
    CU_STREAM_ADD_CAPTURE_DEPENDENCIES = 0,
    CU_STREAM_SET_CAPTURE_DEPENDENCIES = 1,
}
pub use self::CUstreamUpdateCaptureDependencies_flags_enum as CUstreamUpdateCaptureDependencies_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUarray_format_enum {
    CU_AD_FORMAT_UNSIGNED_INT8 = 1,
    CU_AD_FORMAT_UNSIGNED_INT16 = 2,
    CU_AD_FORMAT_UNSIGNED_INT32 = 3,
    CU_AD_FORMAT_SIGNED_INT8 = 8,
    CU_AD_FORMAT_SIGNED_INT16 = 9,
    CU_AD_FORMAT_SIGNED_INT32 = 10,
    CU_AD_FORMAT_HALF = 16,
    CU_AD_FORMAT_FLOAT = 32,
    CU_AD_FORMAT_NV12 = 176,
    CU_AD_FORMAT_UNORM_INT8X1 = 192,
    CU_AD_FORMAT_UNORM_INT8X2 = 193,
    CU_AD_FORMAT_UNORM_INT8X4 = 194,
    CU_AD_FORMAT_UNORM_INT16X1 = 195,
    CU_AD_FORMAT_UNORM_INT16X2 = 196,
    CU_AD_FORMAT_UNORM_INT16X4 = 197,
    CU_AD_FORMAT_SNORM_INT8X1 = 198,
    CU_AD_FORMAT_SNORM_INT8X2 = 199,
    CU_AD_FORMAT_SNORM_INT8X4 = 200,
    CU_AD_FORMAT_SNORM_INT16X1 = 201,
    CU_AD_FORMAT_SNORM_INT16X2 = 202,
    CU_AD_FORMAT_SNORM_INT16X4 = 203,
    CU_AD_FORMAT_BC1_UNORM = 145,
    CU_AD_FORMAT_BC1_UNORM_SRGB = 146,
    CU_AD_FORMAT_BC2_UNORM = 147,
    CU_AD_FORMAT_BC2_UNORM_SRGB = 148,
    CU_AD_FORMAT_BC3_UNORM = 149,
    CU_AD_FORMAT_BC3_UNORM_SRGB = 150,
    CU_AD_FORMAT_BC4_UNORM = 151,
    CU_AD_FORMAT_BC4_SNORM = 152,
    CU_AD_FORMAT_BC5_UNORM = 153,
    CU_AD_FORMAT_BC5_SNORM = 154,
    CU_AD_FORMAT_BC6H_UF16 = 155,
    CU_AD_FORMAT_BC6H_SF16 = 156,
    CU_AD_FORMAT_BC7_UNORM = 157,
    CU_AD_FORMAT_BC7_UNORM_SRGB = 158,
}
pub use self::CUarray_format_enum as CUarray_format;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUaddress_mode_enum {
    CU_TR_ADDRESS_MODE_WRAP = 0,
    CU_TR_ADDRESS_MODE_CLAMP = 1,
    CU_TR_ADDRESS_MODE_MIRROR = 2,
    CU_TR_ADDRESS_MODE_BORDER = 3,
}
pub use self::CUaddress_mode_enum as CUaddress_mode;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUfilter_mode_enum {
    CU_TR_FILTER_MODE_POINT = 0,
    CU_TR_FILTER_MODE_LINEAR = 1,
}
pub use self::CUfilter_mode_enum as CUfilter_mode;
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS;
}
impl CUdevice_attribute_enum {
    pub const CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED: CUdevice_attribute_enum =
        CUdevice_attribute_enum::CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUdevice_attribute_enum {
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = 2,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = 3,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = 4,
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = 5,
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = 6,
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = 7,
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = 8,
    CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = 9,
    CU_DEVICE_ATTRIBUTE_WARP_SIZE = 10,
    CU_DEVICE_ATTRIBUTE_MAX_PITCH = 11,
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = 12,
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13,
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14,
    CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = 15,
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16,
    CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = 17,
    CU_DEVICE_ATTRIBUTE_INTEGRATED = 18,
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19,
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = 21,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = 22,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = 23,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = 24,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = 25,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = 26,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH = 27,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT = 28,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS = 29,
    CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = 30,
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,
    CU_DEVICE_ATTRIBUTE_ECC_ENABLED = 32,
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33,
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34,
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35,
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36,
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37,
    CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = 38,
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = 39,
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = 42,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = 43,
    CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = 44,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = 45,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = 46,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = 47,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = 48,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = 49,
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = 50,
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = 51,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = 52,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = 53,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = 54,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = 55,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = 56,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = 57,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = 58,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = 59,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = 60,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = 61,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = 62,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = 63,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = 64,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = 65,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = 66,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = 67,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = 68,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = 69,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = 70,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = 71,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = 72,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = 73,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = 74,
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = 75,
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = 76,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = 77,
    CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = 78,
    CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = 79,
    CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = 80,
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = 81,
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82,
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = 83,
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = 84,
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = 85,
    CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED = 86,
    CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO = 87,
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS = 88,
    CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS = 89,
    CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED = 90,
    CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM = 91,
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS_V1 = 92,
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V1 = 93,
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V1 = 94,
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH = 95,
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH = 96,
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN = 97,
    CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES = 98,
    CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED = 99,
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES = 100,
    CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST = 101,
    CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED = 102,
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED = 103,
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED = 104,
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED = 105,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR = 106,
    CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED = 107,
    CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE = 108,
    CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE = 109,
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED = 110,
    CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK = 111,
    CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED = 112,
    CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED = 113,
    CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED = 114,
    CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED = 115,
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED = 116,
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS = 117,
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING = 118,
    CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES = 119,
    CU_DEVICE_ATTRIBUTE_CLUSTER_LAUNCH = 120,
    CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED = 121,
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS = 122,
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR = 123,
    CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED = 124,
    CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED = 125,
    CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT = 126,
    CU_DEVICE_ATTRIBUTE_TENSOR_MAP_ACCESS_SUPPORTED = 127,
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_FABRIC_SUPPORTED = 128,
    CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS = 129,
    CU_DEVICE_ATTRIBUTE_NUMA_CONFIG = 130,
    CU_DEVICE_ATTRIBUTE_NUMA_ID = 131,
    CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED = 132,
    CU_DEVICE_ATTRIBUTE_MPS_ENABLED = 133,
    CU_DEVICE_ATTRIBUTE_HOST_NUMA_ID = 134,
    CU_DEVICE_ATTRIBUTE_MAX = 135,
}
pub use self::CUdevice_attribute_enum as CUdevice_attribute;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUdevprop_st {
    pub maxThreadsPerBlock: ::core::ffi::c_int,
    pub maxThreadsDim: [::core::ffi::c_int; 3usize],
    pub maxGridSize: [::core::ffi::c_int; 3usize],
    pub sharedMemPerBlock: ::core::ffi::c_int,
    pub totalConstantMemory: ::core::ffi::c_int,
    pub SIMDWidth: ::core::ffi::c_int,
    pub memPitch: ::core::ffi::c_int,
    pub regsPerBlock: ::core::ffi::c_int,
    pub clockRate: ::core::ffi::c_int,
    pub textureAlign: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_CUdevprop_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUdevprop_st> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUdevprop_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUdevprop_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUdevprop_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUdevprop_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxThreadsPerBlock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxThreadsDim) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxThreadsDim)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxGridSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(maxGridSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharedMemPerBlock) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(sharedMemPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).totalConstantMemory) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(totalConstantMemory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SIMDWidth) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(SIMDWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memPitch) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(memPitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).regsPerBlock) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(regsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clockRate) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(clockRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).textureAlign) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CUdevprop_st),
            "::",
            stringify!(textureAlign)
        )
    );
}
pub type CUdevprop_v1 = CUdevprop_st;
pub type CUdevprop = CUdevprop_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUpointer_attribute_enum {
    CU_POINTER_ATTRIBUTE_CONTEXT = 1,
    CU_POINTER_ATTRIBUTE_MEMORY_TYPE = 2,
    CU_POINTER_ATTRIBUTE_DEVICE_POINTER = 3,
    CU_POINTER_ATTRIBUTE_HOST_POINTER = 4,
    CU_POINTER_ATTRIBUTE_P2P_TOKENS = 5,
    CU_POINTER_ATTRIBUTE_SYNC_MEMOPS = 6,
    CU_POINTER_ATTRIBUTE_BUFFER_ID = 7,
    CU_POINTER_ATTRIBUTE_IS_MANAGED = 8,
    CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL = 9,
    CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE = 10,
    CU_POINTER_ATTRIBUTE_RANGE_START_ADDR = 11,
    CU_POINTER_ATTRIBUTE_RANGE_SIZE = 12,
    CU_POINTER_ATTRIBUTE_MAPPED = 13,
    CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = 14,
    CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = 15,
    CU_POINTER_ATTRIBUTE_ACCESS_FLAGS = 16,
    CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = 17,
    CU_POINTER_ATTRIBUTE_MAPPING_SIZE = 18,
    CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR = 19,
    CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID = 20,
}
pub use self::CUpointer_attribute_enum as CUpointer_attribute;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUfunction_attribute_enum {
    CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,
    CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,
    CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,
    CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,
    CU_FUNC_ATTRIBUTE_NUM_REGS = 4,
    CU_FUNC_ATTRIBUTE_PTX_VERSION = 5,
    CU_FUNC_ATTRIBUTE_BINARY_VERSION = 6,
    CU_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,
    CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = 8,
    CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 9,
    CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET = 10,
    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH = 11,
    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT = 12,
    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH = 13,
    CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED = 14,
    CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = 15,
    CU_FUNC_ATTRIBUTE_MAX = 16,
}
pub use self::CUfunction_attribute_enum as CUfunction_attribute;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUfunc_cache_enum {
    CU_FUNC_CACHE_PREFER_NONE = 0,
    CU_FUNC_CACHE_PREFER_SHARED = 1,
    CU_FUNC_CACHE_PREFER_L1 = 2,
    CU_FUNC_CACHE_PREFER_EQUAL = 3,
}
pub use self::CUfunc_cache_enum as CUfunc_cache;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUsharedconfig_enum {
    CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE = 0,
    CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE = 1,
    CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE = 2,
}
pub use self::CUsharedconfig_enum as CUsharedconfig;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUshared_carveout_enum {
    CU_SHAREDMEM_CARVEOUT_DEFAULT = -1,
    CU_SHAREDMEM_CARVEOUT_MAX_SHARED = 100,
    CU_SHAREDMEM_CARVEOUT_MAX_L1 = 0,
}
pub use self::CUshared_carveout_enum as CUshared_carveout;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemorytype_enum {
    CU_MEMORYTYPE_HOST = 1,
    CU_MEMORYTYPE_DEVICE = 2,
    CU_MEMORYTYPE_ARRAY = 3,
    CU_MEMORYTYPE_UNIFIED = 4,
}
pub use self::CUmemorytype_enum as CUmemorytype;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUcomputemode_enum {
    CU_COMPUTEMODE_DEFAULT = 0,
    CU_COMPUTEMODE_PROHIBITED = 2,
    CU_COMPUTEMODE_EXCLUSIVE_PROCESS = 3,
}
pub use self::CUcomputemode_enum as CUcomputemode;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmem_advise_enum {
    CU_MEM_ADVISE_SET_READ_MOSTLY = 1,
    CU_MEM_ADVISE_UNSET_READ_MOSTLY = 2,
    CU_MEM_ADVISE_SET_PREFERRED_LOCATION = 3,
    CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION = 4,
    CU_MEM_ADVISE_SET_ACCESSED_BY = 5,
    CU_MEM_ADVISE_UNSET_ACCESSED_BY = 6,
}
pub use self::CUmem_advise_enum as CUmem_advise;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmem_range_attribute_enum {
    CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY = 1,
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION = 2,
    CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY = 3,
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION = 4,
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE = 5,
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID = 6,
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE = 7,
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID = 8,
}
pub use self::CUmem_range_attribute_enum as CUmem_range_attribute;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUjit_option_enum {
    CU_JIT_MAX_REGISTERS = 0,
    CU_JIT_THREADS_PER_BLOCK = 1,
    CU_JIT_WALL_TIME = 2,
    CU_JIT_INFO_LOG_BUFFER = 3,
    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES = 4,
    CU_JIT_ERROR_LOG_BUFFER = 5,
    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES = 6,
    CU_JIT_OPTIMIZATION_LEVEL = 7,
    CU_JIT_TARGET_FROM_CUCONTEXT = 8,
    CU_JIT_TARGET = 9,
    CU_JIT_FALLBACK_STRATEGY = 10,
    CU_JIT_GENERATE_DEBUG_INFO = 11,
    CU_JIT_LOG_VERBOSE = 12,
    CU_JIT_GENERATE_LINE_INFO = 13,
    CU_JIT_CACHE_MODE = 14,
    CU_JIT_NEW_SM3X_OPT = 15,
    CU_JIT_FAST_COMPILE = 16,
    CU_JIT_GLOBAL_SYMBOL_NAMES = 17,
    CU_JIT_GLOBAL_SYMBOL_ADDRESSES = 18,
    CU_JIT_GLOBAL_SYMBOL_COUNT = 19,
    CU_JIT_LTO = 20,
    CU_JIT_FTZ = 21,
    CU_JIT_PREC_DIV = 22,
    CU_JIT_PREC_SQRT = 23,
    CU_JIT_FMA = 24,
    CU_JIT_REFERENCED_KERNEL_NAMES = 25,
    CU_JIT_REFERENCED_KERNEL_COUNT = 26,
    CU_JIT_REFERENCED_VARIABLE_NAMES = 27,
    CU_JIT_REFERENCED_VARIABLE_COUNT = 28,
    CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES = 29,
    CU_JIT_POSITION_INDEPENDENT_CODE = 30,
    CU_JIT_MIN_CTA_PER_SM = 31,
    CU_JIT_NUM_OPTIONS = 32,
}
pub use self::CUjit_option_enum as CUjit_option;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUjit_target_enum {
    CU_TARGET_COMPUTE_30 = 30,
    CU_TARGET_COMPUTE_32 = 32,
    CU_TARGET_COMPUTE_35 = 35,
    CU_TARGET_COMPUTE_37 = 37,
    CU_TARGET_COMPUTE_50 = 50,
    CU_TARGET_COMPUTE_52 = 52,
    CU_TARGET_COMPUTE_53 = 53,
    CU_TARGET_COMPUTE_60 = 60,
    CU_TARGET_COMPUTE_61 = 61,
    CU_TARGET_COMPUTE_62 = 62,
    CU_TARGET_COMPUTE_70 = 70,
    CU_TARGET_COMPUTE_72 = 72,
    CU_TARGET_COMPUTE_75 = 75,
    CU_TARGET_COMPUTE_80 = 80,
    CU_TARGET_COMPUTE_86 = 86,
    CU_TARGET_COMPUTE_87 = 87,
    CU_TARGET_COMPUTE_89 = 89,
    CU_TARGET_COMPUTE_90 = 90,
    CU_TARGET_COMPUTE_90A = 65626,
}
pub use self::CUjit_target_enum as CUjit_target;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUjit_fallback_enum {
    CU_PREFER_PTX = 0,
    CU_PREFER_BINARY = 1,
}
pub use self::CUjit_fallback_enum as CUjit_fallback;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUjit_cacheMode_enum {
    CU_JIT_CACHE_OPTION_NONE = 0,
    CU_JIT_CACHE_OPTION_CG = 1,
    CU_JIT_CACHE_OPTION_CA = 2,
}
pub use self::CUjit_cacheMode_enum as CUjit_cacheMode;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUjitInputType_enum {
    CU_JIT_INPUT_CUBIN = 0,
    CU_JIT_INPUT_PTX = 1,
    CU_JIT_INPUT_FATBINARY = 2,
    CU_JIT_INPUT_OBJECT = 3,
    CU_JIT_INPUT_LIBRARY = 4,
    CU_JIT_INPUT_NVVM = 5,
    CU_JIT_NUM_INPUT_TYPES = 6,
}
pub use self::CUjitInputType_enum as CUjitInputType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlinkState_st {
    _unused: [u8; 0],
}
pub type CUlinkState = *mut CUlinkState_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphicsRegisterFlags_enum {
    CU_GRAPHICS_REGISTER_FLAGS_NONE = 0,
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY = 1,
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD = 2,
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 4,
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 8,
}
pub use self::CUgraphicsRegisterFlags_enum as CUgraphicsRegisterFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphicsMapResourceFlags_enum {
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE = 0,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY = 1,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = 2,
}
pub use self::CUgraphicsMapResourceFlags_enum as CUgraphicsMapResourceFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUarray_cubemap_face_enum {
    CU_CUBEMAP_FACE_POSITIVE_X = 0,
    CU_CUBEMAP_FACE_NEGATIVE_X = 1,
    CU_CUBEMAP_FACE_POSITIVE_Y = 2,
    CU_CUBEMAP_FACE_NEGATIVE_Y = 3,
    CU_CUBEMAP_FACE_POSITIVE_Z = 4,
    CU_CUBEMAP_FACE_NEGATIVE_Z = 5,
}
pub use self::CUarray_cubemap_face_enum as CUarray_cubemap_face;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUlimit_enum {
    CU_LIMIT_STACK_SIZE = 0,
    CU_LIMIT_PRINTF_FIFO_SIZE = 1,
    CU_LIMIT_MALLOC_HEAP_SIZE = 2,
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH = 3,
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = 4,
    CU_LIMIT_MAX_L2_FETCH_GRANULARITY = 5,
    CU_LIMIT_PERSISTING_L2_CACHE_SIZE = 6,
    CU_LIMIT_MAX = 7,
}
pub use self::CUlimit_enum as CUlimit;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUresourcetype_enum {
    CU_RESOURCE_TYPE_ARRAY = 0,
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 1,
    CU_RESOURCE_TYPE_LINEAR = 2,
    CU_RESOURCE_TYPE_PITCH2D = 3,
}
pub use self::CUresourcetype_enum as CUresourcetype;
pub type CUhostFn =
    ::core::option::Option<unsafe extern "C" fn(userData: *mut ::core::ffi::c_void)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUaccessProperty_enum {
    CU_ACCESS_PROPERTY_NORMAL = 0,
    CU_ACCESS_PROPERTY_STREAMING = 1,
    CU_ACCESS_PROPERTY_PERSISTING = 2,
}
pub use self::CUaccessProperty_enum as CUaccessProperty;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct CUaccessPolicyWindow_st {
    pub base_ptr: *mut ::core::ffi::c_void,
    pub num_bytes: usize,
    pub hitRatio: f32,
    pub hitProp: CUaccessProperty,
    pub missProp: CUaccessProperty,
}
#[test]
fn bindgen_test_layout_CUaccessPolicyWindow_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUaccessPolicyWindow_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUaccessPolicyWindow_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUaccessPolicyWindow_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUaccessPolicyWindow_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUaccessPolicyWindow_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(base_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_bytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(num_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hitRatio) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(hitRatio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hitProp) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(hitProp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).missProp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUaccessPolicyWindow_st),
            "::",
            stringify!(missProp)
        )
    );
}
impl Default for CUaccessPolicyWindow_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUaccessPolicyWindow_v1 = CUaccessPolicyWindow_st;
pub type CUaccessPolicyWindow = CUaccessPolicyWindow_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_KERNEL_NODE_PARAMS_st {
    pub func: CUfunction,
    pub gridDimX: ::core::ffi::c_uint,
    pub gridDimY: ::core::ffi::c_uint,
    pub gridDimZ: ::core::ffi::c_uint,
    pub blockDimX: ::core::ffi::c_uint,
    pub blockDimY: ::core::ffi::c_uint,
    pub blockDimZ: ::core::ffi::c_uint,
    pub sharedMemBytes: ::core::ffi::c_uint,
    pub kernelParams: *mut *mut ::core::ffi::c_void,
    pub extra: *mut *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_KERNEL_NODE_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_KERNEL_NODE_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_KERNEL_NODE_PARAMS_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUDA_KERNEL_NODE_PARAMS_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_KERNEL_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_KERNEL_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimX) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimY) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimZ) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(kernelParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_st),
            "::",
            stringify!(extra)
        )
    );
}
impl Default for CUDA_KERNEL_NODE_PARAMS_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_KERNEL_NODE_PARAMS_v1 = CUDA_KERNEL_NODE_PARAMS_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_KERNEL_NODE_PARAMS_v2_st {
    pub func: CUfunction,
    pub gridDimX: ::core::ffi::c_uint,
    pub gridDimY: ::core::ffi::c_uint,
    pub gridDimZ: ::core::ffi::c_uint,
    pub blockDimX: ::core::ffi::c_uint,
    pub blockDimY: ::core::ffi::c_uint,
    pub blockDimZ: ::core::ffi::c_uint,
    pub sharedMemBytes: ::core::ffi::c_uint,
    pub kernelParams: *mut *mut ::core::ffi::c_void,
    pub extra: *mut *mut ::core::ffi::c_void,
    pub kern: CUkernel,
    pub ctx: CUcontext,
}
#[test]
fn bindgen_test_layout_CUDA_KERNEL_NODE_PARAMS_v2_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_KERNEL_NODE_PARAMS_v2_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_KERNEL_NODE_PARAMS_v2_st>(),
        72usize,
        concat!("Size of: ", stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_KERNEL_NODE_PARAMS_v2_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimX) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimY) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimZ) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(kernelParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kern) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(kern)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v2_st),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for CUDA_KERNEL_NODE_PARAMS_v2_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_KERNEL_NODE_PARAMS_v2 = CUDA_KERNEL_NODE_PARAMS_v2_st;
pub type CUDA_KERNEL_NODE_PARAMS = CUDA_KERNEL_NODE_PARAMS_v2;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_KERNEL_NODE_PARAMS_v3_st {
    pub func: CUfunction,
    pub gridDimX: ::core::ffi::c_uint,
    pub gridDimY: ::core::ffi::c_uint,
    pub gridDimZ: ::core::ffi::c_uint,
    pub blockDimX: ::core::ffi::c_uint,
    pub blockDimY: ::core::ffi::c_uint,
    pub blockDimZ: ::core::ffi::c_uint,
    pub sharedMemBytes: ::core::ffi::c_uint,
    pub kernelParams: *mut *mut ::core::ffi::c_void,
    pub extra: *mut *mut ::core::ffi::c_void,
    pub kern: CUkernel,
    pub ctx: CUcontext,
}
#[test]
fn bindgen_test_layout_CUDA_KERNEL_NODE_PARAMS_v3_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_KERNEL_NODE_PARAMS_v3_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_KERNEL_NODE_PARAMS_v3_st>(),
        72usize,
        concat!("Size of: ", stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_KERNEL_NODE_PARAMS_v3_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimX) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimY) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimZ) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st),
            "::",
            stringify!(kernelParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kern) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st),
            "::",
            stringify!(kern)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_KERNEL_NODE_PARAMS_v3_st),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for CUDA_KERNEL_NODE_PARAMS_v3_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_KERNEL_NODE_PARAMS_v3 = CUDA_KERNEL_NODE_PARAMS_v3_st;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_MEMSET_NODE_PARAMS_st {
    pub dst: CUdeviceptr,
    pub pitch: usize,
    pub value: ::core::ffi::c_uint,
    pub elementSize: ::core::ffi::c_uint,
    pub width: usize,
    pub height: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMSET_NODE_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_MEMSET_NODE_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_MEMSET_NODE_PARAMS_st>(),
        40usize,
        concat!("Size of: ", stringify!(CUDA_MEMSET_NODE_PARAMS_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_MEMSET_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMSET_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).elementSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(elementSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_st),
            "::",
            stringify!(height)
        )
    );
}
pub type CUDA_MEMSET_NODE_PARAMS_v1 = CUDA_MEMSET_NODE_PARAMS_st;
pub type CUDA_MEMSET_NODE_PARAMS = CUDA_MEMSET_NODE_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_MEMSET_NODE_PARAMS_v2_st {
    pub dst: CUdeviceptr,
    pub pitch: usize,
    pub value: ::core::ffi::c_uint,
    pub elementSize: ::core::ffi::c_uint,
    pub width: usize,
    pub height: usize,
    pub ctx: CUcontext,
}
#[test]
fn bindgen_test_layout_CUDA_MEMSET_NODE_PARAMS_v2_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_MEMSET_NODE_PARAMS_v2_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_MEMSET_NODE_PARAMS_v2_st>(),
        48usize,
        concat!("Size of: ", stringify!(CUDA_MEMSET_NODE_PARAMS_v2_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_MEMSET_NODE_PARAMS_v2_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMSET_NODE_PARAMS_v2_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_v2_st),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_v2_st),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_v2_st),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).elementSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_v2_st),
            "::",
            stringify!(elementSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_v2_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_v2_st),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMSET_NODE_PARAMS_v2_st),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for CUDA_MEMSET_NODE_PARAMS_v2_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_MEMSET_NODE_PARAMS_v2 = CUDA_MEMSET_NODE_PARAMS_v2_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_HOST_NODE_PARAMS_st {
    pub fn_: CUhostFn,
    pub userData: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_HOST_NODE_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_HOST_NODE_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_HOST_NODE_PARAMS_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUDA_HOST_NODE_PARAMS_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_HOST_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_HOST_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_HOST_NODE_PARAMS_st),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).userData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_HOST_NODE_PARAMS_st),
            "::",
            stringify!(userData)
        )
    );
}
impl Default for CUDA_HOST_NODE_PARAMS_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_HOST_NODE_PARAMS_v1 = CUDA_HOST_NODE_PARAMS_st;
pub type CUDA_HOST_NODE_PARAMS = CUDA_HOST_NODE_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_HOST_NODE_PARAMS_v2_st {
    pub fn_: CUhostFn,
    pub userData: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_HOST_NODE_PARAMS_v2_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_HOST_NODE_PARAMS_v2_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_HOST_NODE_PARAMS_v2_st>(),
        16usize,
        concat!("Size of: ", stringify!(CUDA_HOST_NODE_PARAMS_v2_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_HOST_NODE_PARAMS_v2_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_HOST_NODE_PARAMS_v2_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_HOST_NODE_PARAMS_v2_st),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).userData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_HOST_NODE_PARAMS_v2_st),
            "::",
            stringify!(userData)
        )
    );
}
impl Default for CUDA_HOST_NODE_PARAMS_v2_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_HOST_NODE_PARAMS_v2 = CUDA_HOST_NODE_PARAMS_v2_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphConditionalNodeType_enum {
    CU_GRAPH_COND_TYPE_IF = 0,
    CU_GRAPH_COND_TYPE_WHILE = 1,
}
pub use self::CUgraphConditionalNodeType_enum as CUgraphConditionalNodeType;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_CONDITIONAL_NODE_PARAMS {
    pub handle: CUgraphConditionalHandle,
    pub type_: CUgraphConditionalNodeType,
    pub size: ::core::ffi::c_uint,
    pub phGraph_out: *mut CUgraph,
    pub ctx: CUcontext,
}
#[test]
fn bindgen_test_layout_CUDA_CONDITIONAL_NODE_PARAMS() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_CONDITIONAL_NODE_PARAMS> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_CONDITIONAL_NODE_PARAMS>(),
        32usize,
        concat!("Size of: ", stringify!(CUDA_CONDITIONAL_NODE_PARAMS))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_CONDITIONAL_NODE_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_CONDITIONAL_NODE_PARAMS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_CONDITIONAL_NODE_PARAMS),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_CONDITIONAL_NODE_PARAMS),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_CONDITIONAL_NODE_PARAMS),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phGraph_out) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_CONDITIONAL_NODE_PARAMS),
            "::",
            stringify!(phGraph_out)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_CONDITIONAL_NODE_PARAMS),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for CUDA_CONDITIONAL_NODE_PARAMS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphNodeType_enum {
    CU_GRAPH_NODE_TYPE_KERNEL = 0,
    CU_GRAPH_NODE_TYPE_MEMCPY = 1,
    CU_GRAPH_NODE_TYPE_MEMSET = 2,
    CU_GRAPH_NODE_TYPE_HOST = 3,
    CU_GRAPH_NODE_TYPE_GRAPH = 4,
    CU_GRAPH_NODE_TYPE_EMPTY = 5,
    CU_GRAPH_NODE_TYPE_WAIT_EVENT = 6,
    CU_GRAPH_NODE_TYPE_EVENT_RECORD = 7,
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL = 8,
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT = 9,
    CU_GRAPH_NODE_TYPE_MEM_ALLOC = 10,
    CU_GRAPH_NODE_TYPE_MEM_FREE = 11,
    CU_GRAPH_NODE_TYPE_BATCH_MEM_OP = 12,
    CU_GRAPH_NODE_TYPE_CONDITIONAL = 13,
}
pub use self::CUgraphNodeType_enum as CUgraphNodeType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphDependencyType_enum {
    CU_GRAPH_DEPENDENCY_TYPE_DEFAULT = 0,
    CU_GRAPH_DEPENDENCY_TYPE_PROGRAMMATIC = 1,
}
pub use self::CUgraphDependencyType_enum as CUgraphDependencyType;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUgraphEdgeData_st {
    pub from_port: ::core::ffi::c_uchar,
    pub to_port: ::core::ffi::c_uchar,
    pub type_: ::core::ffi::c_uchar,
    pub reserved: [::core::ffi::c_uchar; 5usize],
}
#[test]
fn bindgen_test_layout_CUgraphEdgeData_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUgraphEdgeData_st> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUgraphEdgeData_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUgraphEdgeData_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUgraphEdgeData_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUgraphEdgeData_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).from_port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphEdgeData_st),
            "::",
            stringify!(from_port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).to_port) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphEdgeData_st),
            "::",
            stringify!(to_port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphEdgeData_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphEdgeData_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUgraphEdgeData = CUgraphEdgeData_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphInstantiateResult_enum {
    CUDA_GRAPH_INSTANTIATE_SUCCESS = 0,
    CUDA_GRAPH_INSTANTIATE_ERROR = 1,
    CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE = 2,
    CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED = 3,
    CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED = 4,
}
pub use self::CUgraphInstantiateResult_enum as CUgraphInstantiateResult;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_GRAPH_INSTANTIATE_PARAMS_st {
    pub flags: cuuint64_t,
    pub hUploadStream: CUstream,
    pub hErrNode_out: CUgraphNode,
    pub result_out: CUgraphInstantiateResult,
}
#[test]
fn bindgen_test_layout_CUDA_GRAPH_INSTANTIATE_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_GRAPH_INSTANTIATE_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_GRAPH_INSTANTIATE_PARAMS_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUDA_GRAPH_INSTANTIATE_PARAMS_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_GRAPH_INSTANTIATE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_GRAPH_INSTANTIATE_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_GRAPH_INSTANTIATE_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hUploadStream) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_GRAPH_INSTANTIATE_PARAMS_st),
            "::",
            stringify!(hUploadStream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hErrNode_out) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_GRAPH_INSTANTIATE_PARAMS_st),
            "::",
            stringify!(hErrNode_out)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).result_out) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_GRAPH_INSTANTIATE_PARAMS_st),
            "::",
            stringify!(result_out)
        )
    );
}
impl Default for CUDA_GRAPH_INSTANTIATE_PARAMS_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_GRAPH_INSTANTIATE_PARAMS = CUDA_GRAPH_INSTANTIATE_PARAMS_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUsynchronizationPolicy_enum {
    CU_SYNC_POLICY_AUTO = 1,
    CU_SYNC_POLICY_SPIN = 2,
    CU_SYNC_POLICY_YIELD = 3,
    CU_SYNC_POLICY_BLOCKING_SYNC = 4,
}
pub use self::CUsynchronizationPolicy_enum as CUsynchronizationPolicy;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUclusterSchedulingPolicy_enum {
    CU_CLUSTER_SCHEDULING_POLICY_DEFAULT = 0,
    CU_CLUSTER_SCHEDULING_POLICY_SPREAD = 1,
    CU_CLUSTER_SCHEDULING_POLICY_LOAD_BALANCING = 2,
}
pub use self::CUclusterSchedulingPolicy_enum as CUclusterSchedulingPolicy;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUlaunchMemSyncDomain_enum {
    CU_LAUNCH_MEM_SYNC_DOMAIN_DEFAULT = 0,
    CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE = 1,
}
pub use self::CUlaunchMemSyncDomain_enum as CUlaunchMemSyncDomain;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUlaunchMemSyncDomainMap_st {
    pub default_: ::core::ffi::c_uchar,
    pub remote: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_CUlaunchMemSyncDomainMap_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUlaunchMemSyncDomainMap_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUlaunchMemSyncDomainMap_st>(),
        2usize,
        concat!("Size of: ", stringify!(CUlaunchMemSyncDomainMap_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUlaunchMemSyncDomainMap_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUlaunchMemSyncDomainMap_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchMemSyncDomainMap_st),
            "::",
            stringify!(default_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remote) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchMemSyncDomainMap_st),
            "::",
            stringify!(remote)
        )
    );
}
pub type CUlaunchMemSyncDomainMap = CUlaunchMemSyncDomainMap_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUlaunchAttributeID_enum {
    CU_LAUNCH_ATTRIBUTE_IGNORE = 0,
    CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW = 1,
    CU_LAUNCH_ATTRIBUTE_COOPERATIVE = 2,
    CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY = 3,
    CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION = 4,
    CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = 5,
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION = 6,
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT = 7,
    CU_LAUNCH_ATTRIBUTE_PRIORITY = 8,
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP = 9,
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN = 10,
    CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT = 12,
}
pub use self::CUlaunchAttributeID_enum as CUlaunchAttributeID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUlaunchAttributeValue_union {
    pub pad: [::core::ffi::c_char; 64usize],
    pub accessPolicyWindow: CUaccessPolicyWindow,
    pub cooperative: ::core::ffi::c_int,
    pub syncPolicy: CUsynchronizationPolicy,
    pub clusterDim: CUlaunchAttributeValue_union__bindgen_ty_1,
    pub clusterSchedulingPolicyPreference: CUclusterSchedulingPolicy,
    pub programmaticStreamSerializationAllowed: ::core::ffi::c_int,
    pub programmaticEvent: CUlaunchAttributeValue_union__bindgen_ty_2,
    pub launchCompletionEvent: CUlaunchAttributeValue_union__bindgen_ty_3,
    pub priority: ::core::ffi::c_int,
    pub memSyncDomainMap: CUlaunchMemSyncDomainMap,
    pub memSyncDomain: CUlaunchMemSyncDomain,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_1 {
    pub x: ::core::ffi::c_uint,
    pub y: ::core::ffi::c_uint,
    pub z: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUlaunchAttributeValue_union__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUlaunchAttributeValue_union__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_1),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_2 {
    pub event: CUevent,
    pub flags: ::core::ffi::c_int,
    pub triggerAtBlockStart: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_CUlaunchAttributeValue_union__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<CUlaunchAttributeValue_union__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_2),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).triggerAtBlockStart) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_2),
            "::",
            stringify!(triggerAtBlockStart)
        )
    );
}
impl Default for CUlaunchAttributeValue_union__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_3 {
    pub event: CUevent,
    pub flags: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_CUlaunchAttributeValue_union__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<CUlaunchAttributeValue_union__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_3),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union__bindgen_ty_3),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for CUlaunchAttributeValue_union__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUlaunchAttributeValue_union() {
    const UNINIT: ::core::mem::MaybeUninit<CUlaunchAttributeValue_union> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUlaunchAttributeValue_union>(),
        64usize,
        concat!("Size of: ", stringify!(CUlaunchAttributeValue_union))
    );
    assert_eq!(
        ::core::mem::align_of::<CUlaunchAttributeValue_union>(),
        8usize,
        concat!("Alignment of ", stringify!(CUlaunchAttributeValue_union))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accessPolicyWindow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(accessPolicyWindow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cooperative) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(cooperative)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).syncPolicy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(syncPolicy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clusterDim) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(clusterDim)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).clusterSchedulingPolicyPreference) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(clusterSchedulingPolicyPreference)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).programmaticStreamSerializationAllowed) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(programmaticStreamSerializationAllowed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).programmaticEvent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(programmaticEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).launchCompletionEvent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(launchCompletionEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memSyncDomainMap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(memSyncDomainMap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memSyncDomain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttributeValue_union),
            "::",
            stringify!(memSyncDomain)
        )
    );
}
impl Default for CUlaunchAttributeValue_union {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUlaunchAttributeValue = CUlaunchAttributeValue_union;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUlaunchAttribute_st {
    pub id: CUlaunchAttributeID,
    pub pad: [::core::ffi::c_char; 4usize],
    pub value: CUlaunchAttributeValue,
}
#[test]
fn bindgen_test_layout_CUlaunchAttribute_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUlaunchAttribute_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUlaunchAttribute_st>(),
        72usize,
        concat!("Size of: ", stringify!(CUlaunchAttribute_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUlaunchAttribute_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUlaunchAttribute_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttribute_st),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttribute_st),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchAttribute_st),
            "::",
            stringify!(value)
        )
    );
}
impl Default for CUlaunchAttribute_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUlaunchAttribute = CUlaunchAttribute_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUlaunchConfig_st {
    pub gridDimX: ::core::ffi::c_uint,
    pub gridDimY: ::core::ffi::c_uint,
    pub gridDimZ: ::core::ffi::c_uint,
    pub blockDimX: ::core::ffi::c_uint,
    pub blockDimY: ::core::ffi::c_uint,
    pub blockDimZ: ::core::ffi::c_uint,
    pub sharedMemBytes: ::core::ffi::c_uint,
    pub hStream: CUstream,
    pub attrs: *mut CUlaunchAttribute,
    pub numAttrs: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUlaunchConfig_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUlaunchConfig_st> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUlaunchConfig_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUlaunchConfig_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUlaunchConfig_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUlaunchConfig_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimZ) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimZ) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hStream) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(hStream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attrs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(attrs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numAttrs) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlaunchConfig_st),
            "::",
            stringify!(numAttrs)
        )
    );
}
impl Default for CUlaunchConfig_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUlaunchConfig = CUlaunchConfig_st;
pub use self::CUlaunchAttributeID as CUkernelNodeAttrID;
pub type CUkernelNodeAttrValue_v1 = CUlaunchAttributeValue;
pub type CUkernelNodeAttrValue = CUkernelNodeAttrValue_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamCaptureStatus_enum {
    CU_STREAM_CAPTURE_STATUS_NONE = 0,
    CU_STREAM_CAPTURE_STATUS_ACTIVE = 1,
    CU_STREAM_CAPTURE_STATUS_INVALIDATED = 2,
}
pub use self::CUstreamCaptureStatus_enum as CUstreamCaptureStatus;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUstreamCaptureMode_enum {
    CU_STREAM_CAPTURE_MODE_GLOBAL = 0,
    CU_STREAM_CAPTURE_MODE_THREAD_LOCAL = 1,
    CU_STREAM_CAPTURE_MODE_RELAXED = 2,
}
pub use self::CUlaunchAttributeID as CUstreamAttrID;
pub use self::CUstreamCaptureMode_enum as CUstreamCaptureMode;
pub type CUstreamAttrValue_v1 = CUlaunchAttributeValue;
pub type CUstreamAttrValue = CUstreamAttrValue_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUdriverProcAddress_flags_enum {
    CU_GET_PROC_ADDRESS_DEFAULT = 0,
    CU_GET_PROC_ADDRESS_LEGACY_STREAM = 1,
    CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM = 2,
}
pub use self::CUdriverProcAddress_flags_enum as CUdriverProcAddress_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUdriverProcAddressQueryResult_enum {
    CU_GET_PROC_ADDRESS_SUCCESS = 0,
    CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND = 1,
    CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT = 2,
}
pub use self::CUdriverProcAddressQueryResult_enum as CUdriverProcAddressQueryResult;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUexecAffinityType_enum {
    CU_EXEC_AFFINITY_TYPE_SM_COUNT = 0,
    CU_EXEC_AFFINITY_TYPE_MAX = 1,
}
pub use self::CUexecAffinityType_enum as CUexecAffinityType;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUexecAffinitySmCount_st {
    pub val: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUexecAffinitySmCount_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUexecAffinitySmCount_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUexecAffinitySmCount_st>(),
        4usize,
        concat!("Size of: ", stringify!(CUexecAffinitySmCount_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUexecAffinitySmCount_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUexecAffinitySmCount_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinitySmCount_st),
            "::",
            stringify!(val)
        )
    );
}
pub type CUexecAffinitySmCount_v1 = CUexecAffinitySmCount_st;
pub type CUexecAffinitySmCount = CUexecAffinitySmCount_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUexecAffinityParam_st {
    pub type_: CUexecAffinityType,
    pub param: CUexecAffinityParam_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUexecAffinityParam_st__bindgen_ty_1 {
    pub smCount: CUexecAffinitySmCount,
}
#[test]
fn bindgen_test_layout_CUexecAffinityParam_st__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUexecAffinityParam_st__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUexecAffinityParam_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUexecAffinityParam_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).smCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinityParam_st__bindgen_ty_1),
            "::",
            stringify!(smCount)
        )
    );
}
impl Default for CUexecAffinityParam_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUexecAffinityParam_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUexecAffinityParam_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUexecAffinityParam_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUexecAffinityParam_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUexecAffinityParam_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUexecAffinityParam_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinityParam_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUexecAffinityParam_st),
            "::",
            stringify!(param)
        )
    );
}
impl Default for CUexecAffinityParam_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUexecAffinityParam_v1 = CUexecAffinityParam_st;
pub type CUexecAffinityParam = CUexecAffinityParam_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUlibraryOption_enum {
    CU_LIBRARY_HOST_UNIVERSAL_FUNCTION_AND_DATA_TABLE = 0,
    CU_LIBRARY_BINARY_IS_PRESERVED = 1,
    CU_LIBRARY_NUM_OPTIONS = 2,
}
pub use self::CUlibraryOption_enum as CUlibraryOption;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUlibraryHostUniversalFunctionAndDataTable_st {
    pub functionTable: *mut ::core::ffi::c_void,
    pub functionWindowSize: usize,
    pub dataTable: *mut ::core::ffi::c_void,
    pub dataWindowSize: usize,
}
#[test]
fn bindgen_test_layout_CUlibraryHostUniversalFunctionAndDataTable_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUlibraryHostUniversalFunctionAndDataTable_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUlibraryHostUniversalFunctionAndDataTable_st>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(CUlibraryHostUniversalFunctionAndDataTable_st)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUlibraryHostUniversalFunctionAndDataTable_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUlibraryHostUniversalFunctionAndDataTable_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).functionTable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlibraryHostUniversalFunctionAndDataTable_st),
            "::",
            stringify!(functionTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).functionWindowSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlibraryHostUniversalFunctionAndDataTable_st),
            "::",
            stringify!(functionWindowSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dataTable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlibraryHostUniversalFunctionAndDataTable_st),
            "::",
            stringify!(dataTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dataWindowSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUlibraryHostUniversalFunctionAndDataTable_st),
            "::",
            stringify!(dataWindowSize)
        )
    );
}
impl Default for CUlibraryHostUniversalFunctionAndDataTable_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUlibraryHostUniversalFunctionAndDataTable = CUlibraryHostUniversalFunctionAndDataTable_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum cudaError_enum {
    CUDA_SUCCESS = 0,
    CUDA_ERROR_INVALID_VALUE = 1,
    CUDA_ERROR_OUT_OF_MEMORY = 2,
    CUDA_ERROR_NOT_INITIALIZED = 3,
    CUDA_ERROR_DEINITIALIZED = 4,
    CUDA_ERROR_PROFILER_DISABLED = 5,
    CUDA_ERROR_PROFILER_NOT_INITIALIZED = 6,
    CUDA_ERROR_PROFILER_ALREADY_STARTED = 7,
    CUDA_ERROR_PROFILER_ALREADY_STOPPED = 8,
    CUDA_ERROR_STUB_LIBRARY = 34,
    CUDA_ERROR_DEVICE_UNAVAILABLE = 46,
    CUDA_ERROR_NO_DEVICE = 100,
    CUDA_ERROR_INVALID_DEVICE = 101,
    CUDA_ERROR_DEVICE_NOT_LICENSED = 102,
    CUDA_ERROR_INVALID_IMAGE = 200,
    CUDA_ERROR_INVALID_CONTEXT = 201,
    CUDA_ERROR_CONTEXT_ALREADY_CURRENT = 202,
    CUDA_ERROR_MAP_FAILED = 205,
    CUDA_ERROR_UNMAP_FAILED = 206,
    CUDA_ERROR_ARRAY_IS_MAPPED = 207,
    CUDA_ERROR_ALREADY_MAPPED = 208,
    CUDA_ERROR_NO_BINARY_FOR_GPU = 209,
    CUDA_ERROR_ALREADY_ACQUIRED = 210,
    CUDA_ERROR_NOT_MAPPED = 211,
    CUDA_ERROR_NOT_MAPPED_AS_ARRAY = 212,
    CUDA_ERROR_NOT_MAPPED_AS_POINTER = 213,
    CUDA_ERROR_ECC_UNCORRECTABLE = 214,
    CUDA_ERROR_UNSUPPORTED_LIMIT = 215,
    CUDA_ERROR_CONTEXT_ALREADY_IN_USE = 216,
    CUDA_ERROR_PEER_ACCESS_UNSUPPORTED = 217,
    CUDA_ERROR_INVALID_PTX = 218,
    CUDA_ERROR_INVALID_GRAPHICS_CONTEXT = 219,
    CUDA_ERROR_NVLINK_UNCORRECTABLE = 220,
    CUDA_ERROR_JIT_COMPILER_NOT_FOUND = 221,
    CUDA_ERROR_UNSUPPORTED_PTX_VERSION = 222,
    CUDA_ERROR_JIT_COMPILATION_DISABLED = 223,
    CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY = 224,
    CUDA_ERROR_UNSUPPORTED_DEVSIDE_SYNC = 225,
    CUDA_ERROR_INVALID_SOURCE = 300,
    CUDA_ERROR_FILE_NOT_FOUND = 301,
    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = 302,
    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED = 303,
    CUDA_ERROR_OPERATING_SYSTEM = 304,
    CUDA_ERROR_INVALID_HANDLE = 400,
    CUDA_ERROR_ILLEGAL_STATE = 401,
    CUDA_ERROR_LOSSY_QUERY = 402,
    CUDA_ERROR_NOT_FOUND = 500,
    CUDA_ERROR_NOT_READY = 600,
    CUDA_ERROR_ILLEGAL_ADDRESS = 700,
    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES = 701,
    CUDA_ERROR_LAUNCH_TIMEOUT = 702,
    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING = 703,
    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED = 704,
    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED = 705,
    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = 708,
    CUDA_ERROR_CONTEXT_IS_DESTROYED = 709,
    CUDA_ERROR_ASSERT = 710,
    CUDA_ERROR_TOO_MANY_PEERS = 711,
    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = 712,
    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED = 713,
    CUDA_ERROR_HARDWARE_STACK_ERROR = 714,
    CUDA_ERROR_ILLEGAL_INSTRUCTION = 715,
    CUDA_ERROR_MISALIGNED_ADDRESS = 716,
    CUDA_ERROR_INVALID_ADDRESS_SPACE = 717,
    CUDA_ERROR_INVALID_PC = 718,
    CUDA_ERROR_LAUNCH_FAILED = 719,
    CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE = 720,
    CUDA_ERROR_NOT_PERMITTED = 800,
    CUDA_ERROR_NOT_SUPPORTED = 801,
    CUDA_ERROR_SYSTEM_NOT_READY = 802,
    CUDA_ERROR_SYSTEM_DRIVER_MISMATCH = 803,
    CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE = 804,
    CUDA_ERROR_MPS_CONNECTION_FAILED = 805,
    CUDA_ERROR_MPS_RPC_FAILURE = 806,
    CUDA_ERROR_MPS_SERVER_NOT_READY = 807,
    CUDA_ERROR_MPS_MAX_CLIENTS_REACHED = 808,
    CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED = 809,
    CUDA_ERROR_MPS_CLIENT_TERMINATED = 810,
    CUDA_ERROR_CDP_NOT_SUPPORTED = 811,
    CUDA_ERROR_CDP_VERSION_MISMATCH = 812,
    CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED = 900,
    CUDA_ERROR_STREAM_CAPTURE_INVALIDATED = 901,
    CUDA_ERROR_STREAM_CAPTURE_MERGE = 902,
    CUDA_ERROR_STREAM_CAPTURE_UNMATCHED = 903,
    CUDA_ERROR_STREAM_CAPTURE_UNJOINED = 904,
    CUDA_ERROR_STREAM_CAPTURE_ISOLATION = 905,
    CUDA_ERROR_STREAM_CAPTURE_IMPLICIT = 906,
    CUDA_ERROR_CAPTURED_EVENT = 907,
    CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD = 908,
    CUDA_ERROR_TIMEOUT = 909,
    CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE = 910,
    CUDA_ERROR_EXTERNAL_DEVICE = 911,
    CUDA_ERROR_INVALID_CLUSTER_SIZE = 912,
    CUDA_ERROR_UNKNOWN = 999,
}
pub use self::cudaError_enum as CUresult;
impl CUdevice_P2PAttribute_enum {
    pub const CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED: CUdevice_P2PAttribute_enum =
        CUdevice_P2PAttribute_enum::CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUdevice_P2PAttribute_enum {
    CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = 1,
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED = 2,
    CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED = 3,
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED = 4,
}
pub use self::CUdevice_P2PAttribute_enum as CUdevice_P2PAttribute;
pub type CUstreamCallback = ::core::option::Option<
    unsafe extern "C" fn(hStream: CUstream, status: CUresult, userData: *mut ::core::ffi::c_void),
>;
pub type CUoccupancyB2DSize =
    ::core::option::Option<unsafe extern "C" fn(blockSize: ::core::ffi::c_int) -> usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_MEMCPY2D_st {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcMemoryType: CUmemorytype,
    pub srcHost: *const ::core::ffi::c_void,
    pub srcDevice: CUdeviceptr,
    pub srcArray: CUarray,
    pub srcPitch: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstMemoryType: CUmemorytype,
    pub dstHost: *mut ::core::ffi::c_void,
    pub dstDevice: CUdeviceptr,
    pub dstArray: CUarray,
    pub dstPitch: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY2D_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_MEMCPY2D_st> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_MEMCPY2D_st>(),
        128usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY2D_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_MEMCPY2D_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY2D_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcXInBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcMemoryType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcHost) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcPitch) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstXInBytes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstY) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstMemoryType) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstHost) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstPitch) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WidthInBytes) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY2D_st),
            "::",
            stringify!(Height)
        )
    );
}
impl Default for CUDA_MEMCPY2D_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_MEMCPY2D_v2 = CUDA_MEMCPY2D_st;
pub type CUDA_MEMCPY2D = CUDA_MEMCPY2D_v2;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_MEMCPY3D_st {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcZ: usize,
    pub srcLOD: usize,
    pub srcMemoryType: CUmemorytype,
    pub srcHost: *const ::core::ffi::c_void,
    pub srcDevice: CUdeviceptr,
    pub srcArray: CUarray,
    pub reserved0: *mut ::core::ffi::c_void,
    pub srcPitch: usize,
    pub srcHeight: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstZ: usize,
    pub dstLOD: usize,
    pub dstMemoryType: CUmemorytype,
    pub dstHost: *mut ::core::ffi::c_void,
    pub dstDevice: CUdeviceptr,
    pub dstArray: CUarray,
    pub reserved1: *mut ::core::ffi::c_void,
    pub dstPitch: usize,
    pub dstHeight: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
    pub Depth: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY3D_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_MEMCPY3D_st> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_MEMCPY3D_st>(),
        200usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY3D_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_MEMCPY3D_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY3D_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcXInBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcLOD) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcLOD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcMemoryType) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcHost) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcPitch) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcHeight) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(srcHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstXInBytes) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstY) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstZ) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstLOD) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstLOD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstMemoryType) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstHost) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstPitch) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstHeight) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(dstHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WidthInBytes) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_st),
            "::",
            stringify!(Depth)
        )
    );
}
impl Default for CUDA_MEMCPY3D_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_MEMCPY3D_v2 = CUDA_MEMCPY3D_st;
pub type CUDA_MEMCPY3D = CUDA_MEMCPY3D_v2;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_MEMCPY3D_PEER_st {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcZ: usize,
    pub srcLOD: usize,
    pub srcMemoryType: CUmemorytype,
    pub srcHost: *const ::core::ffi::c_void,
    pub srcDevice: CUdeviceptr,
    pub srcArray: CUarray,
    pub srcContext: CUcontext,
    pub srcPitch: usize,
    pub srcHeight: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstZ: usize,
    pub dstLOD: usize,
    pub dstMemoryType: CUmemorytype,
    pub dstHost: *mut ::core::ffi::c_void,
    pub dstDevice: CUdeviceptr,
    pub dstArray: CUarray,
    pub dstContext: CUcontext,
    pub dstPitch: usize,
    pub dstHeight: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
    pub Depth: usize,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY3D_PEER_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_MEMCPY3D_PEER_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_MEMCPY3D_PEER_st>(),
        200usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY3D_PEER_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_MEMCPY3D_PEER_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY3D_PEER_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcXInBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcLOD) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcLOD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcMemoryType) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcHost) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcContext) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcPitch) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srcHeight) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(srcHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstXInBytes) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstY) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstZ) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstLOD) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstLOD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstMemoryType) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstHost) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstContext) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstPitch) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dstHeight) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(dstHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WidthInBytes) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY3D_PEER_st),
            "::",
            stringify!(Depth)
        )
    );
}
impl Default for CUDA_MEMCPY3D_PEER_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_MEMCPY3D_PEER_v1 = CUDA_MEMCPY3D_PEER_st;
pub type CUDA_MEMCPY3D_PEER = CUDA_MEMCPY3D_PEER_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_MEMCPY_NODE_PARAMS_st {
    pub flags: ::core::ffi::c_int,
    pub reserved: ::core::ffi::c_int,
    pub copyCtx: CUcontext,
    pub copyParams: CUDA_MEMCPY3D,
}
#[test]
fn bindgen_test_layout_CUDA_MEMCPY_NODE_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_MEMCPY_NODE_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_MEMCPY_NODE_PARAMS_st>(),
        216usize,
        concat!("Size of: ", stringify!(CUDA_MEMCPY_NODE_PARAMS_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_MEMCPY_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEMCPY_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY_NODE_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY_NODE_PARAMS_st),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copyCtx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY_NODE_PARAMS_st),
            "::",
            stringify!(copyCtx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copyParams) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEMCPY_NODE_PARAMS_st),
            "::",
            stringify!(copyParams)
        )
    );
}
impl Default for CUDA_MEMCPY_NODE_PARAMS_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_MEMCPY_NODE_PARAMS = CUDA_MEMCPY_NODE_PARAMS_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_ARRAY_DESCRIPTOR_st {
    pub Width: usize,
    pub Height: usize,
    pub Format: CUarray_format,
    pub NumChannels: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_DESCRIPTOR_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_ARRAY_DESCRIPTOR_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_ARRAY_DESCRIPTOR_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_DESCRIPTOR_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_ARRAY_DESCRIPTOR_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY_DESCRIPTOR_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Format) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumChannels) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_DESCRIPTOR_st),
            "::",
            stringify!(NumChannels)
        )
    );
}
impl Default for CUDA_ARRAY_DESCRIPTOR_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_ARRAY_DESCRIPTOR_v2 = CUDA_ARRAY_DESCRIPTOR_st;
pub type CUDA_ARRAY_DESCRIPTOR = CUDA_ARRAY_DESCRIPTOR_v2;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_ARRAY3D_DESCRIPTOR_st {
    pub Width: usize,
    pub Height: usize,
    pub Depth: usize,
    pub Format: CUarray_format,
    pub NumChannels: ::core::ffi::c_uint,
    pub Flags: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY3D_DESCRIPTOR_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_ARRAY3D_DESCRIPTOR_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_ARRAY3D_DESCRIPTOR_st>(),
        40usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY3D_DESCRIPTOR_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_ARRAY3D_DESCRIPTOR_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY3D_DESCRIPTOR_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Format) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumChannels) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(NumChannels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY3D_DESCRIPTOR_st),
            "::",
            stringify!(Flags)
        )
    );
}
impl Default for CUDA_ARRAY3D_DESCRIPTOR_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_ARRAY3D_DESCRIPTOR_v2 = CUDA_ARRAY3D_DESCRIPTOR_st;
pub type CUDA_ARRAY3D_DESCRIPTOR = CUDA_ARRAY3D_DESCRIPTOR_v2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_ARRAY_SPARSE_PROPERTIES_st {
    pub tileExtent: CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1,
    pub miptailFirstLevel: ::core::ffi::c_uint,
    pub miptailSize: ::core::ffi::c_ulonglong,
    pub flags: ::core::ffi::c_uint,
    pub reserved: [::core::ffi::c_uint; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1 {
    pub width: ::core::ffi::c_uint,
    pub height: ::core::ffi::c_uint,
    pub depth: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st__bindgen_ty_1),
            "::",
            stringify!(depth)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_SPARSE_PROPERTIES_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_ARRAY_SPARSE_PROPERTIES_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st>(),
        48usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_ARRAY_SPARSE_PROPERTIES_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tileExtent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(tileExtent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).miptailFirstLevel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(miptailFirstLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).miptailSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(miptailSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_SPARSE_PROPERTIES_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_ARRAY_SPARSE_PROPERTIES_v1 = CUDA_ARRAY_SPARSE_PROPERTIES_st;
pub type CUDA_ARRAY_SPARSE_PROPERTIES = CUDA_ARRAY_SPARSE_PROPERTIES_v1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_ARRAY_MEMORY_REQUIREMENTS_st {
    pub size: usize,
    pub alignment: usize,
    pub reserved: [::core::ffi::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_CUDA_ARRAY_MEMORY_REQUIREMENTS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_ARRAY_MEMORY_REQUIREMENTS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_ARRAY_MEMORY_REQUIREMENTS_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_ARRAY_MEMORY_REQUIREMENTS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_ARRAY_MEMORY_REQUIREMENTS_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_ARRAY_MEMORY_REQUIREMENTS_v1 = CUDA_ARRAY_MEMORY_REQUIREMENTS_st;
pub type CUDA_ARRAY_MEMORY_REQUIREMENTS = CUDA_ARRAY_MEMORY_REQUIREMENTS_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_RESOURCE_DESC_st {
    pub resType: CUresourcetype,
    pub res: CUDA_RESOURCE_DESC_st__bindgen_ty_1,
    pub flags: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub hArray: CUarray,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hArray)
        )
    );
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    pub hMipmappedArray: CUmipmappedArray,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hMipmappedArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hMipmappedArray)
        )
    );
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: CUdeviceptr,
    pub format: CUarray_format,
    pub numChannels: ::core::ffi::c_uint,
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numChannels) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sizeInBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: CUdeviceptr,
    pub format: CUarray_format,
    pub numChannels: ::core::ffi::c_uint,
    pub width: usize,
    pub height: usize,
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numChannels) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitchInBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::core::ffi::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_RESOURCE_DESC_st__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_RESOURCE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitch2D) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_RESOURCE_DESC_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_DESC_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_RESOURCE_DESC_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_RESOURCE_DESC_st>(),
        144usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_DESC_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_RESOURCE_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_RESOURCE_DESC_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).res) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for CUDA_RESOURCE_DESC_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_RESOURCE_DESC_v1 = CUDA_RESOURCE_DESC_st;
pub type CUDA_RESOURCE_DESC = CUDA_RESOURCE_DESC_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct CUDA_TEXTURE_DESC_st {
    pub addressMode: [CUaddress_mode; 3usize],
    pub filterMode: CUfilter_mode,
    pub flags: ::core::ffi::c_uint,
    pub maxAnisotropy: ::core::ffi::c_uint,
    pub mipmapFilterMode: CUfilter_mode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub borderColor: [f32; 4usize],
    pub reserved: [::core::ffi::c_int; 12usize],
}
#[test]
fn bindgen_test_layout_CUDA_TEXTURE_DESC_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_TEXTURE_DESC_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_TEXTURE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(CUDA_TEXTURE_DESC_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_TEXTURE_DESC_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUDA_TEXTURE_DESC_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addressMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filterMode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxAnisotropy) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mipmapFilterMode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mipmapLevelBias) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minMipmapLevelClamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxMipmapLevelClamp) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).borderColor) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(borderColor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_TEXTURE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_TEXTURE_DESC_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_TEXTURE_DESC_v1 = CUDA_TEXTURE_DESC_st;
pub type CUDA_TEXTURE_DESC = CUDA_TEXTURE_DESC_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUresourceViewFormat_enum {
    CU_RES_VIEW_FORMAT_NONE = 0,
    CU_RES_VIEW_FORMAT_UINT_1X8 = 1,
    CU_RES_VIEW_FORMAT_UINT_2X8 = 2,
    CU_RES_VIEW_FORMAT_UINT_4X8 = 3,
    CU_RES_VIEW_FORMAT_SINT_1X8 = 4,
    CU_RES_VIEW_FORMAT_SINT_2X8 = 5,
    CU_RES_VIEW_FORMAT_SINT_4X8 = 6,
    CU_RES_VIEW_FORMAT_UINT_1X16 = 7,
    CU_RES_VIEW_FORMAT_UINT_2X16 = 8,
    CU_RES_VIEW_FORMAT_UINT_4X16 = 9,
    CU_RES_VIEW_FORMAT_SINT_1X16 = 10,
    CU_RES_VIEW_FORMAT_SINT_2X16 = 11,
    CU_RES_VIEW_FORMAT_SINT_4X16 = 12,
    CU_RES_VIEW_FORMAT_UINT_1X32 = 13,
    CU_RES_VIEW_FORMAT_UINT_2X32 = 14,
    CU_RES_VIEW_FORMAT_UINT_4X32 = 15,
    CU_RES_VIEW_FORMAT_SINT_1X32 = 16,
    CU_RES_VIEW_FORMAT_SINT_2X32 = 17,
    CU_RES_VIEW_FORMAT_SINT_4X32 = 18,
    CU_RES_VIEW_FORMAT_FLOAT_1X16 = 19,
    CU_RES_VIEW_FORMAT_FLOAT_2X16 = 20,
    CU_RES_VIEW_FORMAT_FLOAT_4X16 = 21,
    CU_RES_VIEW_FORMAT_FLOAT_1X32 = 22,
    CU_RES_VIEW_FORMAT_FLOAT_2X32 = 23,
    CU_RES_VIEW_FORMAT_FLOAT_4X32 = 24,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC1 = 25,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC2 = 26,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC3 = 27,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC4 = 28,
    CU_RES_VIEW_FORMAT_SIGNED_BC4 = 29,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC5 = 30,
    CU_RES_VIEW_FORMAT_SIGNED_BC5 = 31,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC6H = 32,
    CU_RES_VIEW_FORMAT_SIGNED_BC6H = 33,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC7 = 34,
}
pub use self::CUresourceViewFormat_enum as CUresourceViewFormat;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_RESOURCE_VIEW_DESC_st {
    pub format: CUresourceViewFormat,
    pub width: usize,
    pub height: usize,
    pub depth: usize,
    pub firstMipmapLevel: ::core::ffi::c_uint,
    pub lastMipmapLevel: ::core::ffi::c_uint,
    pub firstLayer: ::core::ffi::c_uint,
    pub lastLayer: ::core::ffi::c_uint,
    pub reserved: [::core::ffi::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_RESOURCE_VIEW_DESC_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_RESOURCE_VIEW_DESC_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_RESOURCE_VIEW_DESC_st>(),
        112usize,
        concat!("Size of: ", stringify!(CUDA_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_RESOURCE_VIEW_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).firstMipmapLevel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lastMipmapLevel) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).firstLayer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lastLayer) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastLayer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_RESOURCE_VIEW_DESC_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_RESOURCE_VIEW_DESC_v1 = CUDA_RESOURCE_VIEW_DESC_st;
pub type CUDA_RESOURCE_VIEW_DESC = CUDA_RESOURCE_VIEW_DESC_v1;
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUtensorMap_st {
    pub opaque: [cuuint64_t; 16usize],
}
#[test]
fn bindgen_test_layout_CUtensorMap_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUtensorMap_st> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUtensorMap_st>(),
        128usize,
        concat!("Size of: ", stringify!(CUtensorMap_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUtensorMap_st>(),
        64usize,
        concat!("Alignment of ", stringify!(CUtensorMap_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUtensorMap_st),
            "::",
            stringify!(opaque)
        )
    );
}
impl Default for CUtensorMap_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUtensorMap = CUtensorMap_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUtensorMapDataType_enum {
    CU_TENSOR_MAP_DATA_TYPE_UINT8 = 0,
    CU_TENSOR_MAP_DATA_TYPE_UINT16 = 1,
    CU_TENSOR_MAP_DATA_TYPE_UINT32 = 2,
    CU_TENSOR_MAP_DATA_TYPE_INT32 = 3,
    CU_TENSOR_MAP_DATA_TYPE_UINT64 = 4,
    CU_TENSOR_MAP_DATA_TYPE_INT64 = 5,
    CU_TENSOR_MAP_DATA_TYPE_FLOAT16 = 6,
    CU_TENSOR_MAP_DATA_TYPE_FLOAT32 = 7,
    CU_TENSOR_MAP_DATA_TYPE_FLOAT64 = 8,
    CU_TENSOR_MAP_DATA_TYPE_BFLOAT16 = 9,
    CU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ = 10,
    CU_TENSOR_MAP_DATA_TYPE_TFLOAT32 = 11,
    CU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ = 12,
}
pub use self::CUtensorMapDataType_enum as CUtensorMapDataType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUtensorMapInterleave_enum {
    CU_TENSOR_MAP_INTERLEAVE_NONE = 0,
    CU_TENSOR_MAP_INTERLEAVE_16B = 1,
    CU_TENSOR_MAP_INTERLEAVE_32B = 2,
}
pub use self::CUtensorMapInterleave_enum as CUtensorMapInterleave;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUtensorMapSwizzle_enum {
    CU_TENSOR_MAP_SWIZZLE_NONE = 0,
    CU_TENSOR_MAP_SWIZZLE_32B = 1,
    CU_TENSOR_MAP_SWIZZLE_64B = 2,
    CU_TENSOR_MAP_SWIZZLE_128B = 3,
}
pub use self::CUtensorMapSwizzle_enum as CUtensorMapSwizzle;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUtensorMapL2promotion_enum {
    CU_TENSOR_MAP_L2_PROMOTION_NONE = 0,
    CU_TENSOR_MAP_L2_PROMOTION_L2_64B = 1,
    CU_TENSOR_MAP_L2_PROMOTION_L2_128B = 2,
    CU_TENSOR_MAP_L2_PROMOTION_L2_256B = 3,
}
pub use self::CUtensorMapL2promotion_enum as CUtensorMapL2promotion;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUtensorMapFloatOOBfill_enum {
    CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE = 0,
    CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA = 1,
}
pub use self::CUtensorMapFloatOOBfill_enum as CUtensorMapFloatOOBfill;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st {
    pub p2pToken: ::core::ffi::c_ulonglong,
    pub vaSpaceToken: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p2pToken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st),
            "::",
            stringify!(p2pToken)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vaSpaceToken) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st),
            "::",
            stringify!(vaSpaceToken)
        )
    );
}
pub type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1 = CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st;
pub type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS = CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum {
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE = 0,
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ = 1,
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE = 3,
}
pub use self::CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum as CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_LAUNCH_PARAMS_st {
    pub function: CUfunction,
    pub gridDimX: ::core::ffi::c_uint,
    pub gridDimY: ::core::ffi::c_uint,
    pub gridDimZ: ::core::ffi::c_uint,
    pub blockDimX: ::core::ffi::c_uint,
    pub blockDimY: ::core::ffi::c_uint,
    pub blockDimZ: ::core::ffi::c_uint,
    pub sharedMemBytes: ::core::ffi::c_uint,
    pub hStream: CUstream,
    pub kernelParams: *mut *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_LAUNCH_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_LAUNCH_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_LAUNCH_PARAMS_st>(),
        56usize,
        concat!("Size of: ", stringify!(CUDA_LAUNCH_PARAMS_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_LAUNCH_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_LAUNCH_PARAMS_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gridDimZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimX) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimY) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockDimZ) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hStream) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(hStream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_LAUNCH_PARAMS_st),
            "::",
            stringify!(kernelParams)
        )
    );
}
impl Default for CUDA_LAUNCH_PARAMS_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_LAUNCH_PARAMS_v1 = CUDA_LAUNCH_PARAMS_st;
pub type CUDA_LAUNCH_PARAMS = CUDA_LAUNCH_PARAMS_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUexternalMemoryHandleType_enum {
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD = 1,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32 = 2,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP = 4,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE = 5,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE = 6,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT = 7,
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF = 8,
}
pub use self::CUexternalMemoryHandleType_enum as CUexternalMemoryHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    pub type_: CUexternalMemoryHandleType,
    pub handle: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1,
    pub size: ::core::ffi::c_ulonglong,
    pub flags: ::core::ffi::c_uint,
    pub reserved: [::core::ffi::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1 {
    pub fd: ::core::ffi::c_int,
    pub win32: CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciBufObject: *const ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::core::ffi::c_void,
    pub name: *const ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
impl Default for CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).win32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvSciBufObject) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(nvSciBufObject)
        )
    );
}
impl Default for CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1 = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st;
pub type CUDA_EXTERNAL_MEMORY_HANDLE_DESC = CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {
    pub offset: ::core::ffi::c_ulonglong,
    pub size: ::core::ffi::c_ulonglong,
    pub flags: ::core::ffi::c_uint,
    pub reserved: [::core::ffi::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>(),
        88usize,
        concat!("Size of: ", stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1 = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st;
pub type CUDA_EXTERNAL_MEMORY_BUFFER_DESC = CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    pub offset: ::core::ffi::c_ulonglong,
    pub arrayDesc: CUDA_ARRAY3D_DESCRIPTOR,
    pub numLevels: ::core::ffi::c_uint,
    pub reserved: [::core::ffi::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arrayDesc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(arrayDesc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numLevels) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(numLevels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1 =
    CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st;
pub type CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC = CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUexternalSemaphoreHandleType_enum {
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD = 1,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32 = 2,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE = 4,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE = 5,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC = 6,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX = 7,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT = 8,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD = 9,
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = 10,
}
pub use self::CUexternalSemaphoreHandleType_enum as CUexternalSemaphoreHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    pub type_: CUexternalSemaphoreHandleType,
    pub handle: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1,
    pub flags: ::core::ffi::c_uint,
    pub reserved: [::core::ffi::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1 {
    pub fd: ::core::ffi::c_int,
    pub win32: CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSyncObj: *const ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::core::ffi::c_void,
    pub name: *const ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).win32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvSciSyncObj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSyncObj)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1 = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st;
pub type CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC = CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1,
    pub flags: ::core::ffi::c_uint,
    pub reserved: [::core::ffi::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::core::ffi::c_uint; 12usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::core::ffi::c_void,
    pub reserved: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1 = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st;
pub type CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS = CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st {
    pub params: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1,
    pub flags: ::core::ffi::c_uint,
    pub reserved: [::core::ffi::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1 {
    pub fence: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::core::ffi::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::core::ffi::c_void,
    pub reserved: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::core::ffi::c_ulonglong,
    pub timeoutMs: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<
        CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeoutMs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(timeoutMs)
        )
    );
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1 = CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st;
pub type CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS = CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st {
    pub extSemArray: *mut CUexternalSemaphore,
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
    pub numExtSems: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st),
            "::",
            stringify!(numExtSems)
        )
    );
}
impl Default for CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1 = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st;
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st {
    pub extSemArray: *mut CUexternalSemaphore,
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
    pub numExtSems: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st),
            "::",
            stringify!(numExtSems)
        )
    );
}
impl Default for CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2 = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXT_SEM_WAIT_NODE_PARAMS_st {
    pub extSemArray: *mut CUexternalSemaphore,
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
    pub numExtSems: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXT_SEM_WAIT_NODE_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_st),
            "::",
            stringify!(numExtSems)
        )
    );
}
impl Default for CUDA_EXT_SEM_WAIT_NODE_PARAMS_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1 = CUDA_EXT_SEM_WAIT_NODE_PARAMS_st;
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS = CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st {
    pub extSemArray: *mut CUexternalSemaphore,
    pub paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
    pub numExtSems: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st),
            "::",
            stringify!(numExtSems)
        )
    );
}
impl Default for CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2 = CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st;
pub type CUmemGenericAllocationHandle_v1 = ::core::ffi::c_ulonglong;
pub type CUmemGenericAllocationHandle = CUmemGenericAllocationHandle_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemAllocationHandleType_enum {
    CU_MEM_HANDLE_TYPE_NONE = 0,
    CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR = 1,
    CU_MEM_HANDLE_TYPE_WIN32 = 2,
    CU_MEM_HANDLE_TYPE_WIN32_KMT = 4,
    CU_MEM_HANDLE_TYPE_FABRIC = 8,
    CU_MEM_HANDLE_TYPE_MAX = 2147483647,
}
pub use self::CUmemAllocationHandleType_enum as CUmemAllocationHandleType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemAccess_flags_enum {
    CU_MEM_ACCESS_FLAGS_PROT_NONE = 0,
    CU_MEM_ACCESS_FLAGS_PROT_READ = 1,
    CU_MEM_ACCESS_FLAGS_PROT_READWRITE = 3,
    CU_MEM_ACCESS_FLAGS_PROT_MAX = 2147483647,
}
pub use self::CUmemAccess_flags_enum as CUmemAccess_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemLocationType_enum {
    CU_MEM_LOCATION_TYPE_INVALID = 0,
    CU_MEM_LOCATION_TYPE_DEVICE = 1,
    CU_MEM_LOCATION_TYPE_HOST = 2,
    CU_MEM_LOCATION_TYPE_HOST_NUMA = 3,
    CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT = 4,
    CU_MEM_LOCATION_TYPE_MAX = 2147483647,
}
pub use self::CUmemLocationType_enum as CUmemLocationType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemAllocationType_enum {
    CU_MEM_ALLOCATION_TYPE_INVALID = 0,
    CU_MEM_ALLOCATION_TYPE_PINNED = 1,
    CU_MEM_ALLOCATION_TYPE_MAX = 2147483647,
}
pub use self::CUmemAllocationType_enum as CUmemAllocationType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemAllocationGranularity_flags_enum {
    CU_MEM_ALLOC_GRANULARITY_MINIMUM = 0,
    CU_MEM_ALLOC_GRANULARITY_RECOMMENDED = 1,
}
pub use self::CUmemAllocationGranularity_flags_enum as CUmemAllocationGranularity_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemRangeHandleType_enum {
    CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD = 1,
    CU_MEM_RANGE_HANDLE_TYPE_MAX = 2147483647,
}
pub use self::CUmemRangeHandleType_enum as CUmemRangeHandleType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUarraySparseSubresourceType_enum {
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL = 0,
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL = 1,
}
pub use self::CUarraySparseSubresourceType_enum as CUarraySparseSubresourceType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemOperationType_enum {
    CU_MEM_OPERATION_TYPE_MAP = 1,
    CU_MEM_OPERATION_TYPE_UNMAP = 2,
}
pub use self::CUmemOperationType_enum as CUmemOperationType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemHandleType_enum {
    CU_MEM_HANDLE_TYPE_GENERIC = 0,
}
pub use self::CUmemHandleType_enum as CUmemHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUarrayMapInfo_st {
    pub resourceType: CUresourcetype,
    pub resource: CUarrayMapInfo_st__bindgen_ty_1,
    pub subresourceType: CUarraySparseSubresourceType,
    pub subresource: CUarrayMapInfo_st__bindgen_ty_2,
    pub memOperationType: CUmemOperationType,
    pub memHandleType: CUmemHandleType,
    pub memHandle: CUarrayMapInfo_st__bindgen_ty_3,
    pub offset: ::core::ffi::c_ulonglong,
    pub deviceBitMask: ::core::ffi::c_uint,
    pub flags: ::core::ffi::c_uint,
    pub reserved: [::core::ffi::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_1 {
    pub mipmap: CUmipmappedArray,
    pub array: CUarray,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUarrayMapInfo_st__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
}
impl Default for CUarrayMapInfo_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_2 {
    pub sparseLevel: CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1,
    pub miptail: CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1 {
    pub level: ::core::ffi::c_uint,
    pub layer: ::core::ffi::c_uint,
    pub offsetX: ::core::ffi::c_uint,
    pub offsetY: ::core::ffi::c_uint,
    pub offsetZ: ::core::ffi::c_uint,
    pub extentWidth: ::core::ffi::c_uint,
    pub extentHeight: ::core::ffi::c_uint,
    pub extentDepth: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).layer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offsetX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offsetY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offsetZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetZ)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extentWidth) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extentHeight) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentHeight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extentDepth) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentDepth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2 {
    pub layer: ::core::ffi::c_uint,
    pub offset: ::core::ffi::c_ulonglong,
    pub size: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).layer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<CUarrayMapInfo_st__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sparseLevel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2),
            "::",
            stringify!(sparseLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).miptail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_2),
            "::",
            stringify!(miptail)
        )
    );
}
impl Default for CUarrayMapInfo_st__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUarrayMapInfo_st__bindgen_ty_3 {
    pub memHandle: CUmemGenericAllocationHandle,
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<CUarrayMapInfo_st__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUarrayMapInfo_st__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<CUarrayMapInfo_st__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st__bindgen_ty_3),
            "::",
            stringify!(memHandle)
        )
    );
}
impl Default for CUarrayMapInfo_st__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUarrayMapInfo_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUarrayMapInfo_st> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUarrayMapInfo_st>(),
        96usize,
        concat!("Size of: ", stringify!(CUarrayMapInfo_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUarrayMapInfo_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUarrayMapInfo_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resourceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(resourceType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resource) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subresourceType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(subresourceType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subresource) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(subresource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memOperationType) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(memOperationType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memHandleType) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(memHandleType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memHandle) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(memHandle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deviceBitMask) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(deviceBitMask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUarrayMapInfo_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUarrayMapInfo_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUarrayMapInfo_v1 = CUarrayMapInfo_st;
pub type CUarrayMapInfo = CUarrayMapInfo_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUmemLocation_st {
    pub type_: CUmemLocationType,
    pub id: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_CUmemLocation_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUmemLocation_st> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUmemLocation_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUmemLocation_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUmemLocation_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUmemLocation_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemLocation_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemLocation_st),
            "::",
            stringify!(id)
        )
    );
}
impl Default for CUmemLocation_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUmemLocation_v1 = CUmemLocation_st;
pub type CUmemLocation = CUmemLocation_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemAllocationCompType_enum {
    CU_MEM_ALLOCATION_COMP_NONE = 0,
    CU_MEM_ALLOCATION_COMP_GENERIC = 1,
}
pub use self::CUmemAllocationCompType_enum as CUmemAllocationCompType;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUmemAllocationProp_st {
    pub type_: CUmemAllocationType,
    pub requestedHandleTypes: CUmemAllocationHandleType,
    pub location: CUmemLocation,
    pub win32HandleMetaData: *mut ::core::ffi::c_void,
    pub allocFlags: CUmemAllocationProp_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUmemAllocationProp_st__bindgen_ty_1 {
    pub compressionType: ::core::ffi::c_uchar,
    pub gpuDirectRDMACapable: ::core::ffi::c_uchar,
    pub usage: ::core::ffi::c_ushort,
    pub reserved: [::core::ffi::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_CUmemAllocationProp_st__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUmemAllocationProp_st__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUmemAllocationProp_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CUmemAllocationProp_st__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compressionType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(compressionType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpuDirectRDMACapable) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(gpuDirectRDMACapable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_CUmemAllocationProp_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUmemAllocationProp_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUmemAllocationProp_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUmemAllocationProp_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUmemAllocationProp_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUmemAllocationProp_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).requestedHandleTypes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(requestedHandleTypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).win32HandleMetaData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(win32HandleMetaData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allocFlags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAllocationProp_st),
            "::",
            stringify!(allocFlags)
        )
    );
}
impl Default for CUmemAllocationProp_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUmemAllocationProp_v1 = CUmemAllocationProp_st;
pub type CUmemAllocationProp = CUmemAllocationProp_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmulticastGranularity_flags_enum {
    CU_MULTICAST_GRANULARITY_MINIMUM = 0,
    CU_MULTICAST_GRANULARITY_RECOMMENDED = 1,
}
pub use self::CUmulticastGranularity_flags_enum as CUmulticastGranularity_flags;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUmulticastObjectProp_st {
    pub numDevices: ::core::ffi::c_uint,
    pub size: usize,
    pub handleTypes: ::core::ffi::c_ulonglong,
    pub flags: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_CUmulticastObjectProp_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUmulticastObjectProp_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUmulticastObjectProp_st>(),
        32usize,
        concat!("Size of: ", stringify!(CUmulticastObjectProp_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUmulticastObjectProp_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUmulticastObjectProp_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numDevices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmulticastObjectProp_st),
            "::",
            stringify!(numDevices)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmulticastObjectProp_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmulticastObjectProp_st),
            "::",
            stringify!(handleTypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmulticastObjectProp_st),
            "::",
            stringify!(flags)
        )
    );
}
pub type CUmulticastObjectProp_v1 = CUmulticastObjectProp_st;
pub type CUmulticastObjectProp = CUmulticastObjectProp_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUmemAccessDesc_st {
    pub location: CUmemLocation,
    pub flags: CUmemAccess_flags,
}
#[test]
fn bindgen_test_layout_CUmemAccessDesc_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUmemAccessDesc_st> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUmemAccessDesc_st>(),
        12usize,
        concat!("Size of: ", stringify!(CUmemAccessDesc_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUmemAccessDesc_st>(),
        4usize,
        concat!("Alignment of ", stringify!(CUmemAccessDesc_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAccessDesc_st),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemAccessDesc_st),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for CUmemAccessDesc_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUmemAccessDesc_v1 = CUmemAccessDesc_st;
pub type CUmemAccessDesc = CUmemAccessDesc_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphExecUpdateResult_enum {
    CU_GRAPH_EXEC_UPDATE_SUCCESS = 0,
    CU_GRAPH_EXEC_UPDATE_ERROR = 1,
    CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED = 2,
    CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED = 3,
    CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED = 4,
    CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED = 5,
    CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED = 6,
    CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE = 7,
    CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED = 8,
}
pub use self::CUgraphExecUpdateResult_enum as CUgraphExecUpdateResult;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUgraphExecUpdateResultInfo_st {
    pub result: CUgraphExecUpdateResult,
    pub errorNode: CUgraphNode,
    pub errorFromNode: CUgraphNode,
}
#[test]
fn bindgen_test_layout_CUgraphExecUpdateResultInfo_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUgraphExecUpdateResultInfo_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUgraphExecUpdateResultInfo_st>(),
        24usize,
        concat!("Size of: ", stringify!(CUgraphExecUpdateResultInfo_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUgraphExecUpdateResultInfo_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUgraphExecUpdateResultInfo_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphExecUpdateResultInfo_st),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errorNode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphExecUpdateResultInfo_st),
            "::",
            stringify!(errorNode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errorFromNode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphExecUpdateResultInfo_st),
            "::",
            stringify!(errorFromNode)
        )
    );
}
impl Default for CUgraphExecUpdateResultInfo_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUgraphExecUpdateResultInfo_v1 = CUgraphExecUpdateResultInfo_st;
pub type CUgraphExecUpdateResultInfo = CUgraphExecUpdateResultInfo_v1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmemPool_attribute_enum {
    CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES = 1,
    CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC = 2,
    CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES = 3,
    CU_MEMPOOL_ATTR_RELEASE_THRESHOLD = 4,
    CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT = 5,
    CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH = 6,
    CU_MEMPOOL_ATTR_USED_MEM_CURRENT = 7,
    CU_MEMPOOL_ATTR_USED_MEM_HIGH = 8,
}
pub use self::CUmemPool_attribute_enum as CUmemPool_attribute;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUmemPoolProps_st {
    pub allocType: CUmemAllocationType,
    pub handleTypes: CUmemAllocationHandleType,
    pub location: CUmemLocation,
    pub win32SecurityAttributes: *mut ::core::ffi::c_void,
    pub maxSize: usize,
    pub reserved: [::core::ffi::c_uchar; 56usize],
}
#[test]
fn bindgen_test_layout_CUmemPoolProps_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUmemPoolProps_st> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUmemPoolProps_st>(),
        88usize,
        concat!("Size of: ", stringify!(CUmemPoolProps_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUmemPoolProps_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUmemPoolProps_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allocType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(allocType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(handleTypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).win32SecurityAttributes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(win32SecurityAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(maxSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolProps_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUmemPoolProps_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUmemPoolProps_v1 = CUmemPoolProps_st;
pub type CUmemPoolProps = CUmemPoolProps_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUmemPoolPtrExportData_st {
    pub reserved: [::core::ffi::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_CUmemPoolPtrExportData_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUmemPoolPtrExportData_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUmemPoolPtrExportData_st>(),
        64usize,
        concat!("Size of: ", stringify!(CUmemPoolPtrExportData_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUmemPoolPtrExportData_st>(),
        1usize,
        concat!("Alignment of ", stringify!(CUmemPoolPtrExportData_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUmemPoolPtrExportData_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for CUmemPoolPtrExportData_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUmemPoolPtrExportData_v1 = CUmemPoolPtrExportData_st;
pub type CUmemPoolPtrExportData = CUmemPoolPtrExportData_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_MEM_ALLOC_NODE_PARAMS_v1_st {
    pub poolProps: CUmemPoolProps,
    pub accessDescs: *const CUmemAccessDesc,
    pub accessDescCount: usize,
    pub bytesize: usize,
    pub dptr: CUdeviceptr,
}
#[test]
fn bindgen_test_layout_CUDA_MEM_ALLOC_NODE_PARAMS_v1_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_MEM_ALLOC_NODE_PARAMS_v1_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_MEM_ALLOC_NODE_PARAMS_v1_st>(),
        120usize,
        concat!("Size of: ", stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v1_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_MEM_ALLOC_NODE_PARAMS_v1_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v1_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poolProps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v1_st),
            "::",
            stringify!(poolProps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accessDescs) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v1_st),
            "::",
            stringify!(accessDescs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accessDescCount) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v1_st),
            "::",
            stringify!(accessDescCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytesize) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v1_st),
            "::",
            stringify!(bytesize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dptr) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v1_st),
            "::",
            stringify!(dptr)
        )
    );
}
impl Default for CUDA_MEM_ALLOC_NODE_PARAMS_v1_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_MEM_ALLOC_NODE_PARAMS_v1 = CUDA_MEM_ALLOC_NODE_PARAMS_v1_st;
pub type CUDA_MEM_ALLOC_NODE_PARAMS = CUDA_MEM_ALLOC_NODE_PARAMS_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_MEM_ALLOC_NODE_PARAMS_v2_st {
    pub poolProps: CUmemPoolProps,
    pub accessDescs: *const CUmemAccessDesc,
    pub accessDescCount: usize,
    pub bytesize: usize,
    pub dptr: CUdeviceptr,
}
#[test]
fn bindgen_test_layout_CUDA_MEM_ALLOC_NODE_PARAMS_v2_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_MEM_ALLOC_NODE_PARAMS_v2_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_MEM_ALLOC_NODE_PARAMS_v2_st>(),
        120usize,
        concat!("Size of: ", stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v2_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_MEM_ALLOC_NODE_PARAMS_v2_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v2_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poolProps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v2_st),
            "::",
            stringify!(poolProps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accessDescs) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v2_st),
            "::",
            stringify!(accessDescs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accessDescCount) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v2_st),
            "::",
            stringify!(accessDescCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytesize) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v2_st),
            "::",
            stringify!(bytesize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dptr) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_ALLOC_NODE_PARAMS_v2_st),
            "::",
            stringify!(dptr)
        )
    );
}
impl Default for CUDA_MEM_ALLOC_NODE_PARAMS_v2_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_MEM_ALLOC_NODE_PARAMS_v2 = CUDA_MEM_ALLOC_NODE_PARAMS_v2_st;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_MEM_FREE_NODE_PARAMS_st {
    pub dptr: CUdeviceptr,
}
#[test]
fn bindgen_test_layout_CUDA_MEM_FREE_NODE_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_MEM_FREE_NODE_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_MEM_FREE_NODE_PARAMS_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUDA_MEM_FREE_NODE_PARAMS_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_MEM_FREE_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_MEM_FREE_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_MEM_FREE_NODE_PARAMS_st),
            "::",
            stringify!(dptr)
        )
    );
}
pub type CUDA_MEM_FREE_NODE_PARAMS = CUDA_MEM_FREE_NODE_PARAMS_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphMem_attribute_enum {
    CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT = 0,
    CU_GRAPH_MEM_ATTR_USED_MEM_HIGH = 1,
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT = 2,
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH = 3,
}
pub use self::CUgraphMem_attribute_enum as CUgraphMem_attribute;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_CHILD_GRAPH_NODE_PARAMS_st {
    pub graph: CUgraph,
}
#[test]
fn bindgen_test_layout_CUDA_CHILD_GRAPH_NODE_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_CHILD_GRAPH_NODE_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_CHILD_GRAPH_NODE_PARAMS_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUDA_CHILD_GRAPH_NODE_PARAMS_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_CHILD_GRAPH_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_CHILD_GRAPH_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_CHILD_GRAPH_NODE_PARAMS_st),
            "::",
            stringify!(graph)
        )
    );
}
impl Default for CUDA_CHILD_GRAPH_NODE_PARAMS_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_CHILD_GRAPH_NODE_PARAMS = CUDA_CHILD_GRAPH_NODE_PARAMS_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EVENT_RECORD_NODE_PARAMS_st {
    pub event: CUevent,
}
#[test]
fn bindgen_test_layout_CUDA_EVENT_RECORD_NODE_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EVENT_RECORD_NODE_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EVENT_RECORD_NODE_PARAMS_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUDA_EVENT_RECORD_NODE_PARAMS_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EVENT_RECORD_NODE_PARAMS_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUDA_EVENT_RECORD_NODE_PARAMS_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EVENT_RECORD_NODE_PARAMS_st),
            "::",
            stringify!(event)
        )
    );
}
impl Default for CUDA_EVENT_RECORD_NODE_PARAMS_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EVENT_RECORD_NODE_PARAMS = CUDA_EVENT_RECORD_NODE_PARAMS_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CUDA_EVENT_WAIT_NODE_PARAMS_st {
    pub event: CUevent,
}
#[test]
fn bindgen_test_layout_CUDA_EVENT_WAIT_NODE_PARAMS_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUDA_EVENT_WAIT_NODE_PARAMS_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUDA_EVENT_WAIT_NODE_PARAMS_st>(),
        8usize,
        concat!("Size of: ", stringify!(CUDA_EVENT_WAIT_NODE_PARAMS_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUDA_EVENT_WAIT_NODE_PARAMS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUDA_EVENT_WAIT_NODE_PARAMS_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUDA_EVENT_WAIT_NODE_PARAMS_st),
            "::",
            stringify!(event)
        )
    );
}
impl Default for CUDA_EVENT_WAIT_NODE_PARAMS_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUDA_EVENT_WAIT_NODE_PARAMS = CUDA_EVENT_WAIT_NODE_PARAMS_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUgraphNodeParams_st {
    pub type_: CUgraphNodeType,
    pub reserved0: [::core::ffi::c_int; 3usize],
    pub __bindgen_anon_1: CUgraphNodeParams_st__bindgen_ty_1,
    pub reserved2: ::core::ffi::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUgraphNodeParams_st__bindgen_ty_1 {
    pub reserved1: [::core::ffi::c_longlong; 29usize],
    pub kernel: CUDA_KERNEL_NODE_PARAMS_v3,
    pub memcpy: CUDA_MEMCPY_NODE_PARAMS,
    pub memset: CUDA_MEMSET_NODE_PARAMS_v2,
    pub host: CUDA_HOST_NODE_PARAMS_v2,
    pub graph: CUDA_CHILD_GRAPH_NODE_PARAMS,
    pub eventWait: CUDA_EVENT_WAIT_NODE_PARAMS,
    pub eventRecord: CUDA_EVENT_RECORD_NODE_PARAMS,
    pub extSemSignal: CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2,
    pub extSemWait: CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2,
    pub alloc: CUDA_MEM_ALLOC_NODE_PARAMS_v2,
    pub free: CUDA_MEM_FREE_NODE_PARAMS,
    pub memOp: CUDA_BATCH_MEM_OP_NODE_PARAMS_v2,
    pub conditional: CUDA_CONDITIONAL_NODE_PARAMS,
}
#[test]
fn bindgen_test_layout_CUgraphNodeParams_st__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CUgraphNodeParams_st__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUgraphNodeParams_st__bindgen_ty_1>(),
        232usize,
        concat!("Size of: ", stringify!(CUgraphNodeParams_st__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CUgraphNodeParams_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kernel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(kernel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memcpy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(memcpy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(memset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eventWait) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(eventWait)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eventRecord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(eventRecord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extSemSignal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(extSemSignal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extSemWait) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(extSemWait)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memOp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(memOp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conditional) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st__bindgen_ty_1),
            "::",
            stringify!(conditional)
        )
    );
}
impl Default for CUgraphNodeParams_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_CUgraphNodeParams_st() {
    const UNINIT: ::core::mem::MaybeUninit<CUgraphNodeParams_st> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CUgraphNodeParams_st>(),
        256usize,
        concat!("Size of: ", stringify!(CUgraphNodeParams_st))
    );
    assert_eq!(
        ::core::mem::align_of::<CUgraphNodeParams_st>(),
        8usize,
        concat!("Alignment of ", stringify!(CUgraphNodeParams_st))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(CUgraphNodeParams_st),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for CUgraphNodeParams_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CUgraphNodeParams = CUgraphNodeParams_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUflushGPUDirectRDMAWritesOptions_enum {
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST = 1,
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS = 2,
}
pub use self::CUflushGPUDirectRDMAWritesOptions_enum as CUflushGPUDirectRDMAWritesOptions;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUGPUDirectRDMAWritesOrdering_enum {
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE = 0,
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER = 100,
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES = 200,
}
pub use self::CUGPUDirectRDMAWritesOrdering_enum as CUGPUDirectRDMAWritesOrdering;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUflushGPUDirectRDMAWritesScope_enum {
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER = 100,
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES = 200,
}
pub use self::CUflushGPUDirectRDMAWritesScope_enum as CUflushGPUDirectRDMAWritesScope;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUflushGPUDirectRDMAWritesTarget_enum {
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX = 0,
}
pub use self::CUflushGPUDirectRDMAWritesTarget_enum as CUflushGPUDirectRDMAWritesTarget;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphDebugDot_flags_enum {
    CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE = 1,
    CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES = 2,
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS = 4,
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS = 8,
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS = 16,
    CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS = 32,
    CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS = 64,
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS = 128,
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS = 256,
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES = 512,
    CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES = 1024,
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS = 2048,
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS = 4096,
    CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS = 8192,
    CU_GRAPH_DEBUG_DOT_FLAGS_EXTRA_TOPO_INFO = 16384,
    CU_GRAPH_DEBUG_DOT_FLAGS_CONDITIONAL_NODE_PARAMS = 32768,
}
pub use self::CUgraphDebugDot_flags_enum as CUgraphDebugDot_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUuserObject_flags_enum {
    CU_USER_OBJECT_NO_DESTRUCTOR_SYNC = 1,
}
pub use self::CUuserObject_flags_enum as CUuserObject_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUuserObjectRetain_flags_enum {
    CU_GRAPH_USER_OBJECT_MOVE = 1,
}
pub use self::CUuserObjectRetain_flags_enum as CUuserObjectRetain_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUgraphInstantiate_flags_enum {
    CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH = 1,
    CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD = 2,
    CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH = 4,
    CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY = 8,
}
pub use self::CUgraphInstantiate_flags_enum as CUgraphInstantiate_flags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUdeviceNumaConfig_enum {
    CU_DEVICE_NUMA_CONFIG_NONE = 0,
    CU_DEVICE_NUMA_CONFIG_NUMA_NODE = 1,
}
pub use self::CUdeviceNumaConfig_enum as CUdeviceNumaConfig;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUmoduleLoadingMode_enum {
    CU_MODULE_EAGER_LOADING = 1,
    CU_MODULE_LAZY_LOADING = 2,
}
pub use self::CUmoduleLoadingMode_enum as CUmoduleLoadingMode;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUcoredumpSettings_enum {
    CU_COREDUMP_ENABLE_ON_EXCEPTION = 1,
    CU_COREDUMP_TRIGGER_HOST = 2,
    CU_COREDUMP_LIGHTWEIGHT = 3,
    CU_COREDUMP_ENABLE_USER_TRIGGER = 4,
    CU_COREDUMP_FILE = 5,
    CU_COREDUMP_PIPE = 6,
    CU_COREDUMP_MAX = 7,
}
pub use self::CUcoredumpSettings_enum as CUcoredumpSettings;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum CUoutput_mode_enum {
    CU_OUT_KEY_VALUE_PAIR = 0,
    CU_OUT_CSV = 1,
}
pub use self::CUoutput_mode_enum as CUoutput_mode;
extern crate libloading;
pub struct Lib {
    __library: ::libloading::Library,
    pub cuGetErrorString: Result<
        unsafe extern "C" fn(error: CUresult, pStr: *mut *const ::core::ffi::c_char) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGetErrorName: Result<
        unsafe extern "C" fn(error: CUresult, pStr: *mut *const ::core::ffi::c_char) -> CUresult,
        ::libloading::Error,
    >,
    pub cuInit:
        Result<unsafe extern "C" fn(Flags: ::core::ffi::c_uint) -> CUresult, ::libloading::Error>,
    pub cuDriverGetVersion: Result<
        unsafe extern "C" fn(driverVersion: *mut ::core::ffi::c_int) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGet: Result<
        unsafe extern "C" fn(device: *mut CUdevice, ordinal: ::core::ffi::c_int) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetCount: Result<
        unsafe extern "C" fn(count: *mut ::core::ffi::c_int) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetName: Result<
        unsafe extern "C" fn(
            name: *mut ::core::ffi::c_char,
            len: ::core::ffi::c_int,
            dev: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetUuid: Result<
        unsafe extern "C" fn(uuid: *mut CUuuid, dev: CUdevice) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetUuid_v2: Result<
        unsafe extern "C" fn(uuid: *mut CUuuid, dev: CUdevice) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetLuid: Result<
        unsafe extern "C" fn(
            luid: *mut ::core::ffi::c_char,
            deviceNodeMask: *mut ::core::ffi::c_uint,
            dev: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceTotalMem_v2: Result<
        unsafe extern "C" fn(bytes: *mut usize, dev: CUdevice) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetTexture1DLinearMaxWidth: Result<
        unsafe extern "C" fn(
            maxWidthInElements: *mut usize,
            format: CUarray_format,
            numChannels: ::core::ffi::c_uint,
            dev: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetAttribute: Result<
        unsafe extern "C" fn(
            pi: *mut ::core::ffi::c_int,
            attrib: CUdevice_attribute,
            dev: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetNvSciSyncAttributes: Result<
        unsafe extern "C" fn(
            nvSciSyncAttrList: *mut ::core::ffi::c_void,
            dev: CUdevice,
            flags: ::core::ffi::c_int,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceSetMemPool: Result<
        unsafe extern "C" fn(dev: CUdevice, pool: CUmemoryPool) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetMemPool: Result<
        unsafe extern "C" fn(pool: *mut CUmemoryPool, dev: CUdevice) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetDefaultMemPool: Result<
        unsafe extern "C" fn(pool_out: *mut CUmemoryPool, dev: CUdevice) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetExecAffinitySupport: Result<
        unsafe extern "C" fn(
            pi: *mut ::core::ffi::c_int,
            type_: CUexecAffinityType,
            dev: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuFlushGPUDirectRDMAWrites: Result<
        unsafe extern "C" fn(
            target: CUflushGPUDirectRDMAWritesTarget,
            scope: CUflushGPUDirectRDMAWritesScope,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetProperties: Result<
        unsafe extern "C" fn(prop: *mut CUdevprop, dev: CUdevice) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceComputeCapability: Result<
        unsafe extern "C" fn(
            major: *mut ::core::ffi::c_int,
            minor: *mut ::core::ffi::c_int,
            dev: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDevicePrimaryCtxRetain: Result<
        unsafe extern "C" fn(pctx: *mut CUcontext, dev: CUdevice) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDevicePrimaryCtxRelease_v2:
        Result<unsafe extern "C" fn(dev: CUdevice) -> CUresult, ::libloading::Error>,
    pub cuDevicePrimaryCtxSetFlags_v2: Result<
        unsafe extern "C" fn(dev: CUdevice, flags: ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDevicePrimaryCtxGetState: Result<
        unsafe extern "C" fn(
            dev: CUdevice,
            flags: *mut ::core::ffi::c_uint,
            active: *mut ::core::ffi::c_int,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDevicePrimaryCtxReset_v2:
        Result<unsafe extern "C" fn(dev: CUdevice) -> CUresult, ::libloading::Error>,
    pub cuCtxCreate_v2: Result<
        unsafe extern "C" fn(
            pctx: *mut CUcontext,
            flags: ::core::ffi::c_uint,
            dev: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCtxCreate_v3: Result<
        unsafe extern "C" fn(
            pctx: *mut CUcontext,
            paramsArray: *mut CUexecAffinityParam,
            numParams: ::core::ffi::c_int,
            flags: ::core::ffi::c_uint,
            dev: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCtxDestroy_v2:
        Result<unsafe extern "C" fn(ctx: CUcontext) -> CUresult, ::libloading::Error>,
    pub cuCtxPushCurrent_v2:
        Result<unsafe extern "C" fn(ctx: CUcontext) -> CUresult, ::libloading::Error>,
    pub cuCtxPopCurrent_v2:
        Result<unsafe extern "C" fn(pctx: *mut CUcontext) -> CUresult, ::libloading::Error>,
    pub cuCtxSetCurrent:
        Result<unsafe extern "C" fn(ctx: CUcontext) -> CUresult, ::libloading::Error>,
    pub cuCtxGetCurrent:
        Result<unsafe extern "C" fn(pctx: *mut CUcontext) -> CUresult, ::libloading::Error>,
    pub cuCtxGetDevice:
        Result<unsafe extern "C" fn(device: *mut CUdevice) -> CUresult, ::libloading::Error>,
    pub cuCtxGetFlags: Result<
        unsafe extern "C" fn(flags: *mut ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCtxSetFlags:
        Result<unsafe extern "C" fn(flags: ::core::ffi::c_uint) -> CUresult, ::libloading::Error>,
    pub cuCtxGetId: Result<
        unsafe extern "C" fn(ctx: CUcontext, ctxId: *mut ::core::ffi::c_ulonglong) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCtxSynchronize: Result<unsafe extern "C" fn() -> CUresult, ::libloading::Error>,
    pub cuCtxSetLimit:
        Result<unsafe extern "C" fn(limit: CUlimit, value: usize) -> CUresult, ::libloading::Error>,
    pub cuCtxGetLimit: Result<
        unsafe extern "C" fn(pvalue: *mut usize, limit: CUlimit) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCtxGetCacheConfig:
        Result<unsafe extern "C" fn(pconfig: *mut CUfunc_cache) -> CUresult, ::libloading::Error>,
    pub cuCtxSetCacheConfig:
        Result<unsafe extern "C" fn(config: CUfunc_cache) -> CUresult, ::libloading::Error>,
    pub cuCtxGetSharedMemConfig:
        Result<unsafe extern "C" fn(pConfig: *mut CUsharedconfig) -> CUresult, ::libloading::Error>,
    pub cuCtxSetSharedMemConfig:
        Result<unsafe extern "C" fn(config: CUsharedconfig) -> CUresult, ::libloading::Error>,
    pub cuCtxGetApiVersion: Result<
        unsafe extern "C" fn(ctx: CUcontext, version: *mut ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCtxGetStreamPriorityRange: Result<
        unsafe extern "C" fn(
            leastPriority: *mut ::core::ffi::c_int,
            greatestPriority: *mut ::core::ffi::c_int,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCtxResetPersistingL2Cache:
        Result<unsafe extern "C" fn() -> CUresult, ::libloading::Error>,
    pub cuCtxGetExecAffinity: Result<
        unsafe extern "C" fn(
            pExecAffinity: *mut CUexecAffinityParam,
            type_: CUexecAffinityType,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCtxAttach: Result<
        unsafe extern "C" fn(pctx: *mut CUcontext, flags: ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCtxDetach: Result<unsafe extern "C" fn(ctx: CUcontext) -> CUresult, ::libloading::Error>,
    pub cuModuleLoad: Result<
        unsafe extern "C" fn(module: *mut CUmodule, fname: *const ::core::ffi::c_char) -> CUresult,
        ::libloading::Error,
    >,
    pub cuModuleLoadData: Result<
        unsafe extern "C" fn(module: *mut CUmodule, image: *const ::core::ffi::c_void) -> CUresult,
        ::libloading::Error,
    >,
    pub cuModuleLoadDataEx: Result<
        unsafe extern "C" fn(
            module: *mut CUmodule,
            image: *const ::core::ffi::c_void,
            numOptions: ::core::ffi::c_uint,
            options: *mut CUjit_option,
            optionValues: *mut *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuModuleLoadFatBinary: Result<
        unsafe extern "C" fn(
            module: *mut CUmodule,
            fatCubin: *const ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuModuleUnload:
        Result<unsafe extern "C" fn(hmod: CUmodule) -> CUresult, ::libloading::Error>,
    pub cuModuleGetLoadingMode: Result<
        unsafe extern "C" fn(mode: *mut CUmoduleLoadingMode) -> CUresult,
        ::libloading::Error,
    >,
    pub cuModuleGetFunction: Result<
        unsafe extern "C" fn(
            hfunc: *mut CUfunction,
            hmod: CUmodule,
            name: *const ::core::ffi::c_char,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuModuleGetGlobal_v2: Result<
        unsafe extern "C" fn(
            dptr: *mut CUdeviceptr,
            bytes: *mut usize,
            hmod: CUmodule,
            name: *const ::core::ffi::c_char,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLinkCreate_v2: Result<
        unsafe extern "C" fn(
            numOptions: ::core::ffi::c_uint,
            options: *mut CUjit_option,
            optionValues: *mut *mut ::core::ffi::c_void,
            stateOut: *mut CUlinkState,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLinkAddData_v2: Result<
        unsafe extern "C" fn(
            state: CUlinkState,
            type_: CUjitInputType,
            data: *mut ::core::ffi::c_void,
            size: usize,
            name: *const ::core::ffi::c_char,
            numOptions: ::core::ffi::c_uint,
            options: *mut CUjit_option,
            optionValues: *mut *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLinkAddFile_v2: Result<
        unsafe extern "C" fn(
            state: CUlinkState,
            type_: CUjitInputType,
            path: *const ::core::ffi::c_char,
            numOptions: ::core::ffi::c_uint,
            options: *mut CUjit_option,
            optionValues: *mut *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLinkComplete: Result<
        unsafe extern "C" fn(
            state: CUlinkState,
            cubinOut: *mut *mut ::core::ffi::c_void,
            sizeOut: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLinkDestroy:
        Result<unsafe extern "C" fn(state: CUlinkState) -> CUresult, ::libloading::Error>,
    pub cuModuleGetTexRef: Result<
        unsafe extern "C" fn(
            pTexRef: *mut CUtexref,
            hmod: CUmodule,
            name: *const ::core::ffi::c_char,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuModuleGetSurfRef: Result<
        unsafe extern "C" fn(
            pSurfRef: *mut CUsurfref,
            hmod: CUmodule,
            name: *const ::core::ffi::c_char,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLibraryLoadData: Result<
        unsafe extern "C" fn(
            library: *mut CUlibrary,
            code: *const ::core::ffi::c_void,
            jitOptions: *mut CUjit_option,
            jitOptionsValues: *mut *mut ::core::ffi::c_void,
            numJitOptions: ::core::ffi::c_uint,
            libraryOptions: *mut CUlibraryOption,
            libraryOptionValues: *mut *mut ::core::ffi::c_void,
            numLibraryOptions: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLibraryLoadFromFile: Result<
        unsafe extern "C" fn(
            library: *mut CUlibrary,
            fileName: *const ::core::ffi::c_char,
            jitOptions: *mut CUjit_option,
            jitOptionsValues: *mut *mut ::core::ffi::c_void,
            numJitOptions: ::core::ffi::c_uint,
            libraryOptions: *mut CUlibraryOption,
            libraryOptionValues: *mut *mut ::core::ffi::c_void,
            numLibraryOptions: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLibraryUnload:
        Result<unsafe extern "C" fn(library: CUlibrary) -> CUresult, ::libloading::Error>,
    pub cuLibraryGetKernel: Result<
        unsafe extern "C" fn(
            pKernel: *mut CUkernel,
            library: CUlibrary,
            name: *const ::core::ffi::c_char,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLibraryGetModule: Result<
        unsafe extern "C" fn(pMod: *mut CUmodule, library: CUlibrary) -> CUresult,
        ::libloading::Error,
    >,
    pub cuKernelGetFunction: Result<
        unsafe extern "C" fn(pFunc: *mut CUfunction, kernel: CUkernel) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLibraryGetGlobal: Result<
        unsafe extern "C" fn(
            dptr: *mut CUdeviceptr,
            bytes: *mut usize,
            library: CUlibrary,
            name: *const ::core::ffi::c_char,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLibraryGetManaged: Result<
        unsafe extern "C" fn(
            dptr: *mut CUdeviceptr,
            bytes: *mut usize,
            library: CUlibrary,
            name: *const ::core::ffi::c_char,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLibraryGetUnifiedFunction: Result<
        unsafe extern "C" fn(
            fptr: *mut *mut ::core::ffi::c_void,
            library: CUlibrary,
            symbol: *const ::core::ffi::c_char,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuKernelGetAttribute: Result<
        unsafe extern "C" fn(
            pi: *mut ::core::ffi::c_int,
            attrib: CUfunction_attribute,
            kernel: CUkernel,
            dev: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuKernelSetAttribute: Result<
        unsafe extern "C" fn(
            attrib: CUfunction_attribute,
            val: ::core::ffi::c_int,
            kernel: CUkernel,
            dev: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuKernelSetCacheConfig: Result<
        unsafe extern "C" fn(kernel: CUkernel, config: CUfunc_cache, dev: CUdevice) -> CUresult,
        ::libloading::Error,
    >,
    pub cuKernelGetName: Result<
        unsafe extern "C" fn(name: *mut *const ::core::ffi::c_char, hfunc: CUkernel) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemGetInfo_v2: Result<
        unsafe extern "C" fn(free: *mut usize, total: *mut usize) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemAlloc_v2: Result<
        unsafe extern "C" fn(dptr: *mut CUdeviceptr, bytesize: usize) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemAllocPitch_v2: Result<
        unsafe extern "C" fn(
            dptr: *mut CUdeviceptr,
            pPitch: *mut usize,
            WidthInBytes: usize,
            Height: usize,
            ElementSizeBytes: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemFree_v2:
        Result<unsafe extern "C" fn(dptr: CUdeviceptr) -> CUresult, ::libloading::Error>,
    pub cuMemGetAddressRange_v2: Result<
        unsafe extern "C" fn(
            pbase: *mut CUdeviceptr,
            psize: *mut usize,
            dptr: CUdeviceptr,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemAllocHost_v2: Result<
        unsafe extern "C" fn(pp: *mut *mut ::core::ffi::c_void, bytesize: usize) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemFreeHost:
        Result<unsafe extern "C" fn(p: *mut ::core::ffi::c_void) -> CUresult, ::libloading::Error>,
    pub cuMemHostAlloc: Result<
        unsafe extern "C" fn(
            pp: *mut *mut ::core::ffi::c_void,
            bytesize: usize,
            Flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemHostGetDevicePointer_v2: Result<
        unsafe extern "C" fn(
            pdptr: *mut CUdeviceptr,
            p: *mut ::core::ffi::c_void,
            Flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemHostGetFlags: Result<
        unsafe extern "C" fn(
            pFlags: *mut ::core::ffi::c_uint,
            p: *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemAllocManaged: Result<
        unsafe extern "C" fn(
            dptr: *mut CUdeviceptr,
            bytesize: usize,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetByPCIBusId: Result<
        unsafe extern "C" fn(dev: *mut CUdevice, pciBusId: *const ::core::ffi::c_char) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGetPCIBusId: Result<
        unsafe extern "C" fn(
            pciBusId: *mut ::core::ffi::c_char,
            len: ::core::ffi::c_int,
            dev: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuIpcGetEventHandle: Result<
        unsafe extern "C" fn(pHandle: *mut CUipcEventHandle, event: CUevent) -> CUresult,
        ::libloading::Error,
    >,
    pub cuIpcOpenEventHandle: Result<
        unsafe extern "C" fn(phEvent: *mut CUevent, handle: CUipcEventHandle) -> CUresult,
        ::libloading::Error,
    >,
    pub cuIpcGetMemHandle: Result<
        unsafe extern "C" fn(pHandle: *mut CUipcMemHandle, dptr: CUdeviceptr) -> CUresult,
        ::libloading::Error,
    >,
    pub cuIpcOpenMemHandle_v2: Result<
        unsafe extern "C" fn(
            pdptr: *mut CUdeviceptr,
            handle: CUipcMemHandle,
            Flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuIpcCloseMemHandle:
        Result<unsafe extern "C" fn(dptr: CUdeviceptr) -> CUresult, ::libloading::Error>,
    pub cuMemHostRegister_v2: Result<
        unsafe extern "C" fn(
            p: *mut ::core::ffi::c_void,
            bytesize: usize,
            Flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemHostUnregister:
        Result<unsafe extern "C" fn(p: *mut ::core::ffi::c_void) -> CUresult, ::libloading::Error>,
    pub cuMemcpy: Result<
        unsafe extern "C" fn(dst: CUdeviceptr, src: CUdeviceptr, ByteCount: usize) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyPeer: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            dstContext: CUcontext,
            srcDevice: CUdeviceptr,
            srcContext: CUcontext,
            ByteCount: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyHtoD_v2: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            srcHost: *const ::core::ffi::c_void,
            ByteCount: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyDtoH_v2: Result<
        unsafe extern "C" fn(
            dstHost: *mut ::core::ffi::c_void,
            srcDevice: CUdeviceptr,
            ByteCount: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyDtoD_v2: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            srcDevice: CUdeviceptr,
            ByteCount: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyDtoA_v2: Result<
        unsafe extern "C" fn(
            dstArray: CUarray,
            dstOffset: usize,
            srcDevice: CUdeviceptr,
            ByteCount: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyAtoD_v2: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            srcArray: CUarray,
            srcOffset: usize,
            ByteCount: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyHtoA_v2: Result<
        unsafe extern "C" fn(
            dstArray: CUarray,
            dstOffset: usize,
            srcHost: *const ::core::ffi::c_void,
            ByteCount: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyAtoH_v2: Result<
        unsafe extern "C" fn(
            dstHost: *mut ::core::ffi::c_void,
            srcArray: CUarray,
            srcOffset: usize,
            ByteCount: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyAtoA_v2: Result<
        unsafe extern "C" fn(
            dstArray: CUarray,
            dstOffset: usize,
            srcArray: CUarray,
            srcOffset: usize,
            ByteCount: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpy2D_v2:
        Result<unsafe extern "C" fn(pCopy: *const CUDA_MEMCPY2D) -> CUresult, ::libloading::Error>,
    pub cuMemcpy2DUnaligned_v2:
        Result<unsafe extern "C" fn(pCopy: *const CUDA_MEMCPY2D) -> CUresult, ::libloading::Error>,
    pub cuMemcpy3D_v2:
        Result<unsafe extern "C" fn(pCopy: *const CUDA_MEMCPY3D) -> CUresult, ::libloading::Error>,
    pub cuMemcpy3DPeer: Result<
        unsafe extern "C" fn(pCopy: *const CUDA_MEMCPY3D_PEER) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyAsync: Result<
        unsafe extern "C" fn(
            dst: CUdeviceptr,
            src: CUdeviceptr,
            ByteCount: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyPeerAsync: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            dstContext: CUcontext,
            srcDevice: CUdeviceptr,
            srcContext: CUcontext,
            ByteCount: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyHtoDAsync_v2: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            srcHost: *const ::core::ffi::c_void,
            ByteCount: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyDtoHAsync_v2: Result<
        unsafe extern "C" fn(
            dstHost: *mut ::core::ffi::c_void,
            srcDevice: CUdeviceptr,
            ByteCount: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyDtoDAsync_v2: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            srcDevice: CUdeviceptr,
            ByteCount: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyHtoAAsync_v2: Result<
        unsafe extern "C" fn(
            dstArray: CUarray,
            dstOffset: usize,
            srcHost: *const ::core::ffi::c_void,
            ByteCount: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpyAtoHAsync_v2: Result<
        unsafe extern "C" fn(
            dstHost: *mut ::core::ffi::c_void,
            srcArray: CUarray,
            srcOffset: usize,
            ByteCount: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpy2DAsync_v2: Result<
        unsafe extern "C" fn(pCopy: *const CUDA_MEMCPY2D, hStream: CUstream) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpy3DAsync_v2: Result<
        unsafe extern "C" fn(pCopy: *const CUDA_MEMCPY3D, hStream: CUstream) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemcpy3DPeerAsync: Result<
        unsafe extern "C" fn(pCopy: *const CUDA_MEMCPY3D_PEER, hStream: CUstream) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemsetD8_v2: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            uc: ::core::ffi::c_uchar,
            N: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemsetD16_v2: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            us: ::core::ffi::c_ushort,
            N: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemsetD32_v2: Result<
        unsafe extern "C" fn(dstDevice: CUdeviceptr, ui: ::core::ffi::c_uint, N: usize) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemsetD2D8_v2: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            dstPitch: usize,
            uc: ::core::ffi::c_uchar,
            Width: usize,
            Height: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemsetD2D16_v2: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            dstPitch: usize,
            us: ::core::ffi::c_ushort,
            Width: usize,
            Height: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemsetD2D32_v2: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            dstPitch: usize,
            ui: ::core::ffi::c_uint,
            Width: usize,
            Height: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemsetD8Async: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            uc: ::core::ffi::c_uchar,
            N: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemsetD16Async: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            us: ::core::ffi::c_ushort,
            N: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemsetD32Async: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            ui: ::core::ffi::c_uint,
            N: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemsetD2D8Async: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            dstPitch: usize,
            uc: ::core::ffi::c_uchar,
            Width: usize,
            Height: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemsetD2D16Async: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            dstPitch: usize,
            us: ::core::ffi::c_ushort,
            Width: usize,
            Height: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemsetD2D32Async: Result<
        unsafe extern "C" fn(
            dstDevice: CUdeviceptr,
            dstPitch: usize,
            ui: ::core::ffi::c_uint,
            Width: usize,
            Height: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuArrayCreate_v2: Result<
        unsafe extern "C" fn(
            pHandle: *mut CUarray,
            pAllocateArray: *const CUDA_ARRAY_DESCRIPTOR,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuArrayGetDescriptor_v2: Result<
        unsafe extern "C" fn(
            pArrayDescriptor: *mut CUDA_ARRAY_DESCRIPTOR,
            hArray: CUarray,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuArrayGetSparseProperties: Result<
        unsafe extern "C" fn(
            sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
            array: CUarray,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMipmappedArrayGetSparseProperties: Result<
        unsafe extern "C" fn(
            sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
            mipmap: CUmipmappedArray,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuArrayGetMemoryRequirements: Result<
        unsafe extern "C" fn(
            memoryRequirements: *mut CUDA_ARRAY_MEMORY_REQUIREMENTS,
            array: CUarray,
            device: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMipmappedArrayGetMemoryRequirements: Result<
        unsafe extern "C" fn(
            memoryRequirements: *mut CUDA_ARRAY_MEMORY_REQUIREMENTS,
            mipmap: CUmipmappedArray,
            device: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuArrayGetPlane: Result<
        unsafe extern "C" fn(
            pPlaneArray: *mut CUarray,
            hArray: CUarray,
            planeIdx: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuArrayDestroy:
        Result<unsafe extern "C" fn(hArray: CUarray) -> CUresult, ::libloading::Error>,
    pub cuArray3DCreate_v2: Result<
        unsafe extern "C" fn(
            pHandle: *mut CUarray,
            pAllocateArray: *const CUDA_ARRAY3D_DESCRIPTOR,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuArray3DGetDescriptor_v2: Result<
        unsafe extern "C" fn(
            pArrayDescriptor: *mut CUDA_ARRAY3D_DESCRIPTOR,
            hArray: CUarray,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMipmappedArrayCreate: Result<
        unsafe extern "C" fn(
            pHandle: *mut CUmipmappedArray,
            pMipmappedArrayDesc: *const CUDA_ARRAY3D_DESCRIPTOR,
            numMipmapLevels: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMipmappedArrayGetLevel: Result<
        unsafe extern "C" fn(
            pLevelArray: *mut CUarray,
            hMipmappedArray: CUmipmappedArray,
            level: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMipmappedArrayDestroy: Result<
        unsafe extern "C" fn(hMipmappedArray: CUmipmappedArray) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemGetHandleForAddressRange: Result<
        unsafe extern "C" fn(
            handle: *mut ::core::ffi::c_void,
            dptr: CUdeviceptr,
            size: usize,
            handleType: CUmemRangeHandleType,
            flags: ::core::ffi::c_ulonglong,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemAddressReserve: Result<
        unsafe extern "C" fn(
            ptr: *mut CUdeviceptr,
            size: usize,
            alignment: usize,
            addr: CUdeviceptr,
            flags: ::core::ffi::c_ulonglong,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemAddressFree: Result<
        unsafe extern "C" fn(ptr: CUdeviceptr, size: usize) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemCreate: Result<
        unsafe extern "C" fn(
            handle: *mut CUmemGenericAllocationHandle,
            size: usize,
            prop: *const CUmemAllocationProp,
            flags: ::core::ffi::c_ulonglong,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemRelease: Result<
        unsafe extern "C" fn(handle: CUmemGenericAllocationHandle) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemMap: Result<
        unsafe extern "C" fn(
            ptr: CUdeviceptr,
            size: usize,
            offset: usize,
            handle: CUmemGenericAllocationHandle,
            flags: ::core::ffi::c_ulonglong,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemMapArrayAsync: Result<
        unsafe extern "C" fn(
            mapInfoList: *mut CUarrayMapInfo,
            count: ::core::ffi::c_uint,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemUnmap: Result<
        unsafe extern "C" fn(ptr: CUdeviceptr, size: usize) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemSetAccess: Result<
        unsafe extern "C" fn(
            ptr: CUdeviceptr,
            size: usize,
            desc: *const CUmemAccessDesc,
            count: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemGetAccess: Result<
        unsafe extern "C" fn(
            flags: *mut ::core::ffi::c_ulonglong,
            location: *const CUmemLocation,
            ptr: CUdeviceptr,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemExportToShareableHandle: Result<
        unsafe extern "C" fn(
            shareableHandle: *mut ::core::ffi::c_void,
            handle: CUmemGenericAllocationHandle,
            handleType: CUmemAllocationHandleType,
            flags: ::core::ffi::c_ulonglong,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemImportFromShareableHandle: Result<
        unsafe extern "C" fn(
            handle: *mut CUmemGenericAllocationHandle,
            osHandle: *mut ::core::ffi::c_void,
            shHandleType: CUmemAllocationHandleType,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemGetAllocationGranularity: Result<
        unsafe extern "C" fn(
            granularity: *mut usize,
            prop: *const CUmemAllocationProp,
            option: CUmemAllocationGranularity_flags,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemGetAllocationPropertiesFromHandle: Result<
        unsafe extern "C" fn(
            prop: *mut CUmemAllocationProp,
            handle: CUmemGenericAllocationHandle,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemRetainAllocationHandle: Result<
        unsafe extern "C" fn(
            handle: *mut CUmemGenericAllocationHandle,
            addr: *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemFreeAsync: Result<
        unsafe extern "C" fn(dptr: CUdeviceptr, hStream: CUstream) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemAllocAsync: Result<
        unsafe extern "C" fn(
            dptr: *mut CUdeviceptr,
            bytesize: usize,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemPoolTrimTo: Result<
        unsafe extern "C" fn(pool: CUmemoryPool, minBytesToKeep: usize) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemPoolSetAttribute: Result<
        unsafe extern "C" fn(
            pool: CUmemoryPool,
            attr: CUmemPool_attribute,
            value: *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemPoolGetAttribute: Result<
        unsafe extern "C" fn(
            pool: CUmemoryPool,
            attr: CUmemPool_attribute,
            value: *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemPoolSetAccess: Result<
        unsafe extern "C" fn(
            pool: CUmemoryPool,
            map: *const CUmemAccessDesc,
            count: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemPoolGetAccess: Result<
        unsafe extern "C" fn(
            flags: *mut CUmemAccess_flags,
            memPool: CUmemoryPool,
            location: *mut CUmemLocation,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemPoolCreate: Result<
        unsafe extern "C" fn(pool: *mut CUmemoryPool, poolProps: *const CUmemPoolProps) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemPoolDestroy:
        Result<unsafe extern "C" fn(pool: CUmemoryPool) -> CUresult, ::libloading::Error>,
    pub cuMemAllocFromPoolAsync: Result<
        unsafe extern "C" fn(
            dptr: *mut CUdeviceptr,
            bytesize: usize,
            pool: CUmemoryPool,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemPoolExportToShareableHandle: Result<
        unsafe extern "C" fn(
            handle_out: *mut ::core::ffi::c_void,
            pool: CUmemoryPool,
            handleType: CUmemAllocationHandleType,
            flags: ::core::ffi::c_ulonglong,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemPoolImportFromShareableHandle: Result<
        unsafe extern "C" fn(
            pool_out: *mut CUmemoryPool,
            handle: *mut ::core::ffi::c_void,
            handleType: CUmemAllocationHandleType,
            flags: ::core::ffi::c_ulonglong,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemPoolExportPointer: Result<
        unsafe extern "C" fn(
            shareData_out: *mut CUmemPoolPtrExportData,
            ptr: CUdeviceptr,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemPoolImportPointer: Result<
        unsafe extern "C" fn(
            ptr_out: *mut CUdeviceptr,
            pool: CUmemoryPool,
            shareData: *mut CUmemPoolPtrExportData,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMulticastCreate: Result<
        unsafe extern "C" fn(
            mcHandle: *mut CUmemGenericAllocationHandle,
            prop: *const CUmulticastObjectProp,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMulticastAddDevice: Result<
        unsafe extern "C" fn(mcHandle: CUmemGenericAllocationHandle, dev: CUdevice) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMulticastBindMem: Result<
        unsafe extern "C" fn(
            mcHandle: CUmemGenericAllocationHandle,
            mcOffset: usize,
            memHandle: CUmemGenericAllocationHandle,
            memOffset: usize,
            size: usize,
            flags: ::core::ffi::c_ulonglong,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMulticastBindAddr: Result<
        unsafe extern "C" fn(
            mcHandle: CUmemGenericAllocationHandle,
            mcOffset: usize,
            memptr: CUdeviceptr,
            size: usize,
            flags: ::core::ffi::c_ulonglong,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMulticastUnbind: Result<
        unsafe extern "C" fn(
            mcHandle: CUmemGenericAllocationHandle,
            dev: CUdevice,
            mcOffset: usize,
            size: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMulticastGetGranularity: Result<
        unsafe extern "C" fn(
            granularity: *mut usize,
            prop: *const CUmulticastObjectProp,
            option: CUmulticastGranularity_flags,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuPointerGetAttribute: Result<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            attribute: CUpointer_attribute,
            ptr: CUdeviceptr,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemPrefetchAsync: Result<
        unsafe extern "C" fn(
            devPtr: CUdeviceptr,
            count: usize,
            dstDevice: CUdevice,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemPrefetchAsync_v2: Result<
        unsafe extern "C" fn(
            devPtr: CUdeviceptr,
            count: usize,
            location: CUmemLocation,
            flags: ::core::ffi::c_uint,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemAdvise: Result<
        unsafe extern "C" fn(
            devPtr: CUdeviceptr,
            count: usize,
            advice: CUmem_advise,
            device: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemAdvise_v2: Result<
        unsafe extern "C" fn(
            devPtr: CUdeviceptr,
            count: usize,
            advice: CUmem_advise,
            location: CUmemLocation,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemRangeGetAttribute: Result<
        unsafe extern "C" fn(
            data: *mut ::core::ffi::c_void,
            dataSize: usize,
            attribute: CUmem_range_attribute,
            devPtr: CUdeviceptr,
            count: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuMemRangeGetAttributes: Result<
        unsafe extern "C" fn(
            data: *mut *mut ::core::ffi::c_void,
            dataSizes: *mut usize,
            attributes: *mut CUmem_range_attribute,
            numAttributes: usize,
            devPtr: CUdeviceptr,
            count: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuPointerSetAttribute: Result<
        unsafe extern "C" fn(
            value: *const ::core::ffi::c_void,
            attribute: CUpointer_attribute,
            ptr: CUdeviceptr,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuPointerGetAttributes: Result<
        unsafe extern "C" fn(
            numAttributes: ::core::ffi::c_uint,
            attributes: *mut CUpointer_attribute,
            data: *mut *mut ::core::ffi::c_void,
            ptr: CUdeviceptr,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamCreate: Result<
        unsafe extern "C" fn(phStream: *mut CUstream, Flags: ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamCreateWithPriority: Result<
        unsafe extern "C" fn(
            phStream: *mut CUstream,
            flags: ::core::ffi::c_uint,
            priority: ::core::ffi::c_int,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamGetPriority: Result<
        unsafe extern "C" fn(hStream: CUstream, priority: *mut ::core::ffi::c_int) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamGetFlags: Result<
        unsafe extern "C" fn(hStream: CUstream, flags: *mut ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamGetId: Result<
        unsafe extern "C" fn(
            hStream: CUstream,
            streamId: *mut ::core::ffi::c_ulonglong,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamGetCtx: Result<
        unsafe extern "C" fn(hStream: CUstream, pctx: *mut CUcontext) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamWaitEvent: Result<
        unsafe extern "C" fn(
            hStream: CUstream,
            hEvent: CUevent,
            Flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamAddCallback: Result<
        unsafe extern "C" fn(
            hStream: CUstream,
            callback: CUstreamCallback,
            userData: *mut ::core::ffi::c_void,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamBeginCapture_v2: Result<
        unsafe extern "C" fn(hStream: CUstream, mode: CUstreamCaptureMode) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamBeginCaptureToGraph: Result<
        unsafe extern "C" fn(
            hStream: CUstream,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            dependencyData: *const CUgraphEdgeData,
            numDependencies: usize,
            mode: CUstreamCaptureMode,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuThreadExchangeStreamCaptureMode: Result<
        unsafe extern "C" fn(mode: *mut CUstreamCaptureMode) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamEndCapture: Result<
        unsafe extern "C" fn(hStream: CUstream, phGraph: *mut CUgraph) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamIsCapturing: Result<
        unsafe extern "C" fn(
            hStream: CUstream,
            captureStatus: *mut CUstreamCaptureStatus,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamGetCaptureInfo_v2: Result<
        unsafe extern "C" fn(
            hStream: CUstream,
            captureStatus_out: *mut CUstreamCaptureStatus,
            id_out: *mut cuuint64_t,
            graph_out: *mut CUgraph,
            dependencies_out: *mut *const CUgraphNode,
            numDependencies_out: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamGetCaptureInfo_v3: Result<
        unsafe extern "C" fn(
            hStream: CUstream,
            captureStatus_out: *mut CUstreamCaptureStatus,
            id_out: *mut cuuint64_t,
            graph_out: *mut CUgraph,
            dependencies_out: *mut *const CUgraphNode,
            edgeData_out: *mut *const CUgraphEdgeData,
            numDependencies_out: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamUpdateCaptureDependencies: Result<
        unsafe extern "C" fn(
            hStream: CUstream,
            dependencies: *mut CUgraphNode,
            numDependencies: usize,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamUpdateCaptureDependencies_v2: Result<
        unsafe extern "C" fn(
            hStream: CUstream,
            dependencies: *mut CUgraphNode,
            dependencyData: *const CUgraphEdgeData,
            numDependencies: usize,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamAttachMemAsync: Result<
        unsafe extern "C" fn(
            hStream: CUstream,
            dptr: CUdeviceptr,
            length: usize,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamQuery:
        Result<unsafe extern "C" fn(hStream: CUstream) -> CUresult, ::libloading::Error>,
    pub cuStreamSynchronize:
        Result<unsafe extern "C" fn(hStream: CUstream) -> CUresult, ::libloading::Error>,
    pub cuStreamDestroy_v2:
        Result<unsafe extern "C" fn(hStream: CUstream) -> CUresult, ::libloading::Error>,
    pub cuStreamCopyAttributes:
        Result<unsafe extern "C" fn(dst: CUstream, src: CUstream) -> CUresult, ::libloading::Error>,
    pub cuStreamGetAttribute: Result<
        unsafe extern "C" fn(
            hStream: CUstream,
            attr: CUstreamAttrID,
            value_out: *mut CUstreamAttrValue,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamSetAttribute: Result<
        unsafe extern "C" fn(
            hStream: CUstream,
            attr: CUstreamAttrID,
            value: *const CUstreamAttrValue,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuEventCreate: Result<
        unsafe extern "C" fn(phEvent: *mut CUevent, Flags: ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuEventRecord: Result<
        unsafe extern "C" fn(hEvent: CUevent, hStream: CUstream) -> CUresult,
        ::libloading::Error,
    >,
    pub cuEventRecordWithFlags: Result<
        unsafe extern "C" fn(
            hEvent: CUevent,
            hStream: CUstream,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuEventQuery:
        Result<unsafe extern "C" fn(hEvent: CUevent) -> CUresult, ::libloading::Error>,
    pub cuEventSynchronize:
        Result<unsafe extern "C" fn(hEvent: CUevent) -> CUresult, ::libloading::Error>,
    pub cuEventDestroy_v2:
        Result<unsafe extern "C" fn(hEvent: CUevent) -> CUresult, ::libloading::Error>,
    pub cuEventElapsedTime: Result<
        unsafe extern "C" fn(pMilliseconds: *mut f32, hStart: CUevent, hEnd: CUevent) -> CUresult,
        ::libloading::Error,
    >,
    pub cuImportExternalMemory: Result<
        unsafe extern "C" fn(
            extMem_out: *mut CUexternalMemory,
            memHandleDesc: *const CUDA_EXTERNAL_MEMORY_HANDLE_DESC,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuExternalMemoryGetMappedBuffer: Result<
        unsafe extern "C" fn(
            devPtr: *mut CUdeviceptr,
            extMem: CUexternalMemory,
            bufferDesc: *const CUDA_EXTERNAL_MEMORY_BUFFER_DESC,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuExternalMemoryGetMappedMipmappedArray: Result<
        unsafe extern "C" fn(
            mipmap: *mut CUmipmappedArray,
            extMem: CUexternalMemory,
            mipmapDesc: *const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDestroyExternalMemory:
        Result<unsafe extern "C" fn(extMem: CUexternalMemory) -> CUresult, ::libloading::Error>,
    pub cuImportExternalSemaphore: Result<
        unsafe extern "C" fn(
            extSem_out: *mut CUexternalSemaphore,
            semHandleDesc: *const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuSignalExternalSemaphoresAsync: Result<
        unsafe extern "C" fn(
            extSemArray: *const CUexternalSemaphore,
            paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
            numExtSems: ::core::ffi::c_uint,
            stream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuWaitExternalSemaphoresAsync: Result<
        unsafe extern "C" fn(
            extSemArray: *const CUexternalSemaphore,
            paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
            numExtSems: ::core::ffi::c_uint,
            stream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDestroyExternalSemaphore:
        Result<unsafe extern "C" fn(extSem: CUexternalSemaphore) -> CUresult, ::libloading::Error>,
    pub cuStreamWaitValue32_v2: Result<
        unsafe extern "C" fn(
            stream: CUstream,
            addr: CUdeviceptr,
            value: cuuint32_t,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamWaitValue64_v2: Result<
        unsafe extern "C" fn(
            stream: CUstream,
            addr: CUdeviceptr,
            value: cuuint64_t,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamWriteValue32_v2: Result<
        unsafe extern "C" fn(
            stream: CUstream,
            addr: CUdeviceptr,
            value: cuuint32_t,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamWriteValue64_v2: Result<
        unsafe extern "C" fn(
            stream: CUstream,
            addr: CUdeviceptr,
            value: cuuint64_t,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuStreamBatchMemOp_v2: Result<
        unsafe extern "C" fn(
            stream: CUstream,
            count: ::core::ffi::c_uint,
            paramArray: *mut CUstreamBatchMemOpParams,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuFuncGetAttribute: Result<
        unsafe extern "C" fn(
            pi: *mut ::core::ffi::c_int,
            attrib: CUfunction_attribute,
            hfunc: CUfunction,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuFuncSetAttribute: Result<
        unsafe extern "C" fn(
            hfunc: CUfunction,
            attrib: CUfunction_attribute,
            value: ::core::ffi::c_int,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuFuncSetCacheConfig: Result<
        unsafe extern "C" fn(hfunc: CUfunction, config: CUfunc_cache) -> CUresult,
        ::libloading::Error,
    >,
    pub cuFuncSetSharedMemConfig: Result<
        unsafe extern "C" fn(hfunc: CUfunction, config: CUsharedconfig) -> CUresult,
        ::libloading::Error,
    >,
    pub cuFuncGetModule: Result<
        unsafe extern "C" fn(hmod: *mut CUmodule, hfunc: CUfunction) -> CUresult,
        ::libloading::Error,
    >,
    pub cuFuncGetName: Result<
        unsafe extern "C" fn(name: *mut *const ::core::ffi::c_char, hfunc: CUfunction) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLaunchKernel: Result<
        unsafe extern "C" fn(
            f: CUfunction,
            gridDimX: ::core::ffi::c_uint,
            gridDimY: ::core::ffi::c_uint,
            gridDimZ: ::core::ffi::c_uint,
            blockDimX: ::core::ffi::c_uint,
            blockDimY: ::core::ffi::c_uint,
            blockDimZ: ::core::ffi::c_uint,
            sharedMemBytes: ::core::ffi::c_uint,
            hStream: CUstream,
            kernelParams: *mut *mut ::core::ffi::c_void,
            extra: *mut *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLaunchKernelEx: Result<
        unsafe extern "C" fn(
            config: *const CUlaunchConfig,
            f: CUfunction,
            kernelParams: *mut *mut ::core::ffi::c_void,
            extra: *mut *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLaunchCooperativeKernel: Result<
        unsafe extern "C" fn(
            f: CUfunction,
            gridDimX: ::core::ffi::c_uint,
            gridDimY: ::core::ffi::c_uint,
            gridDimZ: ::core::ffi::c_uint,
            blockDimX: ::core::ffi::c_uint,
            blockDimY: ::core::ffi::c_uint,
            blockDimZ: ::core::ffi::c_uint,
            sharedMemBytes: ::core::ffi::c_uint,
            hStream: CUstream,
            kernelParams: *mut *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLaunchCooperativeKernelMultiDevice: Result<
        unsafe extern "C" fn(
            launchParamsList: *mut CUDA_LAUNCH_PARAMS,
            numDevices: ::core::ffi::c_uint,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLaunchHostFunc: Result<
        unsafe extern "C" fn(
            hStream: CUstream,
            fn_: CUhostFn,
            userData: *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuFuncSetBlockShape: Result<
        unsafe extern "C" fn(
            hfunc: CUfunction,
            x: ::core::ffi::c_int,
            y: ::core::ffi::c_int,
            z: ::core::ffi::c_int,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuFuncSetSharedSize: Result<
        unsafe extern "C" fn(hfunc: CUfunction, bytes: ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuParamSetSize: Result<
        unsafe extern "C" fn(hfunc: CUfunction, numbytes: ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuParamSeti: Result<
        unsafe extern "C" fn(
            hfunc: CUfunction,
            offset: ::core::ffi::c_int,
            value: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuParamSetf: Result<
        unsafe extern "C" fn(hfunc: CUfunction, offset: ::core::ffi::c_int, value: f32) -> CUresult,
        ::libloading::Error,
    >,
    pub cuParamSetv: Result<
        unsafe extern "C" fn(
            hfunc: CUfunction,
            offset: ::core::ffi::c_int,
            ptr: *mut ::core::ffi::c_void,
            numbytes: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLaunch: Result<unsafe extern "C" fn(f: CUfunction) -> CUresult, ::libloading::Error>,
    pub cuLaunchGrid: Result<
        unsafe extern "C" fn(
            f: CUfunction,
            grid_width: ::core::ffi::c_int,
            grid_height: ::core::ffi::c_int,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuLaunchGridAsync: Result<
        unsafe extern "C" fn(
            f: CUfunction,
            grid_width: ::core::ffi::c_int,
            grid_height: ::core::ffi::c_int,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuParamSetTexRef: Result<
        unsafe extern "C" fn(
            hfunc: CUfunction,
            texunit: ::core::ffi::c_int,
            hTexRef: CUtexref,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphCreate: Result<
        unsafe extern "C" fn(phGraph: *mut CUgraph, flags: ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddKernelNode_v2: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
            nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphKernelNodeGetParams_v2: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            nodeParams: *mut CUDA_KERNEL_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphKernelNodeSetParams_v2: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddMemcpyNode: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
            copyParams: *const CUDA_MEMCPY3D,
            ctx: CUcontext,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphMemcpyNodeGetParams: Result<
        unsafe extern "C" fn(hNode: CUgraphNode, nodeParams: *mut CUDA_MEMCPY3D) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphMemcpyNodeSetParams: Result<
        unsafe extern "C" fn(hNode: CUgraphNode, nodeParams: *const CUDA_MEMCPY3D) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddMemsetNode: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
            memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
            ctx: CUcontext,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphMemsetNodeGetParams: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            nodeParams: *mut CUDA_MEMSET_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphMemsetNodeSetParams: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            nodeParams: *const CUDA_MEMSET_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddHostNode: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
            nodeParams: *const CUDA_HOST_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphHostNodeGetParams: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            nodeParams: *mut CUDA_HOST_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphHostNodeSetParams: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            nodeParams: *const CUDA_HOST_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddChildGraphNode: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
            childGraph: CUgraph,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphChildGraphNodeGetGraph: Result<
        unsafe extern "C" fn(hNode: CUgraphNode, phGraph: *mut CUgraph) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddEmptyNode: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddEventRecordNode: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
            event: CUevent,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphEventRecordNodeGetEvent: Result<
        unsafe extern "C" fn(hNode: CUgraphNode, event_out: *mut CUevent) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphEventRecordNodeSetEvent: Result<
        unsafe extern "C" fn(hNode: CUgraphNode, event: CUevent) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddEventWaitNode: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
            event: CUevent,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphEventWaitNodeGetEvent: Result<
        unsafe extern "C" fn(hNode: CUgraphNode, event_out: *mut CUevent) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphEventWaitNodeSetEvent: Result<
        unsafe extern "C" fn(hNode: CUgraphNode, event: CUevent) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddExternalSemaphoresSignalNode: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
            nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExternalSemaphoresSignalNodeGetParams: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            params_out: *mut CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExternalSemaphoresSignalNodeSetParams: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddExternalSemaphoresWaitNode: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
            nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExternalSemaphoresWaitNodeGetParams: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            params_out: *mut CUDA_EXT_SEM_WAIT_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExternalSemaphoresWaitNodeSetParams: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddBatchMemOpNode: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
            nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphBatchMemOpNodeGetParams: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            nodeParams_out: *mut CUDA_BATCH_MEM_OP_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphBatchMemOpNodeSetParams: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExecBatchMemOpNodeSetParams: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hNode: CUgraphNode,
            nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddMemAllocNode: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
            nodeParams: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphMemAllocNodeGetParams: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            params_out: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddMemFreeNode: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
            dptr: CUdeviceptr,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphMemFreeNodeGetParams: Result<
        unsafe extern "C" fn(hNode: CUgraphNode, dptr_out: *mut CUdeviceptr) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceGraphMemTrim:
        Result<unsafe extern "C" fn(device: CUdevice) -> CUresult, ::libloading::Error>,
    pub cuDeviceGetGraphMemAttribute: Result<
        unsafe extern "C" fn(
            device: CUdevice,
            attr: CUgraphMem_attribute,
            value: *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceSetGraphMemAttribute: Result<
        unsafe extern "C" fn(
            device: CUdevice,
            attr: CUgraphMem_attribute,
            value: *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphClone: Result<
        unsafe extern "C" fn(phGraphClone: *mut CUgraph, originalGraph: CUgraph) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphNodeFindInClone: Result<
        unsafe extern "C" fn(
            phNode: *mut CUgraphNode,
            hOriginalNode: CUgraphNode,
            hClonedGraph: CUgraph,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphNodeGetType: Result<
        unsafe extern "C" fn(hNode: CUgraphNode, type_: *mut CUgraphNodeType) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphGetNodes: Result<
        unsafe extern "C" fn(
            hGraph: CUgraph,
            nodes: *mut CUgraphNode,
            numNodes: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphGetRootNodes: Result<
        unsafe extern "C" fn(
            hGraph: CUgraph,
            rootNodes: *mut CUgraphNode,
            numRootNodes: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphGetEdges: Result<
        unsafe extern "C" fn(
            hGraph: CUgraph,
            from: *mut CUgraphNode,
            to: *mut CUgraphNode,
            numEdges: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphGetEdges_v2: Result<
        unsafe extern "C" fn(
            hGraph: CUgraph,
            from: *mut CUgraphNode,
            to: *mut CUgraphNode,
            edgeData: *mut CUgraphEdgeData,
            numEdges: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphNodeGetDependencies: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            dependencies: *mut CUgraphNode,
            numDependencies: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphNodeGetDependencies_v2: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            dependencies: *mut CUgraphNode,
            edgeData: *mut CUgraphEdgeData,
            numDependencies: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphNodeGetDependentNodes: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            dependentNodes: *mut CUgraphNode,
            numDependentNodes: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphNodeGetDependentNodes_v2: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            dependentNodes: *mut CUgraphNode,
            edgeData: *mut CUgraphEdgeData,
            numDependentNodes: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddDependencies: Result<
        unsafe extern "C" fn(
            hGraph: CUgraph,
            from: *const CUgraphNode,
            to: *const CUgraphNode,
            numDependencies: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddDependencies_v2: Result<
        unsafe extern "C" fn(
            hGraph: CUgraph,
            from: *const CUgraphNode,
            to: *const CUgraphNode,
            edgeData: *const CUgraphEdgeData,
            numDependencies: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphRemoveDependencies: Result<
        unsafe extern "C" fn(
            hGraph: CUgraph,
            from: *const CUgraphNode,
            to: *const CUgraphNode,
            numDependencies: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphRemoveDependencies_v2: Result<
        unsafe extern "C" fn(
            hGraph: CUgraph,
            from: *const CUgraphNode,
            to: *const CUgraphNode,
            edgeData: *const CUgraphEdgeData,
            numDependencies: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphDestroyNode:
        Result<unsafe extern "C" fn(hNode: CUgraphNode) -> CUresult, ::libloading::Error>,
    pub cuGraphInstantiateWithFlags: Result<
        unsafe extern "C" fn(
            phGraphExec: *mut CUgraphExec,
            hGraph: CUgraph,
            flags: ::core::ffi::c_ulonglong,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphInstantiateWithParams: Result<
        unsafe extern "C" fn(
            phGraphExec: *mut CUgraphExec,
            hGraph: CUgraph,
            instantiateParams: *mut CUDA_GRAPH_INSTANTIATE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExecGetFlags: Result<
        unsafe extern "C" fn(hGraphExec: CUgraphExec, flags: *mut cuuint64_t) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExecKernelNodeSetParams_v2: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hNode: CUgraphNode,
            nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExecMemcpyNodeSetParams: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hNode: CUgraphNode,
            copyParams: *const CUDA_MEMCPY3D,
            ctx: CUcontext,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExecMemsetNodeSetParams: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hNode: CUgraphNode,
            memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
            ctx: CUcontext,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExecHostNodeSetParams: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hNode: CUgraphNode,
            nodeParams: *const CUDA_HOST_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExecChildGraphNodeSetParams: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hNode: CUgraphNode,
            childGraph: CUgraph,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExecEventRecordNodeSetEvent: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hNode: CUgraphNode,
            event: CUevent,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExecEventWaitNodeSetEvent: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hNode: CUgraphNode,
            event: CUevent,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExecExternalSemaphoresSignalNodeSetParams: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hNode: CUgraphNode,
            nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExecExternalSemaphoresWaitNodeSetParams: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hNode: CUgraphNode,
            nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphNodeSetEnabled: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hNode: CUgraphNode,
            isEnabled: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphNodeGetEnabled: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hNode: CUgraphNode,
            isEnabled: *mut ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphUpload: Result<
        unsafe extern "C" fn(hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphLaunch: Result<
        unsafe extern "C" fn(hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExecDestroy:
        Result<unsafe extern "C" fn(hGraphExec: CUgraphExec) -> CUresult, ::libloading::Error>,
    pub cuGraphDestroy:
        Result<unsafe extern "C" fn(hGraph: CUgraph) -> CUresult, ::libloading::Error>,
    pub cuGraphExecUpdate_v2: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hGraph: CUgraph,
            resultInfo: *mut CUgraphExecUpdateResultInfo,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphKernelNodeCopyAttributes: Result<
        unsafe extern "C" fn(dst: CUgraphNode, src: CUgraphNode) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphKernelNodeGetAttribute: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            attr: CUkernelNodeAttrID,
            value_out: *mut CUkernelNodeAttrValue,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphKernelNodeSetAttribute: Result<
        unsafe extern "C" fn(
            hNode: CUgraphNode,
            attr: CUkernelNodeAttrID,
            value: *const CUkernelNodeAttrValue,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphDebugDotPrint: Result<
        unsafe extern "C" fn(
            hGraph: CUgraph,
            path: *const ::core::ffi::c_char,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuUserObjectCreate: Result<
        unsafe extern "C" fn(
            object_out: *mut CUuserObject,
            ptr: *mut ::core::ffi::c_void,
            destroy: CUhostFn,
            initialRefcount: ::core::ffi::c_uint,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuUserObjectRetain: Result<
        unsafe extern "C" fn(object: CUuserObject, count: ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuUserObjectRelease: Result<
        unsafe extern "C" fn(object: CUuserObject, count: ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphRetainUserObject: Result<
        unsafe extern "C" fn(
            graph: CUgraph,
            object: CUuserObject,
            count: ::core::ffi::c_uint,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphReleaseUserObject: Result<
        unsafe extern "C" fn(
            graph: CUgraph,
            object: CUuserObject,
            count: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddNode: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            numDependencies: usize,
            nodeParams: *mut CUgraphNodeParams,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphAddNode_v2: Result<
        unsafe extern "C" fn(
            phGraphNode: *mut CUgraphNode,
            hGraph: CUgraph,
            dependencies: *const CUgraphNode,
            dependencyData: *const CUgraphEdgeData,
            numDependencies: usize,
            nodeParams: *mut CUgraphNodeParams,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphNodeSetParams: Result<
        unsafe extern "C" fn(hNode: CUgraphNode, nodeParams: *mut CUgraphNodeParams) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphExecNodeSetParams: Result<
        unsafe extern "C" fn(
            hGraphExec: CUgraphExec,
            hNode: CUgraphNode,
            nodeParams: *mut CUgraphNodeParams,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphConditionalHandleCreate: Result<
        unsafe extern "C" fn(
            pHandle_out: *mut CUgraphConditionalHandle,
            hGraph: CUgraph,
            ctx: CUcontext,
            defaultLaunchValue: ::core::ffi::c_uint,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuOccupancyMaxActiveBlocksPerMultiprocessor: Result<
        unsafe extern "C" fn(
            numBlocks: *mut ::core::ffi::c_int,
            func: CUfunction,
            blockSize: ::core::ffi::c_int,
            dynamicSMemSize: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags: Result<
        unsafe extern "C" fn(
            numBlocks: *mut ::core::ffi::c_int,
            func: CUfunction,
            blockSize: ::core::ffi::c_int,
            dynamicSMemSize: usize,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuOccupancyMaxPotentialBlockSize: Result<
        unsafe extern "C" fn(
            minGridSize: *mut ::core::ffi::c_int,
            blockSize: *mut ::core::ffi::c_int,
            func: CUfunction,
            blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
            dynamicSMemSize: usize,
            blockSizeLimit: ::core::ffi::c_int,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuOccupancyMaxPotentialBlockSizeWithFlags: Result<
        unsafe extern "C" fn(
            minGridSize: *mut ::core::ffi::c_int,
            blockSize: *mut ::core::ffi::c_int,
            func: CUfunction,
            blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
            dynamicSMemSize: usize,
            blockSizeLimit: ::core::ffi::c_int,
            flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuOccupancyAvailableDynamicSMemPerBlock: Result<
        unsafe extern "C" fn(
            dynamicSmemSize: *mut usize,
            func: CUfunction,
            numBlocks: ::core::ffi::c_int,
            blockSize: ::core::ffi::c_int,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuOccupancyMaxPotentialClusterSize: Result<
        unsafe extern "C" fn(
            clusterSize: *mut ::core::ffi::c_int,
            func: CUfunction,
            config: *const CUlaunchConfig,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuOccupancyMaxActiveClusters: Result<
        unsafe extern "C" fn(
            numClusters: *mut ::core::ffi::c_int,
            func: CUfunction,
            config: *const CUlaunchConfig,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefSetArray: Result<
        unsafe extern "C" fn(
            hTexRef: CUtexref,
            hArray: CUarray,
            Flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefSetMipmappedArray: Result<
        unsafe extern "C" fn(
            hTexRef: CUtexref,
            hMipmappedArray: CUmipmappedArray,
            Flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefSetAddress_v2: Result<
        unsafe extern "C" fn(
            ByteOffset: *mut usize,
            hTexRef: CUtexref,
            dptr: CUdeviceptr,
            bytes: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefSetAddress2D_v3: Result<
        unsafe extern "C" fn(
            hTexRef: CUtexref,
            desc: *const CUDA_ARRAY_DESCRIPTOR,
            dptr: CUdeviceptr,
            Pitch: usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefSetFormat: Result<
        unsafe extern "C" fn(
            hTexRef: CUtexref,
            fmt: CUarray_format,
            NumPackedComponents: ::core::ffi::c_int,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefSetAddressMode: Result<
        unsafe extern "C" fn(
            hTexRef: CUtexref,
            dim: ::core::ffi::c_int,
            am: CUaddress_mode,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefSetFilterMode: Result<
        unsafe extern "C" fn(hTexRef: CUtexref, fm: CUfilter_mode) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefSetMipmapFilterMode: Result<
        unsafe extern "C" fn(hTexRef: CUtexref, fm: CUfilter_mode) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefSetMipmapLevelBias:
        Result<unsafe extern "C" fn(hTexRef: CUtexref, bias: f32) -> CUresult, ::libloading::Error>,
    pub cuTexRefSetMipmapLevelClamp: Result<
        unsafe extern "C" fn(
            hTexRef: CUtexref,
            minMipmapLevelClamp: f32,
            maxMipmapLevelClamp: f32,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefSetMaxAnisotropy: Result<
        unsafe extern "C" fn(hTexRef: CUtexref, maxAniso: ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefSetBorderColor: Result<
        unsafe extern "C" fn(hTexRef: CUtexref, pBorderColor: *mut f32) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefSetFlags: Result<
        unsafe extern "C" fn(hTexRef: CUtexref, Flags: ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefGetAddress_v2: Result<
        unsafe extern "C" fn(pdptr: *mut CUdeviceptr, hTexRef: CUtexref) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefGetArray: Result<
        unsafe extern "C" fn(phArray: *mut CUarray, hTexRef: CUtexref) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefGetMipmappedArray: Result<
        unsafe extern "C" fn(
            phMipmappedArray: *mut CUmipmappedArray,
            hTexRef: CUtexref,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefGetAddressMode: Result<
        unsafe extern "C" fn(
            pam: *mut CUaddress_mode,
            hTexRef: CUtexref,
            dim: ::core::ffi::c_int,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefGetFilterMode: Result<
        unsafe extern "C" fn(pfm: *mut CUfilter_mode, hTexRef: CUtexref) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefGetFormat: Result<
        unsafe extern "C" fn(
            pFormat: *mut CUarray_format,
            pNumChannels: *mut ::core::ffi::c_int,
            hTexRef: CUtexref,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefGetMipmapFilterMode: Result<
        unsafe extern "C" fn(pfm: *mut CUfilter_mode, hTexRef: CUtexref) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefGetMipmapLevelBias: Result<
        unsafe extern "C" fn(pbias: *mut f32, hTexRef: CUtexref) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefGetMipmapLevelClamp: Result<
        unsafe extern "C" fn(
            pminMipmapLevelClamp: *mut f32,
            pmaxMipmapLevelClamp: *mut f32,
            hTexRef: CUtexref,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefGetMaxAnisotropy: Result<
        unsafe extern "C" fn(pmaxAniso: *mut ::core::ffi::c_int, hTexRef: CUtexref) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefGetBorderColor: Result<
        unsafe extern "C" fn(pBorderColor: *mut f32, hTexRef: CUtexref) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefGetFlags: Result<
        unsafe extern "C" fn(pFlags: *mut ::core::ffi::c_uint, hTexRef: CUtexref) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexRefCreate:
        Result<unsafe extern "C" fn(pTexRef: *mut CUtexref) -> CUresult, ::libloading::Error>,
    pub cuTexRefDestroy:
        Result<unsafe extern "C" fn(hTexRef: CUtexref) -> CUresult, ::libloading::Error>,
    pub cuSurfRefSetArray: Result<
        unsafe extern "C" fn(
            hSurfRef: CUsurfref,
            hArray: CUarray,
            Flags: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuSurfRefGetArray: Result<
        unsafe extern "C" fn(phArray: *mut CUarray, hSurfRef: CUsurfref) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexObjectCreate: Result<
        unsafe extern "C" fn(
            pTexObject: *mut CUtexObject,
            pResDesc: *const CUDA_RESOURCE_DESC,
            pTexDesc: *const CUDA_TEXTURE_DESC,
            pResViewDesc: *const CUDA_RESOURCE_VIEW_DESC,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexObjectDestroy:
        Result<unsafe extern "C" fn(texObject: CUtexObject) -> CUresult, ::libloading::Error>,
    pub cuTexObjectGetResourceDesc: Result<
        unsafe extern "C" fn(pResDesc: *mut CUDA_RESOURCE_DESC, texObject: CUtexObject) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexObjectGetTextureDesc: Result<
        unsafe extern "C" fn(pTexDesc: *mut CUDA_TEXTURE_DESC, texObject: CUtexObject) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTexObjectGetResourceViewDesc: Result<
        unsafe extern "C" fn(
            pResViewDesc: *mut CUDA_RESOURCE_VIEW_DESC,
            texObject: CUtexObject,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuSurfObjectCreate: Result<
        unsafe extern "C" fn(
            pSurfObject: *mut CUsurfObject,
            pResDesc: *const CUDA_RESOURCE_DESC,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuSurfObjectDestroy:
        Result<unsafe extern "C" fn(surfObject: CUsurfObject) -> CUresult, ::libloading::Error>,
    pub cuSurfObjectGetResourceDesc: Result<
        unsafe extern "C" fn(
            pResDesc: *mut CUDA_RESOURCE_DESC,
            surfObject: CUsurfObject,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTensorMapEncodeTiled: Result<
        unsafe extern "C" fn(
            tensorMap: *mut CUtensorMap,
            tensorDataType: CUtensorMapDataType,
            tensorRank: cuuint32_t,
            globalAddress: *mut ::core::ffi::c_void,
            globalDim: *const cuuint64_t,
            globalStrides: *const cuuint64_t,
            boxDim: *const cuuint32_t,
            elementStrides: *const cuuint32_t,
            interleave: CUtensorMapInterleave,
            swizzle: CUtensorMapSwizzle,
            l2Promotion: CUtensorMapL2promotion,
            oobFill: CUtensorMapFloatOOBfill,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTensorMapEncodeIm2col: Result<
        unsafe extern "C" fn(
            tensorMap: *mut CUtensorMap,
            tensorDataType: CUtensorMapDataType,
            tensorRank: cuuint32_t,
            globalAddress: *mut ::core::ffi::c_void,
            globalDim: *const cuuint64_t,
            globalStrides: *const cuuint64_t,
            pixelBoxLowerCorner: *const ::core::ffi::c_int,
            pixelBoxUpperCorner: *const ::core::ffi::c_int,
            channelsPerPixel: cuuint32_t,
            pixelsPerColumn: cuuint32_t,
            elementStrides: *const cuuint32_t,
            interleave: CUtensorMapInterleave,
            swizzle: CUtensorMapSwizzle,
            l2Promotion: CUtensorMapL2promotion,
            oobFill: CUtensorMapFloatOOBfill,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuTensorMapReplaceAddress: Result<
        unsafe extern "C" fn(
            tensorMap: *mut CUtensorMap,
            globalAddress: *mut ::core::ffi::c_void,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuDeviceCanAccessPeer: Result<
        unsafe extern "C" fn(
            canAccessPeer: *mut ::core::ffi::c_int,
            dev: CUdevice,
            peerDev: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCtxEnablePeerAccess: Result<
        unsafe extern "C" fn(peerContext: CUcontext, Flags: ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCtxDisablePeerAccess:
        Result<unsafe extern "C" fn(peerContext: CUcontext) -> CUresult, ::libloading::Error>,
    pub cuDeviceGetP2PAttribute: Result<
        unsafe extern "C" fn(
            value: *mut ::core::ffi::c_int,
            attrib: CUdevice_P2PAttribute,
            srcDevice: CUdevice,
            dstDevice: CUdevice,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphicsUnregisterResource:
        Result<unsafe extern "C" fn(resource: CUgraphicsResource) -> CUresult, ::libloading::Error>,
    pub cuGraphicsSubResourceGetMappedArray: Result<
        unsafe extern "C" fn(
            pArray: *mut CUarray,
            resource: CUgraphicsResource,
            arrayIndex: ::core::ffi::c_uint,
            mipLevel: ::core::ffi::c_uint,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphicsResourceGetMappedMipmappedArray: Result<
        unsafe extern "C" fn(
            pMipmappedArray: *mut CUmipmappedArray,
            resource: CUgraphicsResource,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphicsResourceGetMappedPointer_v2: Result<
        unsafe extern "C" fn(
            pDevPtr: *mut CUdeviceptr,
            pSize: *mut usize,
            resource: CUgraphicsResource,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphicsResourceSetMapFlags_v2: Result<
        unsafe extern "C" fn(resource: CUgraphicsResource, flags: ::core::ffi::c_uint) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphicsMapResources: Result<
        unsafe extern "C" fn(
            count: ::core::ffi::c_uint,
            resources: *mut CUgraphicsResource,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGraphicsUnmapResources: Result<
        unsafe extern "C" fn(
            count: ::core::ffi::c_uint,
            resources: *mut CUgraphicsResource,
            hStream: CUstream,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGetProcAddress_v2: Result<
        unsafe extern "C" fn(
            symbol: *const ::core::ffi::c_char,
            pfn: *mut *mut ::core::ffi::c_void,
            cudaVersion: ::core::ffi::c_int,
            flags: cuuint64_t,
            symbolStatus: *mut CUdriverProcAddressQueryResult,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCoredumpGetAttribute: Result<
        unsafe extern "C" fn(
            attrib: CUcoredumpSettings,
            value: *mut ::core::ffi::c_void,
            size: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCoredumpGetAttributeGlobal: Result<
        unsafe extern "C" fn(
            attrib: CUcoredumpSettings,
            value: *mut ::core::ffi::c_void,
            size: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCoredumpSetAttribute: Result<
        unsafe extern "C" fn(
            attrib: CUcoredumpSettings,
            value: *mut ::core::ffi::c_void,
            size: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuCoredumpSetAttributeGlobal: Result<
        unsafe extern "C" fn(
            attrib: CUcoredumpSettings,
            value: *mut ::core::ffi::c_void,
            size: *mut usize,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuGetExportTable: Result<
        unsafe extern "C" fn(
            ppExportTable: *mut *const ::core::ffi::c_void,
            pExportTableId: *const CUuuid,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuProfilerInitialize: Result<
        unsafe extern "C" fn(
            configFile: *const ::core::ffi::c_char,
            outputFile: *const ::core::ffi::c_char,
            outputMode: CUoutput_mode,
        ) -> CUresult,
        ::libloading::Error,
    >,
    pub cuProfilerStart: Result<unsafe extern "C" fn() -> CUresult, ::libloading::Error>,
    pub cuProfilerStop: Result<unsafe extern "C" fn() -> CUresult, ::libloading::Error>,
}
impl Lib {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let cuGetErrorString = __library.get(b"cuGetErrorString\0").map(|sym| *sym);
        let cuGetErrorName = __library.get(b"cuGetErrorName\0").map(|sym| *sym);
        let cuInit = __library.get(b"cuInit\0").map(|sym| *sym);
        let cuDriverGetVersion = __library.get(b"cuDriverGetVersion\0").map(|sym| *sym);
        let cuDeviceGet = __library.get(b"cuDeviceGet\0").map(|sym| *sym);
        let cuDeviceGetCount = __library.get(b"cuDeviceGetCount\0").map(|sym| *sym);
        let cuDeviceGetName = __library.get(b"cuDeviceGetName\0").map(|sym| *sym);
        let cuDeviceGetUuid = __library.get(b"cuDeviceGetUuid\0").map(|sym| *sym);
        let cuDeviceGetUuid_v2 = __library.get(b"cuDeviceGetUuid_v2\0").map(|sym| *sym);
        let cuDeviceGetLuid = __library.get(b"cuDeviceGetLuid\0").map(|sym| *sym);
        let cuDeviceTotalMem_v2 = __library.get(b"cuDeviceTotalMem_v2\0").map(|sym| *sym);
        let cuDeviceGetTexture1DLinearMaxWidth = __library
            .get(b"cuDeviceGetTexture1DLinearMaxWidth\0")
            .map(|sym| *sym);
        let cuDeviceGetAttribute = __library.get(b"cuDeviceGetAttribute\0").map(|sym| *sym);
        let cuDeviceGetNvSciSyncAttributes = __library
            .get(b"cuDeviceGetNvSciSyncAttributes\0")
            .map(|sym| *sym);
        let cuDeviceSetMemPool = __library.get(b"cuDeviceSetMemPool\0").map(|sym| *sym);
        let cuDeviceGetMemPool = __library.get(b"cuDeviceGetMemPool\0").map(|sym| *sym);
        let cuDeviceGetDefaultMemPool = __library
            .get(b"cuDeviceGetDefaultMemPool\0")
            .map(|sym| *sym);
        let cuDeviceGetExecAffinitySupport = __library
            .get(b"cuDeviceGetExecAffinitySupport\0")
            .map(|sym| *sym);
        let cuFlushGPUDirectRDMAWrites = __library
            .get(b"cuFlushGPUDirectRDMAWrites\0")
            .map(|sym| *sym);
        let cuDeviceGetProperties = __library.get(b"cuDeviceGetProperties\0").map(|sym| *sym);
        let cuDeviceComputeCapability = __library
            .get(b"cuDeviceComputeCapability\0")
            .map(|sym| *sym);
        let cuDevicePrimaryCtxRetain = __library.get(b"cuDevicePrimaryCtxRetain\0").map(|sym| *sym);
        let cuDevicePrimaryCtxRelease_v2 = __library
            .get(b"cuDevicePrimaryCtxRelease_v2\0")
            .map(|sym| *sym);
        let cuDevicePrimaryCtxSetFlags_v2 = __library
            .get(b"cuDevicePrimaryCtxSetFlags_v2\0")
            .map(|sym| *sym);
        let cuDevicePrimaryCtxGetState = __library
            .get(b"cuDevicePrimaryCtxGetState\0")
            .map(|sym| *sym);
        let cuDevicePrimaryCtxReset_v2 = __library
            .get(b"cuDevicePrimaryCtxReset_v2\0")
            .map(|sym| *sym);
        let cuCtxCreate_v2 = __library.get(b"cuCtxCreate_v2\0").map(|sym| *sym);
        let cuCtxCreate_v3 = __library.get(b"cuCtxCreate_v3\0").map(|sym| *sym);
        let cuCtxDestroy_v2 = __library.get(b"cuCtxDestroy_v2\0").map(|sym| *sym);
        let cuCtxPushCurrent_v2 = __library.get(b"cuCtxPushCurrent_v2\0").map(|sym| *sym);
        let cuCtxPopCurrent_v2 = __library.get(b"cuCtxPopCurrent_v2\0").map(|sym| *sym);
        let cuCtxSetCurrent = __library.get(b"cuCtxSetCurrent\0").map(|sym| *sym);
        let cuCtxGetCurrent = __library.get(b"cuCtxGetCurrent\0").map(|sym| *sym);
        let cuCtxGetDevice = __library.get(b"cuCtxGetDevice\0").map(|sym| *sym);
        let cuCtxGetFlags = __library.get(b"cuCtxGetFlags\0").map(|sym| *sym);
        let cuCtxSetFlags = __library.get(b"cuCtxSetFlags\0").map(|sym| *sym);
        let cuCtxGetId = __library.get(b"cuCtxGetId\0").map(|sym| *sym);
        let cuCtxSynchronize = __library.get(b"cuCtxSynchronize\0").map(|sym| *sym);
        let cuCtxSetLimit = __library.get(b"cuCtxSetLimit\0").map(|sym| *sym);
        let cuCtxGetLimit = __library.get(b"cuCtxGetLimit\0").map(|sym| *sym);
        let cuCtxGetCacheConfig = __library.get(b"cuCtxGetCacheConfig\0").map(|sym| *sym);
        let cuCtxSetCacheConfig = __library.get(b"cuCtxSetCacheConfig\0").map(|sym| *sym);
        let cuCtxGetSharedMemConfig = __library.get(b"cuCtxGetSharedMemConfig\0").map(|sym| *sym);
        let cuCtxSetSharedMemConfig = __library.get(b"cuCtxSetSharedMemConfig\0").map(|sym| *sym);
        let cuCtxGetApiVersion = __library.get(b"cuCtxGetApiVersion\0").map(|sym| *sym);
        let cuCtxGetStreamPriorityRange = __library
            .get(b"cuCtxGetStreamPriorityRange\0")
            .map(|sym| *sym);
        let cuCtxResetPersistingL2Cache = __library
            .get(b"cuCtxResetPersistingL2Cache\0")
            .map(|sym| *sym);
        let cuCtxGetExecAffinity = __library.get(b"cuCtxGetExecAffinity\0").map(|sym| *sym);
        let cuCtxAttach = __library.get(b"cuCtxAttach\0").map(|sym| *sym);
        let cuCtxDetach = __library.get(b"cuCtxDetach\0").map(|sym| *sym);
        let cuModuleLoad = __library.get(b"cuModuleLoad\0").map(|sym| *sym);
        let cuModuleLoadData = __library.get(b"cuModuleLoadData\0").map(|sym| *sym);
        let cuModuleLoadDataEx = __library.get(b"cuModuleLoadDataEx\0").map(|sym| *sym);
        let cuModuleLoadFatBinary = __library.get(b"cuModuleLoadFatBinary\0").map(|sym| *sym);
        let cuModuleUnload = __library.get(b"cuModuleUnload\0").map(|sym| *sym);
        let cuModuleGetLoadingMode = __library.get(b"cuModuleGetLoadingMode\0").map(|sym| *sym);
        let cuModuleGetFunction = __library.get(b"cuModuleGetFunction\0").map(|sym| *sym);
        let cuModuleGetGlobal_v2 = __library.get(b"cuModuleGetGlobal_v2\0").map(|sym| *sym);
        let cuLinkCreate_v2 = __library.get(b"cuLinkCreate_v2\0").map(|sym| *sym);
        let cuLinkAddData_v2 = __library.get(b"cuLinkAddData_v2\0").map(|sym| *sym);
        let cuLinkAddFile_v2 = __library.get(b"cuLinkAddFile_v2\0").map(|sym| *sym);
        let cuLinkComplete = __library.get(b"cuLinkComplete\0").map(|sym| *sym);
        let cuLinkDestroy = __library.get(b"cuLinkDestroy\0").map(|sym| *sym);
        let cuModuleGetTexRef = __library.get(b"cuModuleGetTexRef\0").map(|sym| *sym);
        let cuModuleGetSurfRef = __library.get(b"cuModuleGetSurfRef\0").map(|sym| *sym);
        let cuLibraryLoadData = __library.get(b"cuLibraryLoadData\0").map(|sym| *sym);
        let cuLibraryLoadFromFile = __library.get(b"cuLibraryLoadFromFile\0").map(|sym| *sym);
        let cuLibraryUnload = __library.get(b"cuLibraryUnload\0").map(|sym| *sym);
        let cuLibraryGetKernel = __library.get(b"cuLibraryGetKernel\0").map(|sym| *sym);
        let cuLibraryGetModule = __library.get(b"cuLibraryGetModule\0").map(|sym| *sym);
        let cuKernelGetFunction = __library.get(b"cuKernelGetFunction\0").map(|sym| *sym);
        let cuLibraryGetGlobal = __library.get(b"cuLibraryGetGlobal\0").map(|sym| *sym);
        let cuLibraryGetManaged = __library.get(b"cuLibraryGetManaged\0").map(|sym| *sym);
        let cuLibraryGetUnifiedFunction = __library
            .get(b"cuLibraryGetUnifiedFunction\0")
            .map(|sym| *sym);
        let cuKernelGetAttribute = __library.get(b"cuKernelGetAttribute\0").map(|sym| *sym);
        let cuKernelSetAttribute = __library.get(b"cuKernelSetAttribute\0").map(|sym| *sym);
        let cuKernelSetCacheConfig = __library.get(b"cuKernelSetCacheConfig\0").map(|sym| *sym);
        let cuKernelGetName = __library.get(b"cuKernelGetName\0").map(|sym| *sym);
        let cuMemGetInfo_v2 = __library.get(b"cuMemGetInfo_v2\0").map(|sym| *sym);
        let cuMemAlloc_v2 = __library.get(b"cuMemAlloc_v2\0").map(|sym| *sym);
        let cuMemAllocPitch_v2 = __library.get(b"cuMemAllocPitch_v2\0").map(|sym| *sym);
        let cuMemFree_v2 = __library.get(b"cuMemFree_v2\0").map(|sym| *sym);
        let cuMemGetAddressRange_v2 = __library.get(b"cuMemGetAddressRange_v2\0").map(|sym| *sym);
        let cuMemAllocHost_v2 = __library.get(b"cuMemAllocHost_v2\0").map(|sym| *sym);
        let cuMemFreeHost = __library.get(b"cuMemFreeHost\0").map(|sym| *sym);
        let cuMemHostAlloc = __library.get(b"cuMemHostAlloc\0").map(|sym| *sym);
        let cuMemHostGetDevicePointer_v2 = __library
            .get(b"cuMemHostGetDevicePointer_v2\0")
            .map(|sym| *sym);
        let cuMemHostGetFlags = __library.get(b"cuMemHostGetFlags\0").map(|sym| *sym);
        let cuMemAllocManaged = __library.get(b"cuMemAllocManaged\0").map(|sym| *sym);
        let cuDeviceGetByPCIBusId = __library.get(b"cuDeviceGetByPCIBusId\0").map(|sym| *sym);
        let cuDeviceGetPCIBusId = __library.get(b"cuDeviceGetPCIBusId\0").map(|sym| *sym);
        let cuIpcGetEventHandle = __library.get(b"cuIpcGetEventHandle\0").map(|sym| *sym);
        let cuIpcOpenEventHandle = __library.get(b"cuIpcOpenEventHandle\0").map(|sym| *sym);
        let cuIpcGetMemHandle = __library.get(b"cuIpcGetMemHandle\0").map(|sym| *sym);
        let cuIpcOpenMemHandle_v2 = __library.get(b"cuIpcOpenMemHandle_v2\0").map(|sym| *sym);
        let cuIpcCloseMemHandle = __library.get(b"cuIpcCloseMemHandle\0").map(|sym| *sym);
        let cuMemHostRegister_v2 = __library.get(b"cuMemHostRegister_v2\0").map(|sym| *sym);
        let cuMemHostUnregister = __library.get(b"cuMemHostUnregister\0").map(|sym| *sym);
        let cuMemcpy = __library.get(b"cuMemcpy\0").map(|sym| *sym);
        let cuMemcpyPeer = __library.get(b"cuMemcpyPeer\0").map(|sym| *sym);
        let cuMemcpyHtoD_v2 = __library.get(b"cuMemcpyHtoD_v2\0").map(|sym| *sym);
        let cuMemcpyDtoH_v2 = __library.get(b"cuMemcpyDtoH_v2\0").map(|sym| *sym);
        let cuMemcpyDtoD_v2 = __library.get(b"cuMemcpyDtoD_v2\0").map(|sym| *sym);
        let cuMemcpyDtoA_v2 = __library.get(b"cuMemcpyDtoA_v2\0").map(|sym| *sym);
        let cuMemcpyAtoD_v2 = __library.get(b"cuMemcpyAtoD_v2\0").map(|sym| *sym);
        let cuMemcpyHtoA_v2 = __library.get(b"cuMemcpyHtoA_v2\0").map(|sym| *sym);
        let cuMemcpyAtoH_v2 = __library.get(b"cuMemcpyAtoH_v2\0").map(|sym| *sym);
        let cuMemcpyAtoA_v2 = __library.get(b"cuMemcpyAtoA_v2\0").map(|sym| *sym);
        let cuMemcpy2D_v2 = __library.get(b"cuMemcpy2D_v2\0").map(|sym| *sym);
        let cuMemcpy2DUnaligned_v2 = __library.get(b"cuMemcpy2DUnaligned_v2\0").map(|sym| *sym);
        let cuMemcpy3D_v2 = __library.get(b"cuMemcpy3D_v2\0").map(|sym| *sym);
        let cuMemcpy3DPeer = __library.get(b"cuMemcpy3DPeer\0").map(|sym| *sym);
        let cuMemcpyAsync = __library.get(b"cuMemcpyAsync\0").map(|sym| *sym);
        let cuMemcpyPeerAsync = __library.get(b"cuMemcpyPeerAsync\0").map(|sym| *sym);
        let cuMemcpyHtoDAsync_v2 = __library.get(b"cuMemcpyHtoDAsync_v2\0").map(|sym| *sym);
        let cuMemcpyDtoHAsync_v2 = __library.get(b"cuMemcpyDtoHAsync_v2\0").map(|sym| *sym);
        let cuMemcpyDtoDAsync_v2 = __library.get(b"cuMemcpyDtoDAsync_v2\0").map(|sym| *sym);
        let cuMemcpyHtoAAsync_v2 = __library.get(b"cuMemcpyHtoAAsync_v2\0").map(|sym| *sym);
        let cuMemcpyAtoHAsync_v2 = __library.get(b"cuMemcpyAtoHAsync_v2\0").map(|sym| *sym);
        let cuMemcpy2DAsync_v2 = __library.get(b"cuMemcpy2DAsync_v2\0").map(|sym| *sym);
        let cuMemcpy3DAsync_v2 = __library.get(b"cuMemcpy3DAsync_v2\0").map(|sym| *sym);
        let cuMemcpy3DPeerAsync = __library.get(b"cuMemcpy3DPeerAsync\0").map(|sym| *sym);
        let cuMemsetD8_v2 = __library.get(b"cuMemsetD8_v2\0").map(|sym| *sym);
        let cuMemsetD16_v2 = __library.get(b"cuMemsetD16_v2\0").map(|sym| *sym);
        let cuMemsetD32_v2 = __library.get(b"cuMemsetD32_v2\0").map(|sym| *sym);
        let cuMemsetD2D8_v2 = __library.get(b"cuMemsetD2D8_v2\0").map(|sym| *sym);
        let cuMemsetD2D16_v2 = __library.get(b"cuMemsetD2D16_v2\0").map(|sym| *sym);
        let cuMemsetD2D32_v2 = __library.get(b"cuMemsetD2D32_v2\0").map(|sym| *sym);
        let cuMemsetD8Async = __library.get(b"cuMemsetD8Async\0").map(|sym| *sym);
        let cuMemsetD16Async = __library.get(b"cuMemsetD16Async\0").map(|sym| *sym);
        let cuMemsetD32Async = __library.get(b"cuMemsetD32Async\0").map(|sym| *sym);
        let cuMemsetD2D8Async = __library.get(b"cuMemsetD2D8Async\0").map(|sym| *sym);
        let cuMemsetD2D16Async = __library.get(b"cuMemsetD2D16Async\0").map(|sym| *sym);
        let cuMemsetD2D32Async = __library.get(b"cuMemsetD2D32Async\0").map(|sym| *sym);
        let cuArrayCreate_v2 = __library.get(b"cuArrayCreate_v2\0").map(|sym| *sym);
        let cuArrayGetDescriptor_v2 = __library.get(b"cuArrayGetDescriptor_v2\0").map(|sym| *sym);
        let cuArrayGetSparseProperties = __library
            .get(b"cuArrayGetSparseProperties\0")
            .map(|sym| *sym);
        let cuMipmappedArrayGetSparseProperties = __library
            .get(b"cuMipmappedArrayGetSparseProperties\0")
            .map(|sym| *sym);
        let cuArrayGetMemoryRequirements = __library
            .get(b"cuArrayGetMemoryRequirements\0")
            .map(|sym| *sym);
        let cuMipmappedArrayGetMemoryRequirements = __library
            .get(b"cuMipmappedArrayGetMemoryRequirements\0")
            .map(|sym| *sym);
        let cuArrayGetPlane = __library.get(b"cuArrayGetPlane\0").map(|sym| *sym);
        let cuArrayDestroy = __library.get(b"cuArrayDestroy\0").map(|sym| *sym);
        let cuArray3DCreate_v2 = __library.get(b"cuArray3DCreate_v2\0").map(|sym| *sym);
        let cuArray3DGetDescriptor_v2 = __library
            .get(b"cuArray3DGetDescriptor_v2\0")
            .map(|sym| *sym);
        let cuMipmappedArrayCreate = __library.get(b"cuMipmappedArrayCreate\0").map(|sym| *sym);
        let cuMipmappedArrayGetLevel = __library.get(b"cuMipmappedArrayGetLevel\0").map(|sym| *sym);
        let cuMipmappedArrayDestroy = __library.get(b"cuMipmappedArrayDestroy\0").map(|sym| *sym);
        let cuMemGetHandleForAddressRange = __library
            .get(b"cuMemGetHandleForAddressRange\0")
            .map(|sym| *sym);
        let cuMemAddressReserve = __library.get(b"cuMemAddressReserve\0").map(|sym| *sym);
        let cuMemAddressFree = __library.get(b"cuMemAddressFree\0").map(|sym| *sym);
        let cuMemCreate = __library.get(b"cuMemCreate\0").map(|sym| *sym);
        let cuMemRelease = __library.get(b"cuMemRelease\0").map(|sym| *sym);
        let cuMemMap = __library.get(b"cuMemMap\0").map(|sym| *sym);
        let cuMemMapArrayAsync = __library.get(b"cuMemMapArrayAsync\0").map(|sym| *sym);
        let cuMemUnmap = __library.get(b"cuMemUnmap\0").map(|sym| *sym);
        let cuMemSetAccess = __library.get(b"cuMemSetAccess\0").map(|sym| *sym);
        let cuMemGetAccess = __library.get(b"cuMemGetAccess\0").map(|sym| *sym);
        let cuMemExportToShareableHandle = __library
            .get(b"cuMemExportToShareableHandle\0")
            .map(|sym| *sym);
        let cuMemImportFromShareableHandle = __library
            .get(b"cuMemImportFromShareableHandle\0")
            .map(|sym| *sym);
        let cuMemGetAllocationGranularity = __library
            .get(b"cuMemGetAllocationGranularity\0")
            .map(|sym| *sym);
        let cuMemGetAllocationPropertiesFromHandle = __library
            .get(b"cuMemGetAllocationPropertiesFromHandle\0")
            .map(|sym| *sym);
        let cuMemRetainAllocationHandle = __library
            .get(b"cuMemRetainAllocationHandle\0")
            .map(|sym| *sym);
        let cuMemFreeAsync = __library.get(b"cuMemFreeAsync\0").map(|sym| *sym);
        let cuMemAllocAsync = __library.get(b"cuMemAllocAsync\0").map(|sym| *sym);
        let cuMemPoolTrimTo = __library.get(b"cuMemPoolTrimTo\0").map(|sym| *sym);
        let cuMemPoolSetAttribute = __library.get(b"cuMemPoolSetAttribute\0").map(|sym| *sym);
        let cuMemPoolGetAttribute = __library.get(b"cuMemPoolGetAttribute\0").map(|sym| *sym);
        let cuMemPoolSetAccess = __library.get(b"cuMemPoolSetAccess\0").map(|sym| *sym);
        let cuMemPoolGetAccess = __library.get(b"cuMemPoolGetAccess\0").map(|sym| *sym);
        let cuMemPoolCreate = __library.get(b"cuMemPoolCreate\0").map(|sym| *sym);
        let cuMemPoolDestroy = __library.get(b"cuMemPoolDestroy\0").map(|sym| *sym);
        let cuMemAllocFromPoolAsync = __library.get(b"cuMemAllocFromPoolAsync\0").map(|sym| *sym);
        let cuMemPoolExportToShareableHandle = __library
            .get(b"cuMemPoolExportToShareableHandle\0")
            .map(|sym| *sym);
        let cuMemPoolImportFromShareableHandle = __library
            .get(b"cuMemPoolImportFromShareableHandle\0")
            .map(|sym| *sym);
        let cuMemPoolExportPointer = __library.get(b"cuMemPoolExportPointer\0").map(|sym| *sym);
        let cuMemPoolImportPointer = __library.get(b"cuMemPoolImportPointer\0").map(|sym| *sym);
        let cuMulticastCreate = __library.get(b"cuMulticastCreate\0").map(|sym| *sym);
        let cuMulticastAddDevice = __library.get(b"cuMulticastAddDevice\0").map(|sym| *sym);
        let cuMulticastBindMem = __library.get(b"cuMulticastBindMem\0").map(|sym| *sym);
        let cuMulticastBindAddr = __library.get(b"cuMulticastBindAddr\0").map(|sym| *sym);
        let cuMulticastUnbind = __library.get(b"cuMulticastUnbind\0").map(|sym| *sym);
        let cuMulticastGetGranularity = __library
            .get(b"cuMulticastGetGranularity\0")
            .map(|sym| *sym);
        let cuPointerGetAttribute = __library.get(b"cuPointerGetAttribute\0").map(|sym| *sym);
        let cuMemPrefetchAsync = __library.get(b"cuMemPrefetchAsync\0").map(|sym| *sym);
        let cuMemPrefetchAsync_v2 = __library.get(b"cuMemPrefetchAsync_v2\0").map(|sym| *sym);
        let cuMemAdvise = __library.get(b"cuMemAdvise\0").map(|sym| *sym);
        let cuMemAdvise_v2 = __library.get(b"cuMemAdvise_v2\0").map(|sym| *sym);
        let cuMemRangeGetAttribute = __library.get(b"cuMemRangeGetAttribute\0").map(|sym| *sym);
        let cuMemRangeGetAttributes = __library.get(b"cuMemRangeGetAttributes\0").map(|sym| *sym);
        let cuPointerSetAttribute = __library.get(b"cuPointerSetAttribute\0").map(|sym| *sym);
        let cuPointerGetAttributes = __library.get(b"cuPointerGetAttributes\0").map(|sym| *sym);
        let cuStreamCreate = __library.get(b"cuStreamCreate\0").map(|sym| *sym);
        let cuStreamCreateWithPriority = __library
            .get(b"cuStreamCreateWithPriority\0")
            .map(|sym| *sym);
        let cuStreamGetPriority = __library.get(b"cuStreamGetPriority\0").map(|sym| *sym);
        let cuStreamGetFlags = __library.get(b"cuStreamGetFlags\0").map(|sym| *sym);
        let cuStreamGetId = __library.get(b"cuStreamGetId\0").map(|sym| *sym);
        let cuStreamGetCtx = __library.get(b"cuStreamGetCtx\0").map(|sym| *sym);
        let cuStreamWaitEvent = __library.get(b"cuStreamWaitEvent\0").map(|sym| *sym);
        let cuStreamAddCallback = __library.get(b"cuStreamAddCallback\0").map(|sym| *sym);
        let cuStreamBeginCapture_v2 = __library.get(b"cuStreamBeginCapture_v2\0").map(|sym| *sym);
        let cuStreamBeginCaptureToGraph = __library
            .get(b"cuStreamBeginCaptureToGraph\0")
            .map(|sym| *sym);
        let cuThreadExchangeStreamCaptureMode = __library
            .get(b"cuThreadExchangeStreamCaptureMode\0")
            .map(|sym| *sym);
        let cuStreamEndCapture = __library.get(b"cuStreamEndCapture\0").map(|sym| *sym);
        let cuStreamIsCapturing = __library.get(b"cuStreamIsCapturing\0").map(|sym| *sym);
        let cuStreamGetCaptureInfo_v2 = __library
            .get(b"cuStreamGetCaptureInfo_v2\0")
            .map(|sym| *sym);
        let cuStreamGetCaptureInfo_v3 = __library
            .get(b"cuStreamGetCaptureInfo_v3\0")
            .map(|sym| *sym);
        let cuStreamUpdateCaptureDependencies = __library
            .get(b"cuStreamUpdateCaptureDependencies\0")
            .map(|sym| *sym);
        let cuStreamUpdateCaptureDependencies_v2 = __library
            .get(b"cuStreamUpdateCaptureDependencies_v2\0")
            .map(|sym| *sym);
        let cuStreamAttachMemAsync = __library.get(b"cuStreamAttachMemAsync\0").map(|sym| *sym);
        let cuStreamQuery = __library.get(b"cuStreamQuery\0").map(|sym| *sym);
        let cuStreamSynchronize = __library.get(b"cuStreamSynchronize\0").map(|sym| *sym);
        let cuStreamDestroy_v2 = __library.get(b"cuStreamDestroy_v2\0").map(|sym| *sym);
        let cuStreamCopyAttributes = __library.get(b"cuStreamCopyAttributes\0").map(|sym| *sym);
        let cuStreamGetAttribute = __library.get(b"cuStreamGetAttribute\0").map(|sym| *sym);
        let cuStreamSetAttribute = __library.get(b"cuStreamSetAttribute\0").map(|sym| *sym);
        let cuEventCreate = __library.get(b"cuEventCreate\0").map(|sym| *sym);
        let cuEventRecord = __library.get(b"cuEventRecord\0").map(|sym| *sym);
        let cuEventRecordWithFlags = __library.get(b"cuEventRecordWithFlags\0").map(|sym| *sym);
        let cuEventQuery = __library.get(b"cuEventQuery\0").map(|sym| *sym);
        let cuEventSynchronize = __library.get(b"cuEventSynchronize\0").map(|sym| *sym);
        let cuEventDestroy_v2 = __library.get(b"cuEventDestroy_v2\0").map(|sym| *sym);
        let cuEventElapsedTime = __library.get(b"cuEventElapsedTime\0").map(|sym| *sym);
        let cuImportExternalMemory = __library.get(b"cuImportExternalMemory\0").map(|sym| *sym);
        let cuExternalMemoryGetMappedBuffer = __library
            .get(b"cuExternalMemoryGetMappedBuffer\0")
            .map(|sym| *sym);
        let cuExternalMemoryGetMappedMipmappedArray = __library
            .get(b"cuExternalMemoryGetMappedMipmappedArray\0")
            .map(|sym| *sym);
        let cuDestroyExternalMemory = __library.get(b"cuDestroyExternalMemory\0").map(|sym| *sym);
        let cuImportExternalSemaphore = __library
            .get(b"cuImportExternalSemaphore\0")
            .map(|sym| *sym);
        let cuSignalExternalSemaphoresAsync = __library
            .get(b"cuSignalExternalSemaphoresAsync\0")
            .map(|sym| *sym);
        let cuWaitExternalSemaphoresAsync = __library
            .get(b"cuWaitExternalSemaphoresAsync\0")
            .map(|sym| *sym);
        let cuDestroyExternalSemaphore = __library
            .get(b"cuDestroyExternalSemaphore\0")
            .map(|sym| *sym);
        let cuStreamWaitValue32_v2 = __library.get(b"cuStreamWaitValue32_v2\0").map(|sym| *sym);
        let cuStreamWaitValue64_v2 = __library.get(b"cuStreamWaitValue64_v2\0").map(|sym| *sym);
        let cuStreamWriteValue32_v2 = __library.get(b"cuStreamWriteValue32_v2\0").map(|sym| *sym);
        let cuStreamWriteValue64_v2 = __library.get(b"cuStreamWriteValue64_v2\0").map(|sym| *sym);
        let cuStreamBatchMemOp_v2 = __library.get(b"cuStreamBatchMemOp_v2\0").map(|sym| *sym);
        let cuFuncGetAttribute = __library.get(b"cuFuncGetAttribute\0").map(|sym| *sym);
        let cuFuncSetAttribute = __library.get(b"cuFuncSetAttribute\0").map(|sym| *sym);
        let cuFuncSetCacheConfig = __library.get(b"cuFuncSetCacheConfig\0").map(|sym| *sym);
        let cuFuncSetSharedMemConfig = __library.get(b"cuFuncSetSharedMemConfig\0").map(|sym| *sym);
        let cuFuncGetModule = __library.get(b"cuFuncGetModule\0").map(|sym| *sym);
        let cuFuncGetName = __library.get(b"cuFuncGetName\0").map(|sym| *sym);
        let cuLaunchKernel = __library.get(b"cuLaunchKernel\0").map(|sym| *sym);
        let cuLaunchKernelEx = __library.get(b"cuLaunchKernelEx\0").map(|sym| *sym);
        let cuLaunchCooperativeKernel = __library
            .get(b"cuLaunchCooperativeKernel\0")
            .map(|sym| *sym);
        let cuLaunchCooperativeKernelMultiDevice = __library
            .get(b"cuLaunchCooperativeKernelMultiDevice\0")
            .map(|sym| *sym);
        let cuLaunchHostFunc = __library.get(b"cuLaunchHostFunc\0").map(|sym| *sym);
        let cuFuncSetBlockShape = __library.get(b"cuFuncSetBlockShape\0").map(|sym| *sym);
        let cuFuncSetSharedSize = __library.get(b"cuFuncSetSharedSize\0").map(|sym| *sym);
        let cuParamSetSize = __library.get(b"cuParamSetSize\0").map(|sym| *sym);
        let cuParamSeti = __library.get(b"cuParamSeti\0").map(|sym| *sym);
        let cuParamSetf = __library.get(b"cuParamSetf\0").map(|sym| *sym);
        let cuParamSetv = __library.get(b"cuParamSetv\0").map(|sym| *sym);
        let cuLaunch = __library.get(b"cuLaunch\0").map(|sym| *sym);
        let cuLaunchGrid = __library.get(b"cuLaunchGrid\0").map(|sym| *sym);
        let cuLaunchGridAsync = __library.get(b"cuLaunchGridAsync\0").map(|sym| *sym);
        let cuParamSetTexRef = __library.get(b"cuParamSetTexRef\0").map(|sym| *sym);
        let cuGraphCreate = __library.get(b"cuGraphCreate\0").map(|sym| *sym);
        let cuGraphAddKernelNode_v2 = __library.get(b"cuGraphAddKernelNode_v2\0").map(|sym| *sym);
        let cuGraphKernelNodeGetParams_v2 = __library
            .get(b"cuGraphKernelNodeGetParams_v2\0")
            .map(|sym| *sym);
        let cuGraphKernelNodeSetParams_v2 = __library
            .get(b"cuGraphKernelNodeSetParams_v2\0")
            .map(|sym| *sym);
        let cuGraphAddMemcpyNode = __library.get(b"cuGraphAddMemcpyNode\0").map(|sym| *sym);
        let cuGraphMemcpyNodeGetParams = __library
            .get(b"cuGraphMemcpyNodeGetParams\0")
            .map(|sym| *sym);
        let cuGraphMemcpyNodeSetParams = __library
            .get(b"cuGraphMemcpyNodeSetParams\0")
            .map(|sym| *sym);
        let cuGraphAddMemsetNode = __library.get(b"cuGraphAddMemsetNode\0").map(|sym| *sym);
        let cuGraphMemsetNodeGetParams = __library
            .get(b"cuGraphMemsetNodeGetParams\0")
            .map(|sym| *sym);
        let cuGraphMemsetNodeSetParams = __library
            .get(b"cuGraphMemsetNodeSetParams\0")
            .map(|sym| *sym);
        let cuGraphAddHostNode = __library.get(b"cuGraphAddHostNode\0").map(|sym| *sym);
        let cuGraphHostNodeGetParams = __library.get(b"cuGraphHostNodeGetParams\0").map(|sym| *sym);
        let cuGraphHostNodeSetParams = __library.get(b"cuGraphHostNodeSetParams\0").map(|sym| *sym);
        let cuGraphAddChildGraphNode = __library.get(b"cuGraphAddChildGraphNode\0").map(|sym| *sym);
        let cuGraphChildGraphNodeGetGraph = __library
            .get(b"cuGraphChildGraphNodeGetGraph\0")
            .map(|sym| *sym);
        let cuGraphAddEmptyNode = __library.get(b"cuGraphAddEmptyNode\0").map(|sym| *sym);
        let cuGraphAddEventRecordNode = __library
            .get(b"cuGraphAddEventRecordNode\0")
            .map(|sym| *sym);
        let cuGraphEventRecordNodeGetEvent = __library
            .get(b"cuGraphEventRecordNodeGetEvent\0")
            .map(|sym| *sym);
        let cuGraphEventRecordNodeSetEvent = __library
            .get(b"cuGraphEventRecordNodeSetEvent\0")
            .map(|sym| *sym);
        let cuGraphAddEventWaitNode = __library.get(b"cuGraphAddEventWaitNode\0").map(|sym| *sym);
        let cuGraphEventWaitNodeGetEvent = __library
            .get(b"cuGraphEventWaitNodeGetEvent\0")
            .map(|sym| *sym);
        let cuGraphEventWaitNodeSetEvent = __library
            .get(b"cuGraphEventWaitNodeSetEvent\0")
            .map(|sym| *sym);
        let cuGraphAddExternalSemaphoresSignalNode = __library
            .get(b"cuGraphAddExternalSemaphoresSignalNode\0")
            .map(|sym| *sym);
        let cuGraphExternalSemaphoresSignalNodeGetParams = __library
            .get(b"cuGraphExternalSemaphoresSignalNodeGetParams\0")
            .map(|sym| *sym);
        let cuGraphExternalSemaphoresSignalNodeSetParams = __library
            .get(b"cuGraphExternalSemaphoresSignalNodeSetParams\0")
            .map(|sym| *sym);
        let cuGraphAddExternalSemaphoresWaitNode = __library
            .get(b"cuGraphAddExternalSemaphoresWaitNode\0")
            .map(|sym| *sym);
        let cuGraphExternalSemaphoresWaitNodeGetParams = __library
            .get(b"cuGraphExternalSemaphoresWaitNodeGetParams\0")
            .map(|sym| *sym);
        let cuGraphExternalSemaphoresWaitNodeSetParams = __library
            .get(b"cuGraphExternalSemaphoresWaitNodeSetParams\0")
            .map(|sym| *sym);
        let cuGraphAddBatchMemOpNode = __library.get(b"cuGraphAddBatchMemOpNode\0").map(|sym| *sym);
        let cuGraphBatchMemOpNodeGetParams = __library
            .get(b"cuGraphBatchMemOpNodeGetParams\0")
            .map(|sym| *sym);
        let cuGraphBatchMemOpNodeSetParams = __library
            .get(b"cuGraphBatchMemOpNodeSetParams\0")
            .map(|sym| *sym);
        let cuGraphExecBatchMemOpNodeSetParams = __library
            .get(b"cuGraphExecBatchMemOpNodeSetParams\0")
            .map(|sym| *sym);
        let cuGraphAddMemAllocNode = __library.get(b"cuGraphAddMemAllocNode\0").map(|sym| *sym);
        let cuGraphMemAllocNodeGetParams = __library
            .get(b"cuGraphMemAllocNodeGetParams\0")
            .map(|sym| *sym);
        let cuGraphAddMemFreeNode = __library.get(b"cuGraphAddMemFreeNode\0").map(|sym| *sym);
        let cuGraphMemFreeNodeGetParams = __library
            .get(b"cuGraphMemFreeNodeGetParams\0")
            .map(|sym| *sym);
        let cuDeviceGraphMemTrim = __library.get(b"cuDeviceGraphMemTrim\0").map(|sym| *sym);
        let cuDeviceGetGraphMemAttribute = __library
            .get(b"cuDeviceGetGraphMemAttribute\0")
            .map(|sym| *sym);
        let cuDeviceSetGraphMemAttribute = __library
            .get(b"cuDeviceSetGraphMemAttribute\0")
            .map(|sym| *sym);
        let cuGraphClone = __library.get(b"cuGraphClone\0").map(|sym| *sym);
        let cuGraphNodeFindInClone = __library.get(b"cuGraphNodeFindInClone\0").map(|sym| *sym);
        let cuGraphNodeGetType = __library.get(b"cuGraphNodeGetType\0").map(|sym| *sym);
        let cuGraphGetNodes = __library.get(b"cuGraphGetNodes\0").map(|sym| *sym);
        let cuGraphGetRootNodes = __library.get(b"cuGraphGetRootNodes\0").map(|sym| *sym);
        let cuGraphGetEdges = __library.get(b"cuGraphGetEdges\0").map(|sym| *sym);
        let cuGraphGetEdges_v2 = __library.get(b"cuGraphGetEdges_v2\0").map(|sym| *sym);
        let cuGraphNodeGetDependencies = __library
            .get(b"cuGraphNodeGetDependencies\0")
            .map(|sym| *sym);
        let cuGraphNodeGetDependencies_v2 = __library
            .get(b"cuGraphNodeGetDependencies_v2\0")
            .map(|sym| *sym);
        let cuGraphNodeGetDependentNodes = __library
            .get(b"cuGraphNodeGetDependentNodes\0")
            .map(|sym| *sym);
        let cuGraphNodeGetDependentNodes_v2 = __library
            .get(b"cuGraphNodeGetDependentNodes_v2\0")
            .map(|sym| *sym);
        let cuGraphAddDependencies = __library.get(b"cuGraphAddDependencies\0").map(|sym| *sym);
        let cuGraphAddDependencies_v2 = __library
            .get(b"cuGraphAddDependencies_v2\0")
            .map(|sym| *sym);
        let cuGraphRemoveDependencies = __library
            .get(b"cuGraphRemoveDependencies\0")
            .map(|sym| *sym);
        let cuGraphRemoveDependencies_v2 = __library
            .get(b"cuGraphRemoveDependencies_v2\0")
            .map(|sym| *sym);
        let cuGraphDestroyNode = __library.get(b"cuGraphDestroyNode\0").map(|sym| *sym);
        let cuGraphInstantiateWithFlags = __library
            .get(b"cuGraphInstantiateWithFlags\0")
            .map(|sym| *sym);
        let cuGraphInstantiateWithParams = __library
            .get(b"cuGraphInstantiateWithParams\0")
            .map(|sym| *sym);
        let cuGraphExecGetFlags = __library.get(b"cuGraphExecGetFlags\0").map(|sym| *sym);
        let cuGraphExecKernelNodeSetParams_v2 = __library
            .get(b"cuGraphExecKernelNodeSetParams_v2\0")
            .map(|sym| *sym);
        let cuGraphExecMemcpyNodeSetParams = __library
            .get(b"cuGraphExecMemcpyNodeSetParams\0")
            .map(|sym| *sym);
        let cuGraphExecMemsetNodeSetParams = __library
            .get(b"cuGraphExecMemsetNodeSetParams\0")
            .map(|sym| *sym);
        let cuGraphExecHostNodeSetParams = __library
            .get(b"cuGraphExecHostNodeSetParams\0")
            .map(|sym| *sym);
        let cuGraphExecChildGraphNodeSetParams = __library
            .get(b"cuGraphExecChildGraphNodeSetParams\0")
            .map(|sym| *sym);
        let cuGraphExecEventRecordNodeSetEvent = __library
            .get(b"cuGraphExecEventRecordNodeSetEvent\0")
            .map(|sym| *sym);
        let cuGraphExecEventWaitNodeSetEvent = __library
            .get(b"cuGraphExecEventWaitNodeSetEvent\0")
            .map(|sym| *sym);
        let cuGraphExecExternalSemaphoresSignalNodeSetParams = __library
            .get(b"cuGraphExecExternalSemaphoresSignalNodeSetParams\0")
            .map(|sym| *sym);
        let cuGraphExecExternalSemaphoresWaitNodeSetParams = __library
            .get(b"cuGraphExecExternalSemaphoresWaitNodeSetParams\0")
            .map(|sym| *sym);
        let cuGraphNodeSetEnabled = __library.get(b"cuGraphNodeSetEnabled\0").map(|sym| *sym);
        let cuGraphNodeGetEnabled = __library.get(b"cuGraphNodeGetEnabled\0").map(|sym| *sym);
        let cuGraphUpload = __library.get(b"cuGraphUpload\0").map(|sym| *sym);
        let cuGraphLaunch = __library.get(b"cuGraphLaunch\0").map(|sym| *sym);
        let cuGraphExecDestroy = __library.get(b"cuGraphExecDestroy\0").map(|sym| *sym);
        let cuGraphDestroy = __library.get(b"cuGraphDestroy\0").map(|sym| *sym);
        let cuGraphExecUpdate_v2 = __library.get(b"cuGraphExecUpdate_v2\0").map(|sym| *sym);
        let cuGraphKernelNodeCopyAttributes = __library
            .get(b"cuGraphKernelNodeCopyAttributes\0")
            .map(|sym| *sym);
        let cuGraphKernelNodeGetAttribute = __library
            .get(b"cuGraphKernelNodeGetAttribute\0")
            .map(|sym| *sym);
        let cuGraphKernelNodeSetAttribute = __library
            .get(b"cuGraphKernelNodeSetAttribute\0")
            .map(|sym| *sym);
        let cuGraphDebugDotPrint = __library.get(b"cuGraphDebugDotPrint\0").map(|sym| *sym);
        let cuUserObjectCreate = __library.get(b"cuUserObjectCreate\0").map(|sym| *sym);
        let cuUserObjectRetain = __library.get(b"cuUserObjectRetain\0").map(|sym| *sym);
        let cuUserObjectRelease = __library.get(b"cuUserObjectRelease\0").map(|sym| *sym);
        let cuGraphRetainUserObject = __library.get(b"cuGraphRetainUserObject\0").map(|sym| *sym);
        let cuGraphReleaseUserObject = __library.get(b"cuGraphReleaseUserObject\0").map(|sym| *sym);
        let cuGraphAddNode = __library.get(b"cuGraphAddNode\0").map(|sym| *sym);
        let cuGraphAddNode_v2 = __library.get(b"cuGraphAddNode_v2\0").map(|sym| *sym);
        let cuGraphNodeSetParams = __library.get(b"cuGraphNodeSetParams\0").map(|sym| *sym);
        let cuGraphExecNodeSetParams = __library.get(b"cuGraphExecNodeSetParams\0").map(|sym| *sym);
        let cuGraphConditionalHandleCreate = __library
            .get(b"cuGraphConditionalHandleCreate\0")
            .map(|sym| *sym);
        let cuOccupancyMaxActiveBlocksPerMultiprocessor = __library
            .get(b"cuOccupancyMaxActiveBlocksPerMultiprocessor\0")
            .map(|sym| *sym);
        let cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags = __library
            .get(b"cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags\0")
            .map(|sym| *sym);
        let cuOccupancyMaxPotentialBlockSize = __library
            .get(b"cuOccupancyMaxPotentialBlockSize\0")
            .map(|sym| *sym);
        let cuOccupancyMaxPotentialBlockSizeWithFlags = __library
            .get(b"cuOccupancyMaxPotentialBlockSizeWithFlags\0")
            .map(|sym| *sym);
        let cuOccupancyAvailableDynamicSMemPerBlock = __library
            .get(b"cuOccupancyAvailableDynamicSMemPerBlock\0")
            .map(|sym| *sym);
        let cuOccupancyMaxPotentialClusterSize = __library
            .get(b"cuOccupancyMaxPotentialClusterSize\0")
            .map(|sym| *sym);
        let cuOccupancyMaxActiveClusters = __library
            .get(b"cuOccupancyMaxActiveClusters\0")
            .map(|sym| *sym);
        let cuTexRefSetArray = __library.get(b"cuTexRefSetArray\0").map(|sym| *sym);
        let cuTexRefSetMipmappedArray = __library
            .get(b"cuTexRefSetMipmappedArray\0")
            .map(|sym| *sym);
        let cuTexRefSetAddress_v2 = __library.get(b"cuTexRefSetAddress_v2\0").map(|sym| *sym);
        let cuTexRefSetAddress2D_v3 = __library.get(b"cuTexRefSetAddress2D_v3\0").map(|sym| *sym);
        let cuTexRefSetFormat = __library.get(b"cuTexRefSetFormat\0").map(|sym| *sym);
        let cuTexRefSetAddressMode = __library.get(b"cuTexRefSetAddressMode\0").map(|sym| *sym);
        let cuTexRefSetFilterMode = __library.get(b"cuTexRefSetFilterMode\0").map(|sym| *sym);
        let cuTexRefSetMipmapFilterMode = __library
            .get(b"cuTexRefSetMipmapFilterMode\0")
            .map(|sym| *sym);
        let cuTexRefSetMipmapLevelBias = __library
            .get(b"cuTexRefSetMipmapLevelBias\0")
            .map(|sym| *sym);
        let cuTexRefSetMipmapLevelClamp = __library
            .get(b"cuTexRefSetMipmapLevelClamp\0")
            .map(|sym| *sym);
        let cuTexRefSetMaxAnisotropy = __library.get(b"cuTexRefSetMaxAnisotropy\0").map(|sym| *sym);
        let cuTexRefSetBorderColor = __library.get(b"cuTexRefSetBorderColor\0").map(|sym| *sym);
        let cuTexRefSetFlags = __library.get(b"cuTexRefSetFlags\0").map(|sym| *sym);
        let cuTexRefGetAddress_v2 = __library.get(b"cuTexRefGetAddress_v2\0").map(|sym| *sym);
        let cuTexRefGetArray = __library.get(b"cuTexRefGetArray\0").map(|sym| *sym);
        let cuTexRefGetMipmappedArray = __library
            .get(b"cuTexRefGetMipmappedArray\0")
            .map(|sym| *sym);
        let cuTexRefGetAddressMode = __library.get(b"cuTexRefGetAddressMode\0").map(|sym| *sym);
        let cuTexRefGetFilterMode = __library.get(b"cuTexRefGetFilterMode\0").map(|sym| *sym);
        let cuTexRefGetFormat = __library.get(b"cuTexRefGetFormat\0").map(|sym| *sym);
        let cuTexRefGetMipmapFilterMode = __library
            .get(b"cuTexRefGetMipmapFilterMode\0")
            .map(|sym| *sym);
        let cuTexRefGetMipmapLevelBias = __library
            .get(b"cuTexRefGetMipmapLevelBias\0")
            .map(|sym| *sym);
        let cuTexRefGetMipmapLevelClamp = __library
            .get(b"cuTexRefGetMipmapLevelClamp\0")
            .map(|sym| *sym);
        let cuTexRefGetMaxAnisotropy = __library.get(b"cuTexRefGetMaxAnisotropy\0").map(|sym| *sym);
        let cuTexRefGetBorderColor = __library.get(b"cuTexRefGetBorderColor\0").map(|sym| *sym);
        let cuTexRefGetFlags = __library.get(b"cuTexRefGetFlags\0").map(|sym| *sym);
        let cuTexRefCreate = __library.get(b"cuTexRefCreate\0").map(|sym| *sym);
        let cuTexRefDestroy = __library.get(b"cuTexRefDestroy\0").map(|sym| *sym);
        let cuSurfRefSetArray = __library.get(b"cuSurfRefSetArray\0").map(|sym| *sym);
        let cuSurfRefGetArray = __library.get(b"cuSurfRefGetArray\0").map(|sym| *sym);
        let cuTexObjectCreate = __library.get(b"cuTexObjectCreate\0").map(|sym| *sym);
        let cuTexObjectDestroy = __library.get(b"cuTexObjectDestroy\0").map(|sym| *sym);
        let cuTexObjectGetResourceDesc = __library
            .get(b"cuTexObjectGetResourceDesc\0")
            .map(|sym| *sym);
        let cuTexObjectGetTextureDesc = __library
            .get(b"cuTexObjectGetTextureDesc\0")
            .map(|sym| *sym);
        let cuTexObjectGetResourceViewDesc = __library
            .get(b"cuTexObjectGetResourceViewDesc\0")
            .map(|sym| *sym);
        let cuSurfObjectCreate = __library.get(b"cuSurfObjectCreate\0").map(|sym| *sym);
        let cuSurfObjectDestroy = __library.get(b"cuSurfObjectDestroy\0").map(|sym| *sym);
        let cuSurfObjectGetResourceDesc = __library
            .get(b"cuSurfObjectGetResourceDesc\0")
            .map(|sym| *sym);
        let cuTensorMapEncodeTiled = __library.get(b"cuTensorMapEncodeTiled\0").map(|sym| *sym);
        let cuTensorMapEncodeIm2col = __library.get(b"cuTensorMapEncodeIm2col\0").map(|sym| *sym);
        let cuTensorMapReplaceAddress = __library
            .get(b"cuTensorMapReplaceAddress\0")
            .map(|sym| *sym);
        let cuDeviceCanAccessPeer = __library.get(b"cuDeviceCanAccessPeer\0").map(|sym| *sym);
        let cuCtxEnablePeerAccess = __library.get(b"cuCtxEnablePeerAccess\0").map(|sym| *sym);
        let cuCtxDisablePeerAccess = __library.get(b"cuCtxDisablePeerAccess\0").map(|sym| *sym);
        let cuDeviceGetP2PAttribute = __library.get(b"cuDeviceGetP2PAttribute\0").map(|sym| *sym);
        let cuGraphicsUnregisterResource = __library
            .get(b"cuGraphicsUnregisterResource\0")
            .map(|sym| *sym);
        let cuGraphicsSubResourceGetMappedArray = __library
            .get(b"cuGraphicsSubResourceGetMappedArray\0")
            .map(|sym| *sym);
        let cuGraphicsResourceGetMappedMipmappedArray = __library
            .get(b"cuGraphicsResourceGetMappedMipmappedArray\0")
            .map(|sym| *sym);
        let cuGraphicsResourceGetMappedPointer_v2 = __library
            .get(b"cuGraphicsResourceGetMappedPointer_v2\0")
            .map(|sym| *sym);
        let cuGraphicsResourceSetMapFlags_v2 = __library
            .get(b"cuGraphicsResourceSetMapFlags_v2\0")
            .map(|sym| *sym);
        let cuGraphicsMapResources = __library.get(b"cuGraphicsMapResources\0").map(|sym| *sym);
        let cuGraphicsUnmapResources = __library.get(b"cuGraphicsUnmapResources\0").map(|sym| *sym);
        let cuGetProcAddress_v2 = __library.get(b"cuGetProcAddress_v2\0").map(|sym| *sym);
        let cuCoredumpGetAttribute = __library.get(b"cuCoredumpGetAttribute\0").map(|sym| *sym);
        let cuCoredumpGetAttributeGlobal = __library
            .get(b"cuCoredumpGetAttributeGlobal\0")
            .map(|sym| *sym);
        let cuCoredumpSetAttribute = __library.get(b"cuCoredumpSetAttribute\0").map(|sym| *sym);
        let cuCoredumpSetAttributeGlobal = __library
            .get(b"cuCoredumpSetAttributeGlobal\0")
            .map(|sym| *sym);
        let cuGetExportTable = __library.get(b"cuGetExportTable\0").map(|sym| *sym);
        let cuProfilerInitialize = __library.get(b"cuProfilerInitialize\0").map(|sym| *sym);
        let cuProfilerStart = __library.get(b"cuProfilerStart\0").map(|sym| *sym);
        let cuProfilerStop = __library.get(b"cuProfilerStop\0").map(|sym| *sym);
        Ok(Lib {
            __library,
            cuGetErrorString,
            cuGetErrorName,
            cuInit,
            cuDriverGetVersion,
            cuDeviceGet,
            cuDeviceGetCount,
            cuDeviceGetName,
            cuDeviceGetUuid,
            cuDeviceGetUuid_v2,
            cuDeviceGetLuid,
            cuDeviceTotalMem_v2,
            cuDeviceGetTexture1DLinearMaxWidth,
            cuDeviceGetAttribute,
            cuDeviceGetNvSciSyncAttributes,
            cuDeviceSetMemPool,
            cuDeviceGetMemPool,
            cuDeviceGetDefaultMemPool,
            cuDeviceGetExecAffinitySupport,
            cuFlushGPUDirectRDMAWrites,
            cuDeviceGetProperties,
            cuDeviceComputeCapability,
            cuDevicePrimaryCtxRetain,
            cuDevicePrimaryCtxRelease_v2,
            cuDevicePrimaryCtxSetFlags_v2,
            cuDevicePrimaryCtxGetState,
            cuDevicePrimaryCtxReset_v2,
            cuCtxCreate_v2,
            cuCtxCreate_v3,
            cuCtxDestroy_v2,
            cuCtxPushCurrent_v2,
            cuCtxPopCurrent_v2,
            cuCtxSetCurrent,
            cuCtxGetCurrent,
            cuCtxGetDevice,
            cuCtxGetFlags,
            cuCtxSetFlags,
            cuCtxGetId,
            cuCtxSynchronize,
            cuCtxSetLimit,
            cuCtxGetLimit,
            cuCtxGetCacheConfig,
            cuCtxSetCacheConfig,
            cuCtxGetSharedMemConfig,
            cuCtxSetSharedMemConfig,
            cuCtxGetApiVersion,
            cuCtxGetStreamPriorityRange,
            cuCtxResetPersistingL2Cache,
            cuCtxGetExecAffinity,
            cuCtxAttach,
            cuCtxDetach,
            cuModuleLoad,
            cuModuleLoadData,
            cuModuleLoadDataEx,
            cuModuleLoadFatBinary,
            cuModuleUnload,
            cuModuleGetLoadingMode,
            cuModuleGetFunction,
            cuModuleGetGlobal_v2,
            cuLinkCreate_v2,
            cuLinkAddData_v2,
            cuLinkAddFile_v2,
            cuLinkComplete,
            cuLinkDestroy,
            cuModuleGetTexRef,
            cuModuleGetSurfRef,
            cuLibraryLoadData,
            cuLibraryLoadFromFile,
            cuLibraryUnload,
            cuLibraryGetKernel,
            cuLibraryGetModule,
            cuKernelGetFunction,
            cuLibraryGetGlobal,
            cuLibraryGetManaged,
            cuLibraryGetUnifiedFunction,
            cuKernelGetAttribute,
            cuKernelSetAttribute,
            cuKernelSetCacheConfig,
            cuKernelGetName,
            cuMemGetInfo_v2,
            cuMemAlloc_v2,
            cuMemAllocPitch_v2,
            cuMemFree_v2,
            cuMemGetAddressRange_v2,
            cuMemAllocHost_v2,
            cuMemFreeHost,
            cuMemHostAlloc,
            cuMemHostGetDevicePointer_v2,
            cuMemHostGetFlags,
            cuMemAllocManaged,
            cuDeviceGetByPCIBusId,
            cuDeviceGetPCIBusId,
            cuIpcGetEventHandle,
            cuIpcOpenEventHandle,
            cuIpcGetMemHandle,
            cuIpcOpenMemHandle_v2,
            cuIpcCloseMemHandle,
            cuMemHostRegister_v2,
            cuMemHostUnregister,
            cuMemcpy,
            cuMemcpyPeer,
            cuMemcpyHtoD_v2,
            cuMemcpyDtoH_v2,
            cuMemcpyDtoD_v2,
            cuMemcpyDtoA_v2,
            cuMemcpyAtoD_v2,
            cuMemcpyHtoA_v2,
            cuMemcpyAtoH_v2,
            cuMemcpyAtoA_v2,
            cuMemcpy2D_v2,
            cuMemcpy2DUnaligned_v2,
            cuMemcpy3D_v2,
            cuMemcpy3DPeer,
            cuMemcpyAsync,
            cuMemcpyPeerAsync,
            cuMemcpyHtoDAsync_v2,
            cuMemcpyDtoHAsync_v2,
            cuMemcpyDtoDAsync_v2,
            cuMemcpyHtoAAsync_v2,
            cuMemcpyAtoHAsync_v2,
            cuMemcpy2DAsync_v2,
            cuMemcpy3DAsync_v2,
            cuMemcpy3DPeerAsync,
            cuMemsetD8_v2,
            cuMemsetD16_v2,
            cuMemsetD32_v2,
            cuMemsetD2D8_v2,
            cuMemsetD2D16_v2,
            cuMemsetD2D32_v2,
            cuMemsetD8Async,
            cuMemsetD16Async,
            cuMemsetD32Async,
            cuMemsetD2D8Async,
            cuMemsetD2D16Async,
            cuMemsetD2D32Async,
            cuArrayCreate_v2,
            cuArrayGetDescriptor_v2,
            cuArrayGetSparseProperties,
            cuMipmappedArrayGetSparseProperties,
            cuArrayGetMemoryRequirements,
            cuMipmappedArrayGetMemoryRequirements,
            cuArrayGetPlane,
            cuArrayDestroy,
            cuArray3DCreate_v2,
            cuArray3DGetDescriptor_v2,
            cuMipmappedArrayCreate,
            cuMipmappedArrayGetLevel,
            cuMipmappedArrayDestroy,
            cuMemGetHandleForAddressRange,
            cuMemAddressReserve,
            cuMemAddressFree,
            cuMemCreate,
            cuMemRelease,
            cuMemMap,
            cuMemMapArrayAsync,
            cuMemUnmap,
            cuMemSetAccess,
            cuMemGetAccess,
            cuMemExportToShareableHandle,
            cuMemImportFromShareableHandle,
            cuMemGetAllocationGranularity,
            cuMemGetAllocationPropertiesFromHandle,
            cuMemRetainAllocationHandle,
            cuMemFreeAsync,
            cuMemAllocAsync,
            cuMemPoolTrimTo,
            cuMemPoolSetAttribute,
            cuMemPoolGetAttribute,
            cuMemPoolSetAccess,
            cuMemPoolGetAccess,
            cuMemPoolCreate,
            cuMemPoolDestroy,
            cuMemAllocFromPoolAsync,
            cuMemPoolExportToShareableHandle,
            cuMemPoolImportFromShareableHandle,
            cuMemPoolExportPointer,
            cuMemPoolImportPointer,
            cuMulticastCreate,
            cuMulticastAddDevice,
            cuMulticastBindMem,
            cuMulticastBindAddr,
            cuMulticastUnbind,
            cuMulticastGetGranularity,
            cuPointerGetAttribute,
            cuMemPrefetchAsync,
            cuMemPrefetchAsync_v2,
            cuMemAdvise,
            cuMemAdvise_v2,
            cuMemRangeGetAttribute,
            cuMemRangeGetAttributes,
            cuPointerSetAttribute,
            cuPointerGetAttributes,
            cuStreamCreate,
            cuStreamCreateWithPriority,
            cuStreamGetPriority,
            cuStreamGetFlags,
            cuStreamGetId,
            cuStreamGetCtx,
            cuStreamWaitEvent,
            cuStreamAddCallback,
            cuStreamBeginCapture_v2,
            cuStreamBeginCaptureToGraph,
            cuThreadExchangeStreamCaptureMode,
            cuStreamEndCapture,
            cuStreamIsCapturing,
            cuStreamGetCaptureInfo_v2,
            cuStreamGetCaptureInfo_v3,
            cuStreamUpdateCaptureDependencies,
            cuStreamUpdateCaptureDependencies_v2,
            cuStreamAttachMemAsync,
            cuStreamQuery,
            cuStreamSynchronize,
            cuStreamDestroy_v2,
            cuStreamCopyAttributes,
            cuStreamGetAttribute,
            cuStreamSetAttribute,
            cuEventCreate,
            cuEventRecord,
            cuEventRecordWithFlags,
            cuEventQuery,
            cuEventSynchronize,
            cuEventDestroy_v2,
            cuEventElapsedTime,
            cuImportExternalMemory,
            cuExternalMemoryGetMappedBuffer,
            cuExternalMemoryGetMappedMipmappedArray,
            cuDestroyExternalMemory,
            cuImportExternalSemaphore,
            cuSignalExternalSemaphoresAsync,
            cuWaitExternalSemaphoresAsync,
            cuDestroyExternalSemaphore,
            cuStreamWaitValue32_v2,
            cuStreamWaitValue64_v2,
            cuStreamWriteValue32_v2,
            cuStreamWriteValue64_v2,
            cuStreamBatchMemOp_v2,
            cuFuncGetAttribute,
            cuFuncSetAttribute,
            cuFuncSetCacheConfig,
            cuFuncSetSharedMemConfig,
            cuFuncGetModule,
            cuFuncGetName,
            cuLaunchKernel,
            cuLaunchKernelEx,
            cuLaunchCooperativeKernel,
            cuLaunchCooperativeKernelMultiDevice,
            cuLaunchHostFunc,
            cuFuncSetBlockShape,
            cuFuncSetSharedSize,
            cuParamSetSize,
            cuParamSeti,
            cuParamSetf,
            cuParamSetv,
            cuLaunch,
            cuLaunchGrid,
            cuLaunchGridAsync,
            cuParamSetTexRef,
            cuGraphCreate,
            cuGraphAddKernelNode_v2,
            cuGraphKernelNodeGetParams_v2,
            cuGraphKernelNodeSetParams_v2,
            cuGraphAddMemcpyNode,
            cuGraphMemcpyNodeGetParams,
            cuGraphMemcpyNodeSetParams,
            cuGraphAddMemsetNode,
            cuGraphMemsetNodeGetParams,
            cuGraphMemsetNodeSetParams,
            cuGraphAddHostNode,
            cuGraphHostNodeGetParams,
            cuGraphHostNodeSetParams,
            cuGraphAddChildGraphNode,
            cuGraphChildGraphNodeGetGraph,
            cuGraphAddEmptyNode,
            cuGraphAddEventRecordNode,
            cuGraphEventRecordNodeGetEvent,
            cuGraphEventRecordNodeSetEvent,
            cuGraphAddEventWaitNode,
            cuGraphEventWaitNodeGetEvent,
            cuGraphEventWaitNodeSetEvent,
            cuGraphAddExternalSemaphoresSignalNode,
            cuGraphExternalSemaphoresSignalNodeGetParams,
            cuGraphExternalSemaphoresSignalNodeSetParams,
            cuGraphAddExternalSemaphoresWaitNode,
            cuGraphExternalSemaphoresWaitNodeGetParams,
            cuGraphExternalSemaphoresWaitNodeSetParams,
            cuGraphAddBatchMemOpNode,
            cuGraphBatchMemOpNodeGetParams,
            cuGraphBatchMemOpNodeSetParams,
            cuGraphExecBatchMemOpNodeSetParams,
            cuGraphAddMemAllocNode,
            cuGraphMemAllocNodeGetParams,
            cuGraphAddMemFreeNode,
            cuGraphMemFreeNodeGetParams,
            cuDeviceGraphMemTrim,
            cuDeviceGetGraphMemAttribute,
            cuDeviceSetGraphMemAttribute,
            cuGraphClone,
            cuGraphNodeFindInClone,
            cuGraphNodeGetType,
            cuGraphGetNodes,
            cuGraphGetRootNodes,
            cuGraphGetEdges,
            cuGraphGetEdges_v2,
            cuGraphNodeGetDependencies,
            cuGraphNodeGetDependencies_v2,
            cuGraphNodeGetDependentNodes,
            cuGraphNodeGetDependentNodes_v2,
            cuGraphAddDependencies,
            cuGraphAddDependencies_v2,
            cuGraphRemoveDependencies,
            cuGraphRemoveDependencies_v2,
            cuGraphDestroyNode,
            cuGraphInstantiateWithFlags,
            cuGraphInstantiateWithParams,
            cuGraphExecGetFlags,
            cuGraphExecKernelNodeSetParams_v2,
            cuGraphExecMemcpyNodeSetParams,
            cuGraphExecMemsetNodeSetParams,
            cuGraphExecHostNodeSetParams,
            cuGraphExecChildGraphNodeSetParams,
            cuGraphExecEventRecordNodeSetEvent,
            cuGraphExecEventWaitNodeSetEvent,
            cuGraphExecExternalSemaphoresSignalNodeSetParams,
            cuGraphExecExternalSemaphoresWaitNodeSetParams,
            cuGraphNodeSetEnabled,
            cuGraphNodeGetEnabled,
            cuGraphUpload,
            cuGraphLaunch,
            cuGraphExecDestroy,
            cuGraphDestroy,
            cuGraphExecUpdate_v2,
            cuGraphKernelNodeCopyAttributes,
            cuGraphKernelNodeGetAttribute,
            cuGraphKernelNodeSetAttribute,
            cuGraphDebugDotPrint,
            cuUserObjectCreate,
            cuUserObjectRetain,
            cuUserObjectRelease,
            cuGraphRetainUserObject,
            cuGraphReleaseUserObject,
            cuGraphAddNode,
            cuGraphAddNode_v2,
            cuGraphNodeSetParams,
            cuGraphExecNodeSetParams,
            cuGraphConditionalHandleCreate,
            cuOccupancyMaxActiveBlocksPerMultiprocessor,
            cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags,
            cuOccupancyMaxPotentialBlockSize,
            cuOccupancyMaxPotentialBlockSizeWithFlags,
            cuOccupancyAvailableDynamicSMemPerBlock,
            cuOccupancyMaxPotentialClusterSize,
            cuOccupancyMaxActiveClusters,
            cuTexRefSetArray,
            cuTexRefSetMipmappedArray,
            cuTexRefSetAddress_v2,
            cuTexRefSetAddress2D_v3,
            cuTexRefSetFormat,
            cuTexRefSetAddressMode,
            cuTexRefSetFilterMode,
            cuTexRefSetMipmapFilterMode,
            cuTexRefSetMipmapLevelBias,
            cuTexRefSetMipmapLevelClamp,
            cuTexRefSetMaxAnisotropy,
            cuTexRefSetBorderColor,
            cuTexRefSetFlags,
            cuTexRefGetAddress_v2,
            cuTexRefGetArray,
            cuTexRefGetMipmappedArray,
            cuTexRefGetAddressMode,
            cuTexRefGetFilterMode,
            cuTexRefGetFormat,
            cuTexRefGetMipmapFilterMode,
            cuTexRefGetMipmapLevelBias,
            cuTexRefGetMipmapLevelClamp,
            cuTexRefGetMaxAnisotropy,
            cuTexRefGetBorderColor,
            cuTexRefGetFlags,
            cuTexRefCreate,
            cuTexRefDestroy,
            cuSurfRefSetArray,
            cuSurfRefGetArray,
            cuTexObjectCreate,
            cuTexObjectDestroy,
            cuTexObjectGetResourceDesc,
            cuTexObjectGetTextureDesc,
            cuTexObjectGetResourceViewDesc,
            cuSurfObjectCreate,
            cuSurfObjectDestroy,
            cuSurfObjectGetResourceDesc,
            cuTensorMapEncodeTiled,
            cuTensorMapEncodeIm2col,
            cuTensorMapReplaceAddress,
            cuDeviceCanAccessPeer,
            cuCtxEnablePeerAccess,
            cuCtxDisablePeerAccess,
            cuDeviceGetP2PAttribute,
            cuGraphicsUnregisterResource,
            cuGraphicsSubResourceGetMappedArray,
            cuGraphicsResourceGetMappedMipmappedArray,
            cuGraphicsResourceGetMappedPointer_v2,
            cuGraphicsResourceSetMapFlags_v2,
            cuGraphicsMapResources,
            cuGraphicsUnmapResources,
            cuGetProcAddress_v2,
            cuCoredumpGetAttribute,
            cuCoredumpGetAttributeGlobal,
            cuCoredumpSetAttribute,
            cuCoredumpSetAttributeGlobal,
            cuGetExportTable,
            cuProfilerInitialize,
            cuProfilerStart,
            cuProfilerStop,
        })
    }
    pub unsafe fn cuGetErrorString(
        &self,
        error: CUresult,
        pStr: *mut *const ::core::ffi::c_char,
    ) -> CUresult {
        (self
            .cuGetErrorString
            .as_ref()
            .expect("Expected function, got error."))(error, pStr)
    }
    pub unsafe fn cuGetErrorName(
        &self,
        error: CUresult,
        pStr: *mut *const ::core::ffi::c_char,
    ) -> CUresult {
        (self
            .cuGetErrorName
            .as_ref()
            .expect("Expected function, got error."))(error, pStr)
    }
    pub unsafe fn cuInit(&self, Flags: ::core::ffi::c_uint) -> CUresult {
        (self.cuInit.as_ref().expect("Expected function, got error."))(Flags)
    }
    pub unsafe fn cuDriverGetVersion(&self, driverVersion: *mut ::core::ffi::c_int) -> CUresult {
        (self
            .cuDriverGetVersion
            .as_ref()
            .expect("Expected function, got error."))(driverVersion)
    }
    pub unsafe fn cuDeviceGet(
        &self,
        device: *mut CUdevice,
        ordinal: ::core::ffi::c_int,
    ) -> CUresult {
        (self
            .cuDeviceGet
            .as_ref()
            .expect("Expected function, got error."))(device, ordinal)
    }
    pub unsafe fn cuDeviceGetCount(&self, count: *mut ::core::ffi::c_int) -> CUresult {
        (self
            .cuDeviceGetCount
            .as_ref()
            .expect("Expected function, got error."))(count)
    }
    pub unsafe fn cuDeviceGetName(
        &self,
        name: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuDeviceGetName
            .as_ref()
            .expect("Expected function, got error."))(name, len, dev)
    }
    pub unsafe fn cuDeviceGetUuid(&self, uuid: *mut CUuuid, dev: CUdevice) -> CUresult {
        (self
            .cuDeviceGetUuid
            .as_ref()
            .expect("Expected function, got error."))(uuid, dev)
    }
    pub unsafe fn cuDeviceGetUuid_v2(&self, uuid: *mut CUuuid, dev: CUdevice) -> CUresult {
        (self
            .cuDeviceGetUuid_v2
            .as_ref()
            .expect("Expected function, got error."))(uuid, dev)
    }
    pub unsafe fn cuDeviceGetLuid(
        &self,
        luid: *mut ::core::ffi::c_char,
        deviceNodeMask: *mut ::core::ffi::c_uint,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuDeviceGetLuid
            .as_ref()
            .expect("Expected function, got error."))(luid, deviceNodeMask, dev)
    }
    pub unsafe fn cuDeviceTotalMem_v2(&self, bytes: *mut usize, dev: CUdevice) -> CUresult {
        (self
            .cuDeviceTotalMem_v2
            .as_ref()
            .expect("Expected function, got error."))(bytes, dev)
    }
    pub unsafe fn cuDeviceGetTexture1DLinearMaxWidth(
        &self,
        maxWidthInElements: *mut usize,
        format: CUarray_format,
        numChannels: ::core::ffi::c_uint,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuDeviceGetTexture1DLinearMaxWidth
            .as_ref()
            .expect("Expected function, got error."))(
            maxWidthInElements, format, numChannels, dev
        )
    }
    pub unsafe fn cuDeviceGetAttribute(
        &self,
        pi: *mut ::core::ffi::c_int,
        attrib: CUdevice_attribute,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuDeviceGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(pi, attrib, dev)
    }
    pub unsafe fn cuDeviceGetNvSciSyncAttributes(
        &self,
        nvSciSyncAttrList: *mut ::core::ffi::c_void,
        dev: CUdevice,
        flags: ::core::ffi::c_int,
    ) -> CUresult {
        (self
            .cuDeviceGetNvSciSyncAttributes
            .as_ref()
            .expect("Expected function, got error."))(nvSciSyncAttrList, dev, flags)
    }
    pub unsafe fn cuDeviceSetMemPool(&self, dev: CUdevice, pool: CUmemoryPool) -> CUresult {
        (self
            .cuDeviceSetMemPool
            .as_ref()
            .expect("Expected function, got error."))(dev, pool)
    }
    pub unsafe fn cuDeviceGetMemPool(&self, pool: *mut CUmemoryPool, dev: CUdevice) -> CUresult {
        (self
            .cuDeviceGetMemPool
            .as_ref()
            .expect("Expected function, got error."))(pool, dev)
    }
    pub unsafe fn cuDeviceGetDefaultMemPool(
        &self,
        pool_out: *mut CUmemoryPool,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuDeviceGetDefaultMemPool
            .as_ref()
            .expect("Expected function, got error."))(pool_out, dev)
    }
    pub unsafe fn cuDeviceGetExecAffinitySupport(
        &self,
        pi: *mut ::core::ffi::c_int,
        type_: CUexecAffinityType,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuDeviceGetExecAffinitySupport
            .as_ref()
            .expect("Expected function, got error."))(pi, type_, dev)
    }
    pub unsafe fn cuFlushGPUDirectRDMAWrites(
        &self,
        target: CUflushGPUDirectRDMAWritesTarget,
        scope: CUflushGPUDirectRDMAWritesScope,
    ) -> CUresult {
        (self
            .cuFlushGPUDirectRDMAWrites
            .as_ref()
            .expect("Expected function, got error."))(target, scope)
    }
    pub unsafe fn cuDeviceGetProperties(&self, prop: *mut CUdevprop, dev: CUdevice) -> CUresult {
        (self
            .cuDeviceGetProperties
            .as_ref()
            .expect("Expected function, got error."))(prop, dev)
    }
    pub unsafe fn cuDeviceComputeCapability(
        &self,
        major: *mut ::core::ffi::c_int,
        minor: *mut ::core::ffi::c_int,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuDeviceComputeCapability
            .as_ref()
            .expect("Expected function, got error."))(major, minor, dev)
    }
    pub unsafe fn cuDevicePrimaryCtxRetain(&self, pctx: *mut CUcontext, dev: CUdevice) -> CUresult {
        (self
            .cuDevicePrimaryCtxRetain
            .as_ref()
            .expect("Expected function, got error."))(pctx, dev)
    }
    pub unsafe fn cuDevicePrimaryCtxRelease_v2(&self, dev: CUdevice) -> CUresult {
        (self
            .cuDevicePrimaryCtxRelease_v2
            .as_ref()
            .expect("Expected function, got error."))(dev)
    }
    pub unsafe fn cuDevicePrimaryCtxSetFlags_v2(
        &self,
        dev: CUdevice,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuDevicePrimaryCtxSetFlags_v2
            .as_ref()
            .expect("Expected function, got error."))(dev, flags)
    }
    pub unsafe fn cuDevicePrimaryCtxGetState(
        &self,
        dev: CUdevice,
        flags: *mut ::core::ffi::c_uint,
        active: *mut ::core::ffi::c_int,
    ) -> CUresult {
        (self
            .cuDevicePrimaryCtxGetState
            .as_ref()
            .expect("Expected function, got error."))(dev, flags, active)
    }
    pub unsafe fn cuDevicePrimaryCtxReset_v2(&self, dev: CUdevice) -> CUresult {
        (self
            .cuDevicePrimaryCtxReset_v2
            .as_ref()
            .expect("Expected function, got error."))(dev)
    }
    pub unsafe fn cuCtxCreate_v2(
        &self,
        pctx: *mut CUcontext,
        flags: ::core::ffi::c_uint,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuCtxCreate_v2
            .as_ref()
            .expect("Expected function, got error."))(pctx, flags, dev)
    }
    pub unsafe fn cuCtxCreate_v3(
        &self,
        pctx: *mut CUcontext,
        paramsArray: *mut CUexecAffinityParam,
        numParams: ::core::ffi::c_int,
        flags: ::core::ffi::c_uint,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuCtxCreate_v3
            .as_ref()
            .expect("Expected function, got error."))(
            pctx, paramsArray, numParams, flags, dev
        )
    }
    pub unsafe fn cuCtxDestroy_v2(&self, ctx: CUcontext) -> CUresult {
        (self
            .cuCtxDestroy_v2
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    pub unsafe fn cuCtxPushCurrent_v2(&self, ctx: CUcontext) -> CUresult {
        (self
            .cuCtxPushCurrent_v2
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    pub unsafe fn cuCtxPopCurrent_v2(&self, pctx: *mut CUcontext) -> CUresult {
        (self
            .cuCtxPopCurrent_v2
            .as_ref()
            .expect("Expected function, got error."))(pctx)
    }
    pub unsafe fn cuCtxSetCurrent(&self, ctx: CUcontext) -> CUresult {
        (self
            .cuCtxSetCurrent
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    pub unsafe fn cuCtxGetCurrent(&self, pctx: *mut CUcontext) -> CUresult {
        (self
            .cuCtxGetCurrent
            .as_ref()
            .expect("Expected function, got error."))(pctx)
    }
    pub unsafe fn cuCtxGetDevice(&self, device: *mut CUdevice) -> CUresult {
        (self
            .cuCtxGetDevice
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn cuCtxGetFlags(&self, flags: *mut ::core::ffi::c_uint) -> CUresult {
        (self
            .cuCtxGetFlags
            .as_ref()
            .expect("Expected function, got error."))(flags)
    }
    pub unsafe fn cuCtxSetFlags(&self, flags: ::core::ffi::c_uint) -> CUresult {
        (self
            .cuCtxSetFlags
            .as_ref()
            .expect("Expected function, got error."))(flags)
    }
    pub unsafe fn cuCtxGetId(
        &self,
        ctx: CUcontext,
        ctxId: *mut ::core::ffi::c_ulonglong,
    ) -> CUresult {
        (self
            .cuCtxGetId
            .as_ref()
            .expect("Expected function, got error."))(ctx, ctxId)
    }
    pub unsafe fn cuCtxSynchronize(&self) -> CUresult {
        (self
            .cuCtxSynchronize
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn cuCtxSetLimit(&self, limit: CUlimit, value: usize) -> CUresult {
        (self
            .cuCtxSetLimit
            .as_ref()
            .expect("Expected function, got error."))(limit, value)
    }
    pub unsafe fn cuCtxGetLimit(&self, pvalue: *mut usize, limit: CUlimit) -> CUresult {
        (self
            .cuCtxGetLimit
            .as_ref()
            .expect("Expected function, got error."))(pvalue, limit)
    }
    pub unsafe fn cuCtxGetCacheConfig(&self, pconfig: *mut CUfunc_cache) -> CUresult {
        (self
            .cuCtxGetCacheConfig
            .as_ref()
            .expect("Expected function, got error."))(pconfig)
    }
    pub unsafe fn cuCtxSetCacheConfig(&self, config: CUfunc_cache) -> CUresult {
        (self
            .cuCtxSetCacheConfig
            .as_ref()
            .expect("Expected function, got error."))(config)
    }
    pub unsafe fn cuCtxGetSharedMemConfig(&self, pConfig: *mut CUsharedconfig) -> CUresult {
        (self
            .cuCtxGetSharedMemConfig
            .as_ref()
            .expect("Expected function, got error."))(pConfig)
    }
    pub unsafe fn cuCtxSetSharedMemConfig(&self, config: CUsharedconfig) -> CUresult {
        (self
            .cuCtxSetSharedMemConfig
            .as_ref()
            .expect("Expected function, got error."))(config)
    }
    pub unsafe fn cuCtxGetApiVersion(
        &self,
        ctx: CUcontext,
        version: *mut ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuCtxGetApiVersion
            .as_ref()
            .expect("Expected function, got error."))(ctx, version)
    }
    pub unsafe fn cuCtxGetStreamPriorityRange(
        &self,
        leastPriority: *mut ::core::ffi::c_int,
        greatestPriority: *mut ::core::ffi::c_int,
    ) -> CUresult {
        (self
            .cuCtxGetStreamPriorityRange
            .as_ref()
            .expect("Expected function, got error."))(leastPriority, greatestPriority)
    }
    pub unsafe fn cuCtxResetPersistingL2Cache(&self) -> CUresult {
        (self
            .cuCtxResetPersistingL2Cache
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn cuCtxGetExecAffinity(
        &self,
        pExecAffinity: *mut CUexecAffinityParam,
        type_: CUexecAffinityType,
    ) -> CUresult {
        (self
            .cuCtxGetExecAffinity
            .as_ref()
            .expect("Expected function, got error."))(pExecAffinity, type_)
    }
    pub unsafe fn cuCtxAttach(&self, pctx: *mut CUcontext, flags: ::core::ffi::c_uint) -> CUresult {
        (self
            .cuCtxAttach
            .as_ref()
            .expect("Expected function, got error."))(pctx, flags)
    }
    pub unsafe fn cuCtxDetach(&self, ctx: CUcontext) -> CUresult {
        (self
            .cuCtxDetach
            .as_ref()
            .expect("Expected function, got error."))(ctx)
    }
    pub unsafe fn cuModuleLoad(
        &self,
        module: *mut CUmodule,
        fname: *const ::core::ffi::c_char,
    ) -> CUresult {
        (self
            .cuModuleLoad
            .as_ref()
            .expect("Expected function, got error."))(module, fname)
    }
    pub unsafe fn cuModuleLoadData(
        &self,
        module: *mut CUmodule,
        image: *const ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuModuleLoadData
            .as_ref()
            .expect("Expected function, got error."))(module, image)
    }
    pub unsafe fn cuModuleLoadDataEx(
        &self,
        module: *mut CUmodule,
        image: *const ::core::ffi::c_void,
        numOptions: ::core::ffi::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuModuleLoadDataEx
            .as_ref()
            .expect("Expected function, got error."))(
            module,
            image,
            numOptions,
            options,
            optionValues,
        )
    }
    pub unsafe fn cuModuleLoadFatBinary(
        &self,
        module: *mut CUmodule,
        fatCubin: *const ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuModuleLoadFatBinary
            .as_ref()
            .expect("Expected function, got error."))(module, fatCubin)
    }
    pub unsafe fn cuModuleUnload(&self, hmod: CUmodule) -> CUresult {
        (self
            .cuModuleUnload
            .as_ref()
            .expect("Expected function, got error."))(hmod)
    }
    pub unsafe fn cuModuleGetLoadingMode(&self, mode: *mut CUmoduleLoadingMode) -> CUresult {
        (self
            .cuModuleGetLoadingMode
            .as_ref()
            .expect("Expected function, got error."))(mode)
    }
    pub unsafe fn cuModuleGetFunction(
        &self,
        hfunc: *mut CUfunction,
        hmod: CUmodule,
        name: *const ::core::ffi::c_char,
    ) -> CUresult {
        (self
            .cuModuleGetFunction
            .as_ref()
            .expect("Expected function, got error."))(hfunc, hmod, name)
    }
    pub unsafe fn cuModuleGetGlobal_v2(
        &self,
        dptr: *mut CUdeviceptr,
        bytes: *mut usize,
        hmod: CUmodule,
        name: *const ::core::ffi::c_char,
    ) -> CUresult {
        (self
            .cuModuleGetGlobal_v2
            .as_ref()
            .expect("Expected function, got error."))(dptr, bytes, hmod, name)
    }
    pub unsafe fn cuLinkCreate_v2(
        &self,
        numOptions: ::core::ffi::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::core::ffi::c_void,
        stateOut: *mut CUlinkState,
    ) -> CUresult {
        (self
            .cuLinkCreate_v2
            .as_ref()
            .expect("Expected function, got error."))(
            numOptions, options, optionValues, stateOut
        )
    }
    pub unsafe fn cuLinkAddData_v2(
        &self,
        state: CUlinkState,
        type_: CUjitInputType,
        data: *mut ::core::ffi::c_void,
        size: usize,
        name: *const ::core::ffi::c_char,
        numOptions: ::core::ffi::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuLinkAddData_v2
            .as_ref()
            .expect("Expected function, got error."))(
            state,
            type_,
            data,
            size,
            name,
            numOptions,
            options,
            optionValues,
        )
    }
    pub unsafe fn cuLinkAddFile_v2(
        &self,
        state: CUlinkState,
        type_: CUjitInputType,
        path: *const ::core::ffi::c_char,
        numOptions: ::core::ffi::c_uint,
        options: *mut CUjit_option,
        optionValues: *mut *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuLinkAddFile_v2
            .as_ref()
            .expect("Expected function, got error."))(
            state,
            type_,
            path,
            numOptions,
            options,
            optionValues,
        )
    }
    pub unsafe fn cuLinkComplete(
        &self,
        state: CUlinkState,
        cubinOut: *mut *mut ::core::ffi::c_void,
        sizeOut: *mut usize,
    ) -> CUresult {
        (self
            .cuLinkComplete
            .as_ref()
            .expect("Expected function, got error."))(state, cubinOut, sizeOut)
    }
    pub unsafe fn cuLinkDestroy(&self, state: CUlinkState) -> CUresult {
        (self
            .cuLinkDestroy
            .as_ref()
            .expect("Expected function, got error."))(state)
    }
    pub unsafe fn cuModuleGetTexRef(
        &self,
        pTexRef: *mut CUtexref,
        hmod: CUmodule,
        name: *const ::core::ffi::c_char,
    ) -> CUresult {
        (self
            .cuModuleGetTexRef
            .as_ref()
            .expect("Expected function, got error."))(pTexRef, hmod, name)
    }
    pub unsafe fn cuModuleGetSurfRef(
        &self,
        pSurfRef: *mut CUsurfref,
        hmod: CUmodule,
        name: *const ::core::ffi::c_char,
    ) -> CUresult {
        (self
            .cuModuleGetSurfRef
            .as_ref()
            .expect("Expected function, got error."))(pSurfRef, hmod, name)
    }
    pub unsafe fn cuLibraryLoadData(
        &self,
        library: *mut CUlibrary,
        code: *const ::core::ffi::c_void,
        jitOptions: *mut CUjit_option,
        jitOptionsValues: *mut *mut ::core::ffi::c_void,
        numJitOptions: ::core::ffi::c_uint,
        libraryOptions: *mut CUlibraryOption,
        libraryOptionValues: *mut *mut ::core::ffi::c_void,
        numLibraryOptions: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuLibraryLoadData
            .as_ref()
            .expect("Expected function, got error."))(
            library,
            code,
            jitOptions,
            jitOptionsValues,
            numJitOptions,
            libraryOptions,
            libraryOptionValues,
            numLibraryOptions,
        )
    }
    pub unsafe fn cuLibraryLoadFromFile(
        &self,
        library: *mut CUlibrary,
        fileName: *const ::core::ffi::c_char,
        jitOptions: *mut CUjit_option,
        jitOptionsValues: *mut *mut ::core::ffi::c_void,
        numJitOptions: ::core::ffi::c_uint,
        libraryOptions: *mut CUlibraryOption,
        libraryOptionValues: *mut *mut ::core::ffi::c_void,
        numLibraryOptions: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuLibraryLoadFromFile
            .as_ref()
            .expect("Expected function, got error."))(
            library,
            fileName,
            jitOptions,
            jitOptionsValues,
            numJitOptions,
            libraryOptions,
            libraryOptionValues,
            numLibraryOptions,
        )
    }
    pub unsafe fn cuLibraryUnload(&self, library: CUlibrary) -> CUresult {
        (self
            .cuLibraryUnload
            .as_ref()
            .expect("Expected function, got error."))(library)
    }
    pub unsafe fn cuLibraryGetKernel(
        &self,
        pKernel: *mut CUkernel,
        library: CUlibrary,
        name: *const ::core::ffi::c_char,
    ) -> CUresult {
        (self
            .cuLibraryGetKernel
            .as_ref()
            .expect("Expected function, got error."))(pKernel, library, name)
    }
    pub unsafe fn cuLibraryGetModule(&self, pMod: *mut CUmodule, library: CUlibrary) -> CUresult {
        (self
            .cuLibraryGetModule
            .as_ref()
            .expect("Expected function, got error."))(pMod, library)
    }
    pub unsafe fn cuKernelGetFunction(&self, pFunc: *mut CUfunction, kernel: CUkernel) -> CUresult {
        (self
            .cuKernelGetFunction
            .as_ref()
            .expect("Expected function, got error."))(pFunc, kernel)
    }
    pub unsafe fn cuLibraryGetGlobal(
        &self,
        dptr: *mut CUdeviceptr,
        bytes: *mut usize,
        library: CUlibrary,
        name: *const ::core::ffi::c_char,
    ) -> CUresult {
        (self
            .cuLibraryGetGlobal
            .as_ref()
            .expect("Expected function, got error."))(dptr, bytes, library, name)
    }
    pub unsafe fn cuLibraryGetManaged(
        &self,
        dptr: *mut CUdeviceptr,
        bytes: *mut usize,
        library: CUlibrary,
        name: *const ::core::ffi::c_char,
    ) -> CUresult {
        (self
            .cuLibraryGetManaged
            .as_ref()
            .expect("Expected function, got error."))(dptr, bytes, library, name)
    }
    pub unsafe fn cuLibraryGetUnifiedFunction(
        &self,
        fptr: *mut *mut ::core::ffi::c_void,
        library: CUlibrary,
        symbol: *const ::core::ffi::c_char,
    ) -> CUresult {
        (self
            .cuLibraryGetUnifiedFunction
            .as_ref()
            .expect("Expected function, got error."))(fptr, library, symbol)
    }
    pub unsafe fn cuKernelGetAttribute(
        &self,
        pi: *mut ::core::ffi::c_int,
        attrib: CUfunction_attribute,
        kernel: CUkernel,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuKernelGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(pi, attrib, kernel, dev)
    }
    pub unsafe fn cuKernelSetAttribute(
        &self,
        attrib: CUfunction_attribute,
        val: ::core::ffi::c_int,
        kernel: CUkernel,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuKernelSetAttribute
            .as_ref()
            .expect("Expected function, got error."))(attrib, val, kernel, dev)
    }
    pub unsafe fn cuKernelSetCacheConfig(
        &self,
        kernel: CUkernel,
        config: CUfunc_cache,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuKernelSetCacheConfig
            .as_ref()
            .expect("Expected function, got error."))(kernel, config, dev)
    }
    pub unsafe fn cuKernelGetName(
        &self,
        name: *mut *const ::core::ffi::c_char,
        hfunc: CUkernel,
    ) -> CUresult {
        (self
            .cuKernelGetName
            .as_ref()
            .expect("Expected function, got error."))(name, hfunc)
    }
    pub unsafe fn cuMemGetInfo_v2(&self, free: *mut usize, total: *mut usize) -> CUresult {
        (self
            .cuMemGetInfo_v2
            .as_ref()
            .expect("Expected function, got error."))(free, total)
    }
    pub unsafe fn cuMemAlloc_v2(&self, dptr: *mut CUdeviceptr, bytesize: usize) -> CUresult {
        (self
            .cuMemAlloc_v2
            .as_ref()
            .expect("Expected function, got error."))(dptr, bytesize)
    }
    pub unsafe fn cuMemAllocPitch_v2(
        &self,
        dptr: *mut CUdeviceptr,
        pPitch: *mut usize,
        WidthInBytes: usize,
        Height: usize,
        ElementSizeBytes: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuMemAllocPitch_v2
            .as_ref()
            .expect("Expected function, got error."))(
            dptr,
            pPitch,
            WidthInBytes,
            Height,
            ElementSizeBytes,
        )
    }
    pub unsafe fn cuMemFree_v2(&self, dptr: CUdeviceptr) -> CUresult {
        (self
            .cuMemFree_v2
            .as_ref()
            .expect("Expected function, got error."))(dptr)
    }
    pub unsafe fn cuMemGetAddressRange_v2(
        &self,
        pbase: *mut CUdeviceptr,
        psize: *mut usize,
        dptr: CUdeviceptr,
    ) -> CUresult {
        (self
            .cuMemGetAddressRange_v2
            .as_ref()
            .expect("Expected function, got error."))(pbase, psize, dptr)
    }
    pub unsafe fn cuMemAllocHost_v2(
        &self,
        pp: *mut *mut ::core::ffi::c_void,
        bytesize: usize,
    ) -> CUresult {
        (self
            .cuMemAllocHost_v2
            .as_ref()
            .expect("Expected function, got error."))(pp, bytesize)
    }
    pub unsafe fn cuMemFreeHost(&self, p: *mut ::core::ffi::c_void) -> CUresult {
        (self
            .cuMemFreeHost
            .as_ref()
            .expect("Expected function, got error."))(p)
    }
    pub unsafe fn cuMemHostAlloc(
        &self,
        pp: *mut *mut ::core::ffi::c_void,
        bytesize: usize,
        Flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuMemHostAlloc
            .as_ref()
            .expect("Expected function, got error."))(pp, bytesize, Flags)
    }
    pub unsafe fn cuMemHostGetDevicePointer_v2(
        &self,
        pdptr: *mut CUdeviceptr,
        p: *mut ::core::ffi::c_void,
        Flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuMemHostGetDevicePointer_v2
            .as_ref()
            .expect("Expected function, got error."))(pdptr, p, Flags)
    }
    pub unsafe fn cuMemHostGetFlags(
        &self,
        pFlags: *mut ::core::ffi::c_uint,
        p: *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuMemHostGetFlags
            .as_ref()
            .expect("Expected function, got error."))(pFlags, p)
    }
    pub unsafe fn cuMemAllocManaged(
        &self,
        dptr: *mut CUdeviceptr,
        bytesize: usize,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuMemAllocManaged
            .as_ref()
            .expect("Expected function, got error."))(dptr, bytesize, flags)
    }
    pub unsafe fn cuDeviceGetByPCIBusId(
        &self,
        dev: *mut CUdevice,
        pciBusId: *const ::core::ffi::c_char,
    ) -> CUresult {
        (self
            .cuDeviceGetByPCIBusId
            .as_ref()
            .expect("Expected function, got error."))(dev, pciBusId)
    }
    pub unsafe fn cuDeviceGetPCIBusId(
        &self,
        pciBusId: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuDeviceGetPCIBusId
            .as_ref()
            .expect("Expected function, got error."))(pciBusId, len, dev)
    }
    pub unsafe fn cuIpcGetEventHandle(
        &self,
        pHandle: *mut CUipcEventHandle,
        event: CUevent,
    ) -> CUresult {
        (self
            .cuIpcGetEventHandle
            .as_ref()
            .expect("Expected function, got error."))(pHandle, event)
    }
    pub unsafe fn cuIpcOpenEventHandle(
        &self,
        phEvent: *mut CUevent,
        handle: CUipcEventHandle,
    ) -> CUresult {
        (self
            .cuIpcOpenEventHandle
            .as_ref()
            .expect("Expected function, got error."))(phEvent, handle)
    }
    pub unsafe fn cuIpcGetMemHandle(
        &self,
        pHandle: *mut CUipcMemHandle,
        dptr: CUdeviceptr,
    ) -> CUresult {
        (self
            .cuIpcGetMemHandle
            .as_ref()
            .expect("Expected function, got error."))(pHandle, dptr)
    }
    pub unsafe fn cuIpcOpenMemHandle_v2(
        &self,
        pdptr: *mut CUdeviceptr,
        handle: CUipcMemHandle,
        Flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuIpcOpenMemHandle_v2
            .as_ref()
            .expect("Expected function, got error."))(pdptr, handle, Flags)
    }
    pub unsafe fn cuIpcCloseMemHandle(&self, dptr: CUdeviceptr) -> CUresult {
        (self
            .cuIpcCloseMemHandle
            .as_ref()
            .expect("Expected function, got error."))(dptr)
    }
    pub unsafe fn cuMemHostRegister_v2(
        &self,
        p: *mut ::core::ffi::c_void,
        bytesize: usize,
        Flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuMemHostRegister_v2
            .as_ref()
            .expect("Expected function, got error."))(p, bytesize, Flags)
    }
    pub unsafe fn cuMemHostUnregister(&self, p: *mut ::core::ffi::c_void) -> CUresult {
        (self
            .cuMemHostUnregister
            .as_ref()
            .expect("Expected function, got error."))(p)
    }
    pub unsafe fn cuMemcpy(
        &self,
        dst: CUdeviceptr,
        src: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult {
        (self
            .cuMemcpy
            .as_ref()
            .expect("Expected function, got error."))(dst, src, ByteCount)
    }
    pub unsafe fn cuMemcpyPeer(
        &self,
        dstDevice: CUdeviceptr,
        dstContext: CUcontext,
        srcDevice: CUdeviceptr,
        srcContext: CUcontext,
        ByteCount: usize,
    ) -> CUresult {
        (self
            .cuMemcpyPeer
            .as_ref()
            .expect("Expected function, got error."))(
            dstDevice, dstContext, srcDevice, srcContext, ByteCount,
        )
    }
    pub unsafe fn cuMemcpyHtoD_v2(
        &self,
        dstDevice: CUdeviceptr,
        srcHost: *const ::core::ffi::c_void,
        ByteCount: usize,
    ) -> CUresult {
        (self
            .cuMemcpyHtoD_v2
            .as_ref()
            .expect("Expected function, got error."))(dstDevice, srcHost, ByteCount)
    }
    pub unsafe fn cuMemcpyDtoH_v2(
        &self,
        dstHost: *mut ::core::ffi::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult {
        (self
            .cuMemcpyDtoH_v2
            .as_ref()
            .expect("Expected function, got error."))(dstHost, srcDevice, ByteCount)
    }
    pub unsafe fn cuMemcpyDtoD_v2(
        &self,
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult {
        (self
            .cuMemcpyDtoD_v2
            .as_ref()
            .expect("Expected function, got error."))(dstDevice, srcDevice, ByteCount)
    }
    pub unsafe fn cuMemcpyDtoA_v2(
        &self,
        dstArray: CUarray,
        dstOffset: usize,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
    ) -> CUresult {
        (self
            .cuMemcpyDtoA_v2
            .as_ref()
            .expect("Expected function, got error."))(
            dstArray, dstOffset, srcDevice, ByteCount
        )
    }
    pub unsafe fn cuMemcpyAtoD_v2(
        &self,
        dstDevice: CUdeviceptr,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
    ) -> CUresult {
        (self
            .cuMemcpyAtoD_v2
            .as_ref()
            .expect("Expected function, got error."))(
            dstDevice, srcArray, srcOffset, ByteCount
        )
    }
    pub unsafe fn cuMemcpyHtoA_v2(
        &self,
        dstArray: CUarray,
        dstOffset: usize,
        srcHost: *const ::core::ffi::c_void,
        ByteCount: usize,
    ) -> CUresult {
        (self
            .cuMemcpyHtoA_v2
            .as_ref()
            .expect("Expected function, got error."))(
            dstArray, dstOffset, srcHost, ByteCount
        )
    }
    pub unsafe fn cuMemcpyAtoH_v2(
        &self,
        dstHost: *mut ::core::ffi::c_void,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
    ) -> CUresult {
        (self
            .cuMemcpyAtoH_v2
            .as_ref()
            .expect("Expected function, got error."))(
            dstHost, srcArray, srcOffset, ByteCount
        )
    }
    pub unsafe fn cuMemcpyAtoA_v2(
        &self,
        dstArray: CUarray,
        dstOffset: usize,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
    ) -> CUresult {
        (self
            .cuMemcpyAtoA_v2
            .as_ref()
            .expect("Expected function, got error."))(
            dstArray, dstOffset, srcArray, srcOffset, ByteCount,
        )
    }
    pub unsafe fn cuMemcpy2D_v2(&self, pCopy: *const CUDA_MEMCPY2D) -> CUresult {
        (self
            .cuMemcpy2D_v2
            .as_ref()
            .expect("Expected function, got error."))(pCopy)
    }
    pub unsafe fn cuMemcpy2DUnaligned_v2(&self, pCopy: *const CUDA_MEMCPY2D) -> CUresult {
        (self
            .cuMemcpy2DUnaligned_v2
            .as_ref()
            .expect("Expected function, got error."))(pCopy)
    }
    pub unsafe fn cuMemcpy3D_v2(&self, pCopy: *const CUDA_MEMCPY3D) -> CUresult {
        (self
            .cuMemcpy3D_v2
            .as_ref()
            .expect("Expected function, got error."))(pCopy)
    }
    pub unsafe fn cuMemcpy3DPeer(&self, pCopy: *const CUDA_MEMCPY3D_PEER) -> CUresult {
        (self
            .cuMemcpy3DPeer
            .as_ref()
            .expect("Expected function, got error."))(pCopy)
    }
    pub unsafe fn cuMemcpyAsync(
        &self,
        dst: CUdeviceptr,
        src: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemcpyAsync
            .as_ref()
            .expect("Expected function, got error."))(dst, src, ByteCount, hStream)
    }
    pub unsafe fn cuMemcpyPeerAsync(
        &self,
        dstDevice: CUdeviceptr,
        dstContext: CUcontext,
        srcDevice: CUdeviceptr,
        srcContext: CUcontext,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemcpyPeerAsync
            .as_ref()
            .expect("Expected function, got error."))(
            dstDevice, dstContext, srcDevice, srcContext, ByteCount, hStream,
        )
    }
    pub unsafe fn cuMemcpyHtoDAsync_v2(
        &self,
        dstDevice: CUdeviceptr,
        srcHost: *const ::core::ffi::c_void,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemcpyHtoDAsync_v2
            .as_ref()
            .expect("Expected function, got error."))(dstDevice, srcHost, ByteCount, hStream)
    }
    pub unsafe fn cuMemcpyDtoHAsync_v2(
        &self,
        dstHost: *mut ::core::ffi::c_void,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemcpyDtoHAsync_v2
            .as_ref()
            .expect("Expected function, got error."))(dstHost, srcDevice, ByteCount, hStream)
    }
    pub unsafe fn cuMemcpyDtoDAsync_v2(
        &self,
        dstDevice: CUdeviceptr,
        srcDevice: CUdeviceptr,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemcpyDtoDAsync_v2
            .as_ref()
            .expect("Expected function, got error."))(
            dstDevice, srcDevice, ByteCount, hStream
        )
    }
    pub unsafe fn cuMemcpyHtoAAsync_v2(
        &self,
        dstArray: CUarray,
        dstOffset: usize,
        srcHost: *const ::core::ffi::c_void,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemcpyHtoAAsync_v2
            .as_ref()
            .expect("Expected function, got error."))(
            dstArray, dstOffset, srcHost, ByteCount, hStream,
        )
    }
    pub unsafe fn cuMemcpyAtoHAsync_v2(
        &self,
        dstHost: *mut ::core::ffi::c_void,
        srcArray: CUarray,
        srcOffset: usize,
        ByteCount: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemcpyAtoHAsync_v2
            .as_ref()
            .expect("Expected function, got error."))(
            dstHost, srcArray, srcOffset, ByteCount, hStream,
        )
    }
    pub unsafe fn cuMemcpy2DAsync_v2(
        &self,
        pCopy: *const CUDA_MEMCPY2D,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemcpy2DAsync_v2
            .as_ref()
            .expect("Expected function, got error."))(pCopy, hStream)
    }
    pub unsafe fn cuMemcpy3DAsync_v2(
        &self,
        pCopy: *const CUDA_MEMCPY3D,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemcpy3DAsync_v2
            .as_ref()
            .expect("Expected function, got error."))(pCopy, hStream)
    }
    pub unsafe fn cuMemcpy3DPeerAsync(
        &self,
        pCopy: *const CUDA_MEMCPY3D_PEER,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemcpy3DPeerAsync
            .as_ref()
            .expect("Expected function, got error."))(pCopy, hStream)
    }
    pub unsafe fn cuMemsetD8_v2(
        &self,
        dstDevice: CUdeviceptr,
        uc: ::core::ffi::c_uchar,
        N: usize,
    ) -> CUresult {
        (self
            .cuMemsetD8_v2
            .as_ref()
            .expect("Expected function, got error."))(dstDevice, uc, N)
    }
    pub unsafe fn cuMemsetD16_v2(
        &self,
        dstDevice: CUdeviceptr,
        us: ::core::ffi::c_ushort,
        N: usize,
    ) -> CUresult {
        (self
            .cuMemsetD16_v2
            .as_ref()
            .expect("Expected function, got error."))(dstDevice, us, N)
    }
    pub unsafe fn cuMemsetD32_v2(
        &self,
        dstDevice: CUdeviceptr,
        ui: ::core::ffi::c_uint,
        N: usize,
    ) -> CUresult {
        (self
            .cuMemsetD32_v2
            .as_ref()
            .expect("Expected function, got error."))(dstDevice, ui, N)
    }
    pub unsafe fn cuMemsetD2D8_v2(
        &self,
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        uc: ::core::ffi::c_uchar,
        Width: usize,
        Height: usize,
    ) -> CUresult {
        (self
            .cuMemsetD2D8_v2
            .as_ref()
            .expect("Expected function, got error."))(dstDevice, dstPitch, uc, Width, Height)
    }
    pub unsafe fn cuMemsetD2D16_v2(
        &self,
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        us: ::core::ffi::c_ushort,
        Width: usize,
        Height: usize,
    ) -> CUresult {
        (self
            .cuMemsetD2D16_v2
            .as_ref()
            .expect("Expected function, got error."))(dstDevice, dstPitch, us, Width, Height)
    }
    pub unsafe fn cuMemsetD2D32_v2(
        &self,
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        ui: ::core::ffi::c_uint,
        Width: usize,
        Height: usize,
    ) -> CUresult {
        (self
            .cuMemsetD2D32_v2
            .as_ref()
            .expect("Expected function, got error."))(dstDevice, dstPitch, ui, Width, Height)
    }
    pub unsafe fn cuMemsetD8Async(
        &self,
        dstDevice: CUdeviceptr,
        uc: ::core::ffi::c_uchar,
        N: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemsetD8Async
            .as_ref()
            .expect("Expected function, got error."))(dstDevice, uc, N, hStream)
    }
    pub unsafe fn cuMemsetD16Async(
        &self,
        dstDevice: CUdeviceptr,
        us: ::core::ffi::c_ushort,
        N: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemsetD16Async
            .as_ref()
            .expect("Expected function, got error."))(dstDevice, us, N, hStream)
    }
    pub unsafe fn cuMemsetD32Async(
        &self,
        dstDevice: CUdeviceptr,
        ui: ::core::ffi::c_uint,
        N: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemsetD32Async
            .as_ref()
            .expect("Expected function, got error."))(dstDevice, ui, N, hStream)
    }
    pub unsafe fn cuMemsetD2D8Async(
        &self,
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        uc: ::core::ffi::c_uchar,
        Width: usize,
        Height: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemsetD2D8Async
            .as_ref()
            .expect("Expected function, got error."))(
            dstDevice, dstPitch, uc, Width, Height, hStream,
        )
    }
    pub unsafe fn cuMemsetD2D16Async(
        &self,
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        us: ::core::ffi::c_ushort,
        Width: usize,
        Height: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemsetD2D16Async
            .as_ref()
            .expect("Expected function, got error."))(
            dstDevice, dstPitch, us, Width, Height, hStream,
        )
    }
    pub unsafe fn cuMemsetD2D32Async(
        &self,
        dstDevice: CUdeviceptr,
        dstPitch: usize,
        ui: ::core::ffi::c_uint,
        Width: usize,
        Height: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemsetD2D32Async
            .as_ref()
            .expect("Expected function, got error."))(
            dstDevice, dstPitch, ui, Width, Height, hStream,
        )
    }
    pub unsafe fn cuArrayCreate_v2(
        &self,
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY_DESCRIPTOR,
    ) -> CUresult {
        (self
            .cuArrayCreate_v2
            .as_ref()
            .expect("Expected function, got error."))(pHandle, pAllocateArray)
    }
    pub unsafe fn cuArrayGetDescriptor_v2(
        &self,
        pArrayDescriptor: *mut CUDA_ARRAY_DESCRIPTOR,
        hArray: CUarray,
    ) -> CUresult {
        (self
            .cuArrayGetDescriptor_v2
            .as_ref()
            .expect("Expected function, got error."))(pArrayDescriptor, hArray)
    }
    pub unsafe fn cuArrayGetSparseProperties(
        &self,
        sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
        array: CUarray,
    ) -> CUresult {
        (self
            .cuArrayGetSparseProperties
            .as_ref()
            .expect("Expected function, got error."))(sparseProperties, array)
    }
    pub unsafe fn cuMipmappedArrayGetSparseProperties(
        &self,
        sparseProperties: *mut CUDA_ARRAY_SPARSE_PROPERTIES,
        mipmap: CUmipmappedArray,
    ) -> CUresult {
        (self
            .cuMipmappedArrayGetSparseProperties
            .as_ref()
            .expect("Expected function, got error."))(sparseProperties, mipmap)
    }
    pub unsafe fn cuArrayGetMemoryRequirements(
        &self,
        memoryRequirements: *mut CUDA_ARRAY_MEMORY_REQUIREMENTS,
        array: CUarray,
        device: CUdevice,
    ) -> CUresult {
        (self
            .cuArrayGetMemoryRequirements
            .as_ref()
            .expect("Expected function, got error."))(memoryRequirements, array, device)
    }
    pub unsafe fn cuMipmappedArrayGetMemoryRequirements(
        &self,
        memoryRequirements: *mut CUDA_ARRAY_MEMORY_REQUIREMENTS,
        mipmap: CUmipmappedArray,
        device: CUdevice,
    ) -> CUresult {
        (self
            .cuMipmappedArrayGetMemoryRequirements
            .as_ref()
            .expect("Expected function, got error."))(memoryRequirements, mipmap, device)
    }
    pub unsafe fn cuArrayGetPlane(
        &self,
        pPlaneArray: *mut CUarray,
        hArray: CUarray,
        planeIdx: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuArrayGetPlane
            .as_ref()
            .expect("Expected function, got error."))(pPlaneArray, hArray, planeIdx)
    }
    pub unsafe fn cuArrayDestroy(&self, hArray: CUarray) -> CUresult {
        (self
            .cuArrayDestroy
            .as_ref()
            .expect("Expected function, got error."))(hArray)
    }
    pub unsafe fn cuArray3DCreate_v2(
        &self,
        pHandle: *mut CUarray,
        pAllocateArray: *const CUDA_ARRAY3D_DESCRIPTOR,
    ) -> CUresult {
        (self
            .cuArray3DCreate_v2
            .as_ref()
            .expect("Expected function, got error."))(pHandle, pAllocateArray)
    }
    pub unsafe fn cuArray3DGetDescriptor_v2(
        &self,
        pArrayDescriptor: *mut CUDA_ARRAY3D_DESCRIPTOR,
        hArray: CUarray,
    ) -> CUresult {
        (self
            .cuArray3DGetDescriptor_v2
            .as_ref()
            .expect("Expected function, got error."))(pArrayDescriptor, hArray)
    }
    pub unsafe fn cuMipmappedArrayCreate(
        &self,
        pHandle: *mut CUmipmappedArray,
        pMipmappedArrayDesc: *const CUDA_ARRAY3D_DESCRIPTOR,
        numMipmapLevels: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuMipmappedArrayCreate
            .as_ref()
            .expect("Expected function, got error."))(
            pHandle, pMipmappedArrayDesc, numMipmapLevels
        )
    }
    pub unsafe fn cuMipmappedArrayGetLevel(
        &self,
        pLevelArray: *mut CUarray,
        hMipmappedArray: CUmipmappedArray,
        level: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuMipmappedArrayGetLevel
            .as_ref()
            .expect("Expected function, got error."))(pLevelArray, hMipmappedArray, level)
    }
    pub unsafe fn cuMipmappedArrayDestroy(&self, hMipmappedArray: CUmipmappedArray) -> CUresult {
        (self
            .cuMipmappedArrayDestroy
            .as_ref()
            .expect("Expected function, got error."))(hMipmappedArray)
    }
    pub unsafe fn cuMemGetHandleForAddressRange(
        &self,
        handle: *mut ::core::ffi::c_void,
        dptr: CUdeviceptr,
        size: usize,
        handleType: CUmemRangeHandleType,
        flags: ::core::ffi::c_ulonglong,
    ) -> CUresult {
        (self
            .cuMemGetHandleForAddressRange
            .as_ref()
            .expect("Expected function, got error."))(handle, dptr, size, handleType, flags)
    }
    pub unsafe fn cuMemAddressReserve(
        &self,
        ptr: *mut CUdeviceptr,
        size: usize,
        alignment: usize,
        addr: CUdeviceptr,
        flags: ::core::ffi::c_ulonglong,
    ) -> CUresult {
        (self
            .cuMemAddressReserve
            .as_ref()
            .expect("Expected function, got error."))(ptr, size, alignment, addr, flags)
    }
    pub unsafe fn cuMemAddressFree(&self, ptr: CUdeviceptr, size: usize) -> CUresult {
        (self
            .cuMemAddressFree
            .as_ref()
            .expect("Expected function, got error."))(ptr, size)
    }
    pub unsafe fn cuMemCreate(
        &self,
        handle: *mut CUmemGenericAllocationHandle,
        size: usize,
        prop: *const CUmemAllocationProp,
        flags: ::core::ffi::c_ulonglong,
    ) -> CUresult {
        (self
            .cuMemCreate
            .as_ref()
            .expect("Expected function, got error."))(handle, size, prop, flags)
    }
    pub unsafe fn cuMemRelease(&self, handle: CUmemGenericAllocationHandle) -> CUresult {
        (self
            .cuMemRelease
            .as_ref()
            .expect("Expected function, got error."))(handle)
    }
    pub unsafe fn cuMemMap(
        &self,
        ptr: CUdeviceptr,
        size: usize,
        offset: usize,
        handle: CUmemGenericAllocationHandle,
        flags: ::core::ffi::c_ulonglong,
    ) -> CUresult {
        (self
            .cuMemMap
            .as_ref()
            .expect("Expected function, got error."))(ptr, size, offset, handle, flags)
    }
    pub unsafe fn cuMemMapArrayAsync(
        &self,
        mapInfoList: *mut CUarrayMapInfo,
        count: ::core::ffi::c_uint,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemMapArrayAsync
            .as_ref()
            .expect("Expected function, got error."))(mapInfoList, count, hStream)
    }
    pub unsafe fn cuMemUnmap(&self, ptr: CUdeviceptr, size: usize) -> CUresult {
        (self
            .cuMemUnmap
            .as_ref()
            .expect("Expected function, got error."))(ptr, size)
    }
    pub unsafe fn cuMemSetAccess(
        &self,
        ptr: CUdeviceptr,
        size: usize,
        desc: *const CUmemAccessDesc,
        count: usize,
    ) -> CUresult {
        (self
            .cuMemSetAccess
            .as_ref()
            .expect("Expected function, got error."))(ptr, size, desc, count)
    }
    pub unsafe fn cuMemGetAccess(
        &self,
        flags: *mut ::core::ffi::c_ulonglong,
        location: *const CUmemLocation,
        ptr: CUdeviceptr,
    ) -> CUresult {
        (self
            .cuMemGetAccess
            .as_ref()
            .expect("Expected function, got error."))(flags, location, ptr)
    }
    pub unsafe fn cuMemExportToShareableHandle(
        &self,
        shareableHandle: *mut ::core::ffi::c_void,
        handle: CUmemGenericAllocationHandle,
        handleType: CUmemAllocationHandleType,
        flags: ::core::ffi::c_ulonglong,
    ) -> CUresult {
        (self
            .cuMemExportToShareableHandle
            .as_ref()
            .expect("Expected function, got error."))(
            shareableHandle, handle, handleType, flags
        )
    }
    pub unsafe fn cuMemImportFromShareableHandle(
        &self,
        handle: *mut CUmemGenericAllocationHandle,
        osHandle: *mut ::core::ffi::c_void,
        shHandleType: CUmemAllocationHandleType,
    ) -> CUresult {
        (self
            .cuMemImportFromShareableHandle
            .as_ref()
            .expect("Expected function, got error."))(handle, osHandle, shHandleType)
    }
    pub unsafe fn cuMemGetAllocationGranularity(
        &self,
        granularity: *mut usize,
        prop: *const CUmemAllocationProp,
        option: CUmemAllocationGranularity_flags,
    ) -> CUresult {
        (self
            .cuMemGetAllocationGranularity
            .as_ref()
            .expect("Expected function, got error."))(granularity, prop, option)
    }
    pub unsafe fn cuMemGetAllocationPropertiesFromHandle(
        &self,
        prop: *mut CUmemAllocationProp,
        handle: CUmemGenericAllocationHandle,
    ) -> CUresult {
        (self
            .cuMemGetAllocationPropertiesFromHandle
            .as_ref()
            .expect("Expected function, got error."))(prop, handle)
    }
    pub unsafe fn cuMemRetainAllocationHandle(
        &self,
        handle: *mut CUmemGenericAllocationHandle,
        addr: *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuMemRetainAllocationHandle
            .as_ref()
            .expect("Expected function, got error."))(handle, addr)
    }
    pub unsafe fn cuMemFreeAsync(&self, dptr: CUdeviceptr, hStream: CUstream) -> CUresult {
        (self
            .cuMemFreeAsync
            .as_ref()
            .expect("Expected function, got error."))(dptr, hStream)
    }
    pub unsafe fn cuMemAllocAsync(
        &self,
        dptr: *mut CUdeviceptr,
        bytesize: usize,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemAllocAsync
            .as_ref()
            .expect("Expected function, got error."))(dptr, bytesize, hStream)
    }
    pub unsafe fn cuMemPoolTrimTo(&self, pool: CUmemoryPool, minBytesToKeep: usize) -> CUresult {
        (self
            .cuMemPoolTrimTo
            .as_ref()
            .expect("Expected function, got error."))(pool, minBytesToKeep)
    }
    pub unsafe fn cuMemPoolSetAttribute(
        &self,
        pool: CUmemoryPool,
        attr: CUmemPool_attribute,
        value: *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuMemPoolSetAttribute
            .as_ref()
            .expect("Expected function, got error."))(pool, attr, value)
    }
    pub unsafe fn cuMemPoolGetAttribute(
        &self,
        pool: CUmemoryPool,
        attr: CUmemPool_attribute,
        value: *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuMemPoolGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(pool, attr, value)
    }
    pub unsafe fn cuMemPoolSetAccess(
        &self,
        pool: CUmemoryPool,
        map: *const CUmemAccessDesc,
        count: usize,
    ) -> CUresult {
        (self
            .cuMemPoolSetAccess
            .as_ref()
            .expect("Expected function, got error."))(pool, map, count)
    }
    pub unsafe fn cuMemPoolGetAccess(
        &self,
        flags: *mut CUmemAccess_flags,
        memPool: CUmemoryPool,
        location: *mut CUmemLocation,
    ) -> CUresult {
        (self
            .cuMemPoolGetAccess
            .as_ref()
            .expect("Expected function, got error."))(flags, memPool, location)
    }
    pub unsafe fn cuMemPoolCreate(
        &self,
        pool: *mut CUmemoryPool,
        poolProps: *const CUmemPoolProps,
    ) -> CUresult {
        (self
            .cuMemPoolCreate
            .as_ref()
            .expect("Expected function, got error."))(pool, poolProps)
    }
    pub unsafe fn cuMemPoolDestroy(&self, pool: CUmemoryPool) -> CUresult {
        (self
            .cuMemPoolDestroy
            .as_ref()
            .expect("Expected function, got error."))(pool)
    }
    pub unsafe fn cuMemAllocFromPoolAsync(
        &self,
        dptr: *mut CUdeviceptr,
        bytesize: usize,
        pool: CUmemoryPool,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemAllocFromPoolAsync
            .as_ref()
            .expect("Expected function, got error."))(dptr, bytesize, pool, hStream)
    }
    pub unsafe fn cuMemPoolExportToShareableHandle(
        &self,
        handle_out: *mut ::core::ffi::c_void,
        pool: CUmemoryPool,
        handleType: CUmemAllocationHandleType,
        flags: ::core::ffi::c_ulonglong,
    ) -> CUresult {
        (self
            .cuMemPoolExportToShareableHandle
            .as_ref()
            .expect("Expected function, got error."))(handle_out, pool, handleType, flags)
    }
    pub unsafe fn cuMemPoolImportFromShareableHandle(
        &self,
        pool_out: *mut CUmemoryPool,
        handle: *mut ::core::ffi::c_void,
        handleType: CUmemAllocationHandleType,
        flags: ::core::ffi::c_ulonglong,
    ) -> CUresult {
        (self
            .cuMemPoolImportFromShareableHandle
            .as_ref()
            .expect("Expected function, got error."))(pool_out, handle, handleType, flags)
    }
    pub unsafe fn cuMemPoolExportPointer(
        &self,
        shareData_out: *mut CUmemPoolPtrExportData,
        ptr: CUdeviceptr,
    ) -> CUresult {
        (self
            .cuMemPoolExportPointer
            .as_ref()
            .expect("Expected function, got error."))(shareData_out, ptr)
    }
    pub unsafe fn cuMemPoolImportPointer(
        &self,
        ptr_out: *mut CUdeviceptr,
        pool: CUmemoryPool,
        shareData: *mut CUmemPoolPtrExportData,
    ) -> CUresult {
        (self
            .cuMemPoolImportPointer
            .as_ref()
            .expect("Expected function, got error."))(ptr_out, pool, shareData)
    }
    pub unsafe fn cuMulticastCreate(
        &self,
        mcHandle: *mut CUmemGenericAllocationHandle,
        prop: *const CUmulticastObjectProp,
    ) -> CUresult {
        (self
            .cuMulticastCreate
            .as_ref()
            .expect("Expected function, got error."))(mcHandle, prop)
    }
    pub unsafe fn cuMulticastAddDevice(
        &self,
        mcHandle: CUmemGenericAllocationHandle,
        dev: CUdevice,
    ) -> CUresult {
        (self
            .cuMulticastAddDevice
            .as_ref()
            .expect("Expected function, got error."))(mcHandle, dev)
    }
    pub unsafe fn cuMulticastBindMem(
        &self,
        mcHandle: CUmemGenericAllocationHandle,
        mcOffset: usize,
        memHandle: CUmemGenericAllocationHandle,
        memOffset: usize,
        size: usize,
        flags: ::core::ffi::c_ulonglong,
    ) -> CUresult {
        (self
            .cuMulticastBindMem
            .as_ref()
            .expect("Expected function, got error."))(
            mcHandle, mcOffset, memHandle, memOffset, size, flags,
        )
    }
    pub unsafe fn cuMulticastBindAddr(
        &self,
        mcHandle: CUmemGenericAllocationHandle,
        mcOffset: usize,
        memptr: CUdeviceptr,
        size: usize,
        flags: ::core::ffi::c_ulonglong,
    ) -> CUresult {
        (self
            .cuMulticastBindAddr
            .as_ref()
            .expect("Expected function, got error."))(
            mcHandle, mcOffset, memptr, size, flags
        )
    }
    pub unsafe fn cuMulticastUnbind(
        &self,
        mcHandle: CUmemGenericAllocationHandle,
        dev: CUdevice,
        mcOffset: usize,
        size: usize,
    ) -> CUresult {
        (self
            .cuMulticastUnbind
            .as_ref()
            .expect("Expected function, got error."))(mcHandle, dev, mcOffset, size)
    }
    pub unsafe fn cuMulticastGetGranularity(
        &self,
        granularity: *mut usize,
        prop: *const CUmulticastObjectProp,
        option: CUmulticastGranularity_flags,
    ) -> CUresult {
        (self
            .cuMulticastGetGranularity
            .as_ref()
            .expect("Expected function, got error."))(granularity, prop, option)
    }
    pub unsafe fn cuPointerGetAttribute(
        &self,
        data: *mut ::core::ffi::c_void,
        attribute: CUpointer_attribute,
        ptr: CUdeviceptr,
    ) -> CUresult {
        (self
            .cuPointerGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(data, attribute, ptr)
    }
    pub unsafe fn cuMemPrefetchAsync(
        &self,
        devPtr: CUdeviceptr,
        count: usize,
        dstDevice: CUdevice,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemPrefetchAsync
            .as_ref()
            .expect("Expected function, got error."))(devPtr, count, dstDevice, hStream)
    }
    pub unsafe fn cuMemPrefetchAsync_v2(
        &self,
        devPtr: CUdeviceptr,
        count: usize,
        location: CUmemLocation,
        flags: ::core::ffi::c_uint,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuMemPrefetchAsync_v2
            .as_ref()
            .expect("Expected function, got error."))(
            devPtr, count, location, flags, hStream
        )
    }
    pub unsafe fn cuMemAdvise(
        &self,
        devPtr: CUdeviceptr,
        count: usize,
        advice: CUmem_advise,
        device: CUdevice,
    ) -> CUresult {
        (self
            .cuMemAdvise
            .as_ref()
            .expect("Expected function, got error."))(devPtr, count, advice, device)
    }
    pub unsafe fn cuMemAdvise_v2(
        &self,
        devPtr: CUdeviceptr,
        count: usize,
        advice: CUmem_advise,
        location: CUmemLocation,
    ) -> CUresult {
        (self
            .cuMemAdvise_v2
            .as_ref()
            .expect("Expected function, got error."))(devPtr, count, advice, location)
    }
    pub unsafe fn cuMemRangeGetAttribute(
        &self,
        data: *mut ::core::ffi::c_void,
        dataSize: usize,
        attribute: CUmem_range_attribute,
        devPtr: CUdeviceptr,
        count: usize,
    ) -> CUresult {
        (self
            .cuMemRangeGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(
            data, dataSize, attribute, devPtr, count
        )
    }
    pub unsafe fn cuMemRangeGetAttributes(
        &self,
        data: *mut *mut ::core::ffi::c_void,
        dataSizes: *mut usize,
        attributes: *mut CUmem_range_attribute,
        numAttributes: usize,
        devPtr: CUdeviceptr,
        count: usize,
    ) -> CUresult {
        (self
            .cuMemRangeGetAttributes
            .as_ref()
            .expect("Expected function, got error."))(
            data,
            dataSizes,
            attributes,
            numAttributes,
            devPtr,
            count,
        )
    }
    pub unsafe fn cuPointerSetAttribute(
        &self,
        value: *const ::core::ffi::c_void,
        attribute: CUpointer_attribute,
        ptr: CUdeviceptr,
    ) -> CUresult {
        (self
            .cuPointerSetAttribute
            .as_ref()
            .expect("Expected function, got error."))(value, attribute, ptr)
    }
    pub unsafe fn cuPointerGetAttributes(
        &self,
        numAttributes: ::core::ffi::c_uint,
        attributes: *mut CUpointer_attribute,
        data: *mut *mut ::core::ffi::c_void,
        ptr: CUdeviceptr,
    ) -> CUresult {
        (self
            .cuPointerGetAttributes
            .as_ref()
            .expect("Expected function, got error."))(numAttributes, attributes, data, ptr)
    }
    pub unsafe fn cuStreamCreate(
        &self,
        phStream: *mut CUstream,
        Flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuStreamCreate
            .as_ref()
            .expect("Expected function, got error."))(phStream, Flags)
    }
    pub unsafe fn cuStreamCreateWithPriority(
        &self,
        phStream: *mut CUstream,
        flags: ::core::ffi::c_uint,
        priority: ::core::ffi::c_int,
    ) -> CUresult {
        (self
            .cuStreamCreateWithPriority
            .as_ref()
            .expect("Expected function, got error."))(phStream, flags, priority)
    }
    pub unsafe fn cuStreamGetPriority(
        &self,
        hStream: CUstream,
        priority: *mut ::core::ffi::c_int,
    ) -> CUresult {
        (self
            .cuStreamGetPriority
            .as_ref()
            .expect("Expected function, got error."))(hStream, priority)
    }
    pub unsafe fn cuStreamGetFlags(
        &self,
        hStream: CUstream,
        flags: *mut ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuStreamGetFlags
            .as_ref()
            .expect("Expected function, got error."))(hStream, flags)
    }
    pub unsafe fn cuStreamGetId(
        &self,
        hStream: CUstream,
        streamId: *mut ::core::ffi::c_ulonglong,
    ) -> CUresult {
        (self
            .cuStreamGetId
            .as_ref()
            .expect("Expected function, got error."))(hStream, streamId)
    }
    pub unsafe fn cuStreamGetCtx(&self, hStream: CUstream, pctx: *mut CUcontext) -> CUresult {
        (self
            .cuStreamGetCtx
            .as_ref()
            .expect("Expected function, got error."))(hStream, pctx)
    }
    pub unsafe fn cuStreamWaitEvent(
        &self,
        hStream: CUstream,
        hEvent: CUevent,
        Flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuStreamWaitEvent
            .as_ref()
            .expect("Expected function, got error."))(hStream, hEvent, Flags)
    }
    pub unsafe fn cuStreamAddCallback(
        &self,
        hStream: CUstream,
        callback: CUstreamCallback,
        userData: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuStreamAddCallback
            .as_ref()
            .expect("Expected function, got error."))(hStream, callback, userData, flags)
    }
    pub unsafe fn cuStreamBeginCapture_v2(
        &self,
        hStream: CUstream,
        mode: CUstreamCaptureMode,
    ) -> CUresult {
        (self
            .cuStreamBeginCapture_v2
            .as_ref()
            .expect("Expected function, got error."))(hStream, mode)
    }
    pub unsafe fn cuStreamBeginCaptureToGraph(
        &self,
        hStream: CUstream,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        dependencyData: *const CUgraphEdgeData,
        numDependencies: usize,
        mode: CUstreamCaptureMode,
    ) -> CUresult {
        (self
            .cuStreamBeginCaptureToGraph
            .as_ref()
            .expect("Expected function, got error."))(
            hStream,
            hGraph,
            dependencies,
            dependencyData,
            numDependencies,
            mode,
        )
    }
    pub unsafe fn cuThreadExchangeStreamCaptureMode(
        &self,
        mode: *mut CUstreamCaptureMode,
    ) -> CUresult {
        (self
            .cuThreadExchangeStreamCaptureMode
            .as_ref()
            .expect("Expected function, got error."))(mode)
    }
    pub unsafe fn cuStreamEndCapture(&self, hStream: CUstream, phGraph: *mut CUgraph) -> CUresult {
        (self
            .cuStreamEndCapture
            .as_ref()
            .expect("Expected function, got error."))(hStream, phGraph)
    }
    pub unsafe fn cuStreamIsCapturing(
        &self,
        hStream: CUstream,
        captureStatus: *mut CUstreamCaptureStatus,
    ) -> CUresult {
        (self
            .cuStreamIsCapturing
            .as_ref()
            .expect("Expected function, got error."))(hStream, captureStatus)
    }
    pub unsafe fn cuStreamGetCaptureInfo_v2(
        &self,
        hStream: CUstream,
        captureStatus_out: *mut CUstreamCaptureStatus,
        id_out: *mut cuuint64_t,
        graph_out: *mut CUgraph,
        dependencies_out: *mut *const CUgraphNode,
        numDependencies_out: *mut usize,
    ) -> CUresult {
        (self
            .cuStreamGetCaptureInfo_v2
            .as_ref()
            .expect("Expected function, got error."))(
            hStream,
            captureStatus_out,
            id_out,
            graph_out,
            dependencies_out,
            numDependencies_out,
        )
    }
    pub unsafe fn cuStreamGetCaptureInfo_v3(
        &self,
        hStream: CUstream,
        captureStatus_out: *mut CUstreamCaptureStatus,
        id_out: *mut cuuint64_t,
        graph_out: *mut CUgraph,
        dependencies_out: *mut *const CUgraphNode,
        edgeData_out: *mut *const CUgraphEdgeData,
        numDependencies_out: *mut usize,
    ) -> CUresult {
        (self
            .cuStreamGetCaptureInfo_v3
            .as_ref()
            .expect("Expected function, got error."))(
            hStream,
            captureStatus_out,
            id_out,
            graph_out,
            dependencies_out,
            edgeData_out,
            numDependencies_out,
        )
    }
    pub unsafe fn cuStreamUpdateCaptureDependencies(
        &self,
        hStream: CUstream,
        dependencies: *mut CUgraphNode,
        numDependencies: usize,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuStreamUpdateCaptureDependencies
            .as_ref()
            .expect("Expected function, got error."))(
            hStream, dependencies, numDependencies, flags
        )
    }
    pub unsafe fn cuStreamUpdateCaptureDependencies_v2(
        &self,
        hStream: CUstream,
        dependencies: *mut CUgraphNode,
        dependencyData: *const CUgraphEdgeData,
        numDependencies: usize,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuStreamUpdateCaptureDependencies_v2
            .as_ref()
            .expect("Expected function, got error."))(
            hStream,
            dependencies,
            dependencyData,
            numDependencies,
            flags,
        )
    }
    pub unsafe fn cuStreamAttachMemAsync(
        &self,
        hStream: CUstream,
        dptr: CUdeviceptr,
        length: usize,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuStreamAttachMemAsync
            .as_ref()
            .expect("Expected function, got error."))(hStream, dptr, length, flags)
    }
    pub unsafe fn cuStreamQuery(&self, hStream: CUstream) -> CUresult {
        (self
            .cuStreamQuery
            .as_ref()
            .expect("Expected function, got error."))(hStream)
    }
    pub unsafe fn cuStreamSynchronize(&self, hStream: CUstream) -> CUresult {
        (self
            .cuStreamSynchronize
            .as_ref()
            .expect("Expected function, got error."))(hStream)
    }
    pub unsafe fn cuStreamDestroy_v2(&self, hStream: CUstream) -> CUresult {
        (self
            .cuStreamDestroy_v2
            .as_ref()
            .expect("Expected function, got error."))(hStream)
    }
    pub unsafe fn cuStreamCopyAttributes(&self, dst: CUstream, src: CUstream) -> CUresult {
        (self
            .cuStreamCopyAttributes
            .as_ref()
            .expect("Expected function, got error."))(dst, src)
    }
    pub unsafe fn cuStreamGetAttribute(
        &self,
        hStream: CUstream,
        attr: CUstreamAttrID,
        value_out: *mut CUstreamAttrValue,
    ) -> CUresult {
        (self
            .cuStreamGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(hStream, attr, value_out)
    }
    pub unsafe fn cuStreamSetAttribute(
        &self,
        hStream: CUstream,
        attr: CUstreamAttrID,
        value: *const CUstreamAttrValue,
    ) -> CUresult {
        (self
            .cuStreamSetAttribute
            .as_ref()
            .expect("Expected function, got error."))(hStream, attr, value)
    }
    pub unsafe fn cuEventCreate(
        &self,
        phEvent: *mut CUevent,
        Flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuEventCreate
            .as_ref()
            .expect("Expected function, got error."))(phEvent, Flags)
    }
    pub unsafe fn cuEventRecord(&self, hEvent: CUevent, hStream: CUstream) -> CUresult {
        (self
            .cuEventRecord
            .as_ref()
            .expect("Expected function, got error."))(hEvent, hStream)
    }
    pub unsafe fn cuEventRecordWithFlags(
        &self,
        hEvent: CUevent,
        hStream: CUstream,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuEventRecordWithFlags
            .as_ref()
            .expect("Expected function, got error."))(hEvent, hStream, flags)
    }
    pub unsafe fn cuEventQuery(&self, hEvent: CUevent) -> CUresult {
        (self
            .cuEventQuery
            .as_ref()
            .expect("Expected function, got error."))(hEvent)
    }
    pub unsafe fn cuEventSynchronize(&self, hEvent: CUevent) -> CUresult {
        (self
            .cuEventSynchronize
            .as_ref()
            .expect("Expected function, got error."))(hEvent)
    }
    pub unsafe fn cuEventDestroy_v2(&self, hEvent: CUevent) -> CUresult {
        (self
            .cuEventDestroy_v2
            .as_ref()
            .expect("Expected function, got error."))(hEvent)
    }
    pub unsafe fn cuEventElapsedTime(
        &self,
        pMilliseconds: *mut f32,
        hStart: CUevent,
        hEnd: CUevent,
    ) -> CUresult {
        (self
            .cuEventElapsedTime
            .as_ref()
            .expect("Expected function, got error."))(pMilliseconds, hStart, hEnd)
    }
    pub unsafe fn cuImportExternalMemory(
        &self,
        extMem_out: *mut CUexternalMemory,
        memHandleDesc: *const CUDA_EXTERNAL_MEMORY_HANDLE_DESC,
    ) -> CUresult {
        (self
            .cuImportExternalMemory
            .as_ref()
            .expect("Expected function, got error."))(extMem_out, memHandleDesc)
    }
    pub unsafe fn cuExternalMemoryGetMappedBuffer(
        &self,
        devPtr: *mut CUdeviceptr,
        extMem: CUexternalMemory,
        bufferDesc: *const CUDA_EXTERNAL_MEMORY_BUFFER_DESC,
    ) -> CUresult {
        (self
            .cuExternalMemoryGetMappedBuffer
            .as_ref()
            .expect("Expected function, got error."))(devPtr, extMem, bufferDesc)
    }
    pub unsafe fn cuExternalMemoryGetMappedMipmappedArray(
        &self,
        mipmap: *mut CUmipmappedArray,
        extMem: CUexternalMemory,
        mipmapDesc: *const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC,
    ) -> CUresult {
        (self
            .cuExternalMemoryGetMappedMipmappedArray
            .as_ref()
            .expect("Expected function, got error."))(mipmap, extMem, mipmapDesc)
    }
    pub unsafe fn cuDestroyExternalMemory(&self, extMem: CUexternalMemory) -> CUresult {
        (self
            .cuDestroyExternalMemory
            .as_ref()
            .expect("Expected function, got error."))(extMem)
    }
    pub unsafe fn cuImportExternalSemaphore(
        &self,
        extSem_out: *mut CUexternalSemaphore,
        semHandleDesc: *const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC,
    ) -> CUresult {
        (self
            .cuImportExternalSemaphore
            .as_ref()
            .expect("Expected function, got error."))(extSem_out, semHandleDesc)
    }
    pub unsafe fn cuSignalExternalSemaphoresAsync(
        &self,
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,
        numExtSems: ::core::ffi::c_uint,
        stream: CUstream,
    ) -> CUresult {
        (self
            .cuSignalExternalSemaphoresAsync
            .as_ref()
            .expect("Expected function, got error."))(
            extSemArray, paramsArray, numExtSems, stream
        )
    }
    pub unsafe fn cuWaitExternalSemaphoresAsync(
        &self,
        extSemArray: *const CUexternalSemaphore,
        paramsArray: *const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,
        numExtSems: ::core::ffi::c_uint,
        stream: CUstream,
    ) -> CUresult {
        (self
            .cuWaitExternalSemaphoresAsync
            .as_ref()
            .expect("Expected function, got error."))(
            extSemArray, paramsArray, numExtSems, stream
        )
    }
    pub unsafe fn cuDestroyExternalSemaphore(&self, extSem: CUexternalSemaphore) -> CUresult {
        (self
            .cuDestroyExternalSemaphore
            .as_ref()
            .expect("Expected function, got error."))(extSem)
    }
    pub unsafe fn cuStreamWaitValue32_v2(
        &self,
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuStreamWaitValue32_v2
            .as_ref()
            .expect("Expected function, got error."))(stream, addr, value, flags)
    }
    pub unsafe fn cuStreamWaitValue64_v2(
        &self,
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuStreamWaitValue64_v2
            .as_ref()
            .expect("Expected function, got error."))(stream, addr, value, flags)
    }
    pub unsafe fn cuStreamWriteValue32_v2(
        &self,
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint32_t,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuStreamWriteValue32_v2
            .as_ref()
            .expect("Expected function, got error."))(stream, addr, value, flags)
    }
    pub unsafe fn cuStreamWriteValue64_v2(
        &self,
        stream: CUstream,
        addr: CUdeviceptr,
        value: cuuint64_t,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuStreamWriteValue64_v2
            .as_ref()
            .expect("Expected function, got error."))(stream, addr, value, flags)
    }
    pub unsafe fn cuStreamBatchMemOp_v2(
        &self,
        stream: CUstream,
        count: ::core::ffi::c_uint,
        paramArray: *mut CUstreamBatchMemOpParams,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuStreamBatchMemOp_v2
            .as_ref()
            .expect("Expected function, got error."))(stream, count, paramArray, flags)
    }
    pub unsafe fn cuFuncGetAttribute(
        &self,
        pi: *mut ::core::ffi::c_int,
        attrib: CUfunction_attribute,
        hfunc: CUfunction,
    ) -> CUresult {
        (self
            .cuFuncGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(pi, attrib, hfunc)
    }
    pub unsafe fn cuFuncSetAttribute(
        &self,
        hfunc: CUfunction,
        attrib: CUfunction_attribute,
        value: ::core::ffi::c_int,
    ) -> CUresult {
        (self
            .cuFuncSetAttribute
            .as_ref()
            .expect("Expected function, got error."))(hfunc, attrib, value)
    }
    pub unsafe fn cuFuncSetCacheConfig(&self, hfunc: CUfunction, config: CUfunc_cache) -> CUresult {
        (self
            .cuFuncSetCacheConfig
            .as_ref()
            .expect("Expected function, got error."))(hfunc, config)
    }
    pub unsafe fn cuFuncSetSharedMemConfig(
        &self,
        hfunc: CUfunction,
        config: CUsharedconfig,
    ) -> CUresult {
        (self
            .cuFuncSetSharedMemConfig
            .as_ref()
            .expect("Expected function, got error."))(hfunc, config)
    }
    pub unsafe fn cuFuncGetModule(&self, hmod: *mut CUmodule, hfunc: CUfunction) -> CUresult {
        (self
            .cuFuncGetModule
            .as_ref()
            .expect("Expected function, got error."))(hmod, hfunc)
    }
    pub unsafe fn cuFuncGetName(
        &self,
        name: *mut *const ::core::ffi::c_char,
        hfunc: CUfunction,
    ) -> CUresult {
        (self
            .cuFuncGetName
            .as_ref()
            .expect("Expected function, got error."))(name, hfunc)
    }
    pub unsafe fn cuLaunchKernel(
        &self,
        f: CUfunction,
        gridDimX: ::core::ffi::c_uint,
        gridDimY: ::core::ffi::c_uint,
        gridDimZ: ::core::ffi::c_uint,
        blockDimX: ::core::ffi::c_uint,
        blockDimY: ::core::ffi::c_uint,
        blockDimZ: ::core::ffi::c_uint,
        sharedMemBytes: ::core::ffi::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::core::ffi::c_void,
        extra: *mut *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuLaunchKernel
            .as_ref()
            .expect("Expected function, got error."))(
            f,
            gridDimX,
            gridDimY,
            gridDimZ,
            blockDimX,
            blockDimY,
            blockDimZ,
            sharedMemBytes,
            hStream,
            kernelParams,
            extra,
        )
    }
    pub unsafe fn cuLaunchKernelEx(
        &self,
        config: *const CUlaunchConfig,
        f: CUfunction,
        kernelParams: *mut *mut ::core::ffi::c_void,
        extra: *mut *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuLaunchKernelEx
            .as_ref()
            .expect("Expected function, got error."))(config, f, kernelParams, extra)
    }
    pub unsafe fn cuLaunchCooperativeKernel(
        &self,
        f: CUfunction,
        gridDimX: ::core::ffi::c_uint,
        gridDimY: ::core::ffi::c_uint,
        gridDimZ: ::core::ffi::c_uint,
        blockDimX: ::core::ffi::c_uint,
        blockDimY: ::core::ffi::c_uint,
        blockDimZ: ::core::ffi::c_uint,
        sharedMemBytes: ::core::ffi::c_uint,
        hStream: CUstream,
        kernelParams: *mut *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuLaunchCooperativeKernel
            .as_ref()
            .expect("Expected function, got error."))(
            f,
            gridDimX,
            gridDimY,
            gridDimZ,
            blockDimX,
            blockDimY,
            blockDimZ,
            sharedMemBytes,
            hStream,
            kernelParams,
        )
    }
    pub unsafe fn cuLaunchCooperativeKernelMultiDevice(
        &self,
        launchParamsList: *mut CUDA_LAUNCH_PARAMS,
        numDevices: ::core::ffi::c_uint,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuLaunchCooperativeKernelMultiDevice
            .as_ref()
            .expect("Expected function, got error."))(launchParamsList, numDevices, flags)
    }
    pub unsafe fn cuLaunchHostFunc(
        &self,
        hStream: CUstream,
        fn_: CUhostFn,
        userData: *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuLaunchHostFunc
            .as_ref()
            .expect("Expected function, got error."))(hStream, fn_, userData)
    }
    pub unsafe fn cuFuncSetBlockShape(
        &self,
        hfunc: CUfunction,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        z: ::core::ffi::c_int,
    ) -> CUresult {
        (self
            .cuFuncSetBlockShape
            .as_ref()
            .expect("Expected function, got error."))(hfunc, x, y, z)
    }
    pub unsafe fn cuFuncSetSharedSize(
        &self,
        hfunc: CUfunction,
        bytes: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuFuncSetSharedSize
            .as_ref()
            .expect("Expected function, got error."))(hfunc, bytes)
    }
    pub unsafe fn cuParamSetSize(
        &self,
        hfunc: CUfunction,
        numbytes: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuParamSetSize
            .as_ref()
            .expect("Expected function, got error."))(hfunc, numbytes)
    }
    pub unsafe fn cuParamSeti(
        &self,
        hfunc: CUfunction,
        offset: ::core::ffi::c_int,
        value: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuParamSeti
            .as_ref()
            .expect("Expected function, got error."))(hfunc, offset, value)
    }
    pub unsafe fn cuParamSetf(
        &self,
        hfunc: CUfunction,
        offset: ::core::ffi::c_int,
        value: f32,
    ) -> CUresult {
        (self
            .cuParamSetf
            .as_ref()
            .expect("Expected function, got error."))(hfunc, offset, value)
    }
    pub unsafe fn cuParamSetv(
        &self,
        hfunc: CUfunction,
        offset: ::core::ffi::c_int,
        ptr: *mut ::core::ffi::c_void,
        numbytes: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuParamSetv
            .as_ref()
            .expect("Expected function, got error."))(hfunc, offset, ptr, numbytes)
    }
    pub unsafe fn cuLaunch(&self, f: CUfunction) -> CUresult {
        (self
            .cuLaunch
            .as_ref()
            .expect("Expected function, got error."))(f)
    }
    pub unsafe fn cuLaunchGrid(
        &self,
        f: CUfunction,
        grid_width: ::core::ffi::c_int,
        grid_height: ::core::ffi::c_int,
    ) -> CUresult {
        (self
            .cuLaunchGrid
            .as_ref()
            .expect("Expected function, got error."))(f, grid_width, grid_height)
    }
    pub unsafe fn cuLaunchGridAsync(
        &self,
        f: CUfunction,
        grid_width: ::core::ffi::c_int,
        grid_height: ::core::ffi::c_int,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuLaunchGridAsync
            .as_ref()
            .expect("Expected function, got error."))(f, grid_width, grid_height, hStream)
    }
    pub unsafe fn cuParamSetTexRef(
        &self,
        hfunc: CUfunction,
        texunit: ::core::ffi::c_int,
        hTexRef: CUtexref,
    ) -> CUresult {
        (self
            .cuParamSetTexRef
            .as_ref()
            .expect("Expected function, got error."))(hfunc, texunit, hTexRef)
    }
    pub unsafe fn cuGraphCreate(
        &self,
        phGraph: *mut CUgraph,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuGraphCreate
            .as_ref()
            .expect("Expected function, got error."))(phGraph, flags)
    }
    pub unsafe fn cuGraphAddKernelNode_v2(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphAddKernelNode_v2
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
            nodeParams,
        )
    }
    pub unsafe fn cuGraphKernelNodeGetParams_v2(
        &self,
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphKernelNodeGetParams_v2
            .as_ref()
            .expect("Expected function, got error."))(hNode, nodeParams)
    }
    pub unsafe fn cuGraphKernelNodeSetParams_v2(
        &self,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphKernelNodeSetParams_v2
            .as_ref()
            .expect("Expected function, got error."))(hNode, nodeParams)
    }
    pub unsafe fn cuGraphAddMemcpyNode(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        copyParams: *const CUDA_MEMCPY3D,
        ctx: CUcontext,
    ) -> CUresult {
        (self
            .cuGraphAddMemcpyNode
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
            copyParams,
            ctx,
        )
    }
    pub unsafe fn cuGraphMemcpyNodeGetParams(
        &self,
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_MEMCPY3D,
    ) -> CUresult {
        (self
            .cuGraphMemcpyNodeGetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, nodeParams)
    }
    pub unsafe fn cuGraphMemcpyNodeSetParams(
        &self,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_MEMCPY3D,
    ) -> CUresult {
        (self
            .cuGraphMemcpyNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, nodeParams)
    }
    pub unsafe fn cuGraphAddMemsetNode(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
        ctx: CUcontext,
    ) -> CUresult {
        (self
            .cuGraphAddMemsetNode
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
            memsetParams,
            ctx,
        )
    }
    pub unsafe fn cuGraphMemsetNodeGetParams(
        &self,
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_MEMSET_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphMemsetNodeGetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, nodeParams)
    }
    pub unsafe fn cuGraphMemsetNodeSetParams(
        &self,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_MEMSET_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphMemsetNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, nodeParams)
    }
    pub unsafe fn cuGraphAddHostNode(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphAddHostNode
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
            nodeParams,
        )
    }
    pub unsafe fn cuGraphHostNodeGetParams(
        &self,
        hNode: CUgraphNode,
        nodeParams: *mut CUDA_HOST_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphHostNodeGetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, nodeParams)
    }
    pub unsafe fn cuGraphHostNodeSetParams(
        &self,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphHostNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, nodeParams)
    }
    pub unsafe fn cuGraphAddChildGraphNode(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        childGraph: CUgraph,
    ) -> CUresult {
        (self
            .cuGraphAddChildGraphNode
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
            childGraph,
        )
    }
    pub unsafe fn cuGraphChildGraphNodeGetGraph(
        &self,
        hNode: CUgraphNode,
        phGraph: *mut CUgraph,
    ) -> CUresult {
        (self
            .cuGraphChildGraphNodeGetGraph
            .as_ref()
            .expect("Expected function, got error."))(hNode, phGraph)
    }
    pub unsafe fn cuGraphAddEmptyNode(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
    ) -> CUresult {
        (self
            .cuGraphAddEmptyNode
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
        )
    }
    pub unsafe fn cuGraphAddEventRecordNode(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        event: CUevent,
    ) -> CUresult {
        (self
            .cuGraphAddEventRecordNode
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
            event,
        )
    }
    pub unsafe fn cuGraphEventRecordNodeGetEvent(
        &self,
        hNode: CUgraphNode,
        event_out: *mut CUevent,
    ) -> CUresult {
        (self
            .cuGraphEventRecordNodeGetEvent
            .as_ref()
            .expect("Expected function, got error."))(hNode, event_out)
    }
    pub unsafe fn cuGraphEventRecordNodeSetEvent(
        &self,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult {
        (self
            .cuGraphEventRecordNodeSetEvent
            .as_ref()
            .expect("Expected function, got error."))(hNode, event)
    }
    pub unsafe fn cuGraphAddEventWaitNode(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        event: CUevent,
    ) -> CUresult {
        (self
            .cuGraphAddEventWaitNode
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
            event,
        )
    }
    pub unsafe fn cuGraphEventWaitNodeGetEvent(
        &self,
        hNode: CUgraphNode,
        event_out: *mut CUevent,
    ) -> CUresult {
        (self
            .cuGraphEventWaitNodeGetEvent
            .as_ref()
            .expect("Expected function, got error."))(hNode, event_out)
    }
    pub unsafe fn cuGraphEventWaitNodeSetEvent(
        &self,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult {
        (self
            .cuGraphEventWaitNodeSetEvent
            .as_ref()
            .expect("Expected function, got error."))(hNode, event)
    }
    pub unsafe fn cuGraphAddExternalSemaphoresSignalNode(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphAddExternalSemaphoresSignalNode
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
            nodeParams,
        )
    }
    pub unsafe fn cuGraphExternalSemaphoresSignalNodeGetParams(
        &self,
        hNode: CUgraphNode,
        params_out: *mut CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphExternalSemaphoresSignalNodeGetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, params_out)
    }
    pub unsafe fn cuGraphExternalSemaphoresSignalNodeSetParams(
        &self,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphExternalSemaphoresSignalNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, nodeParams)
    }
    pub unsafe fn cuGraphAddExternalSemaphoresWaitNode(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphAddExternalSemaphoresWaitNode
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
            nodeParams,
        )
    }
    pub unsafe fn cuGraphExternalSemaphoresWaitNodeGetParams(
        &self,
        hNode: CUgraphNode,
        params_out: *mut CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphExternalSemaphoresWaitNodeGetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, params_out)
    }
    pub unsafe fn cuGraphExternalSemaphoresWaitNodeSetParams(
        &self,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphExternalSemaphoresWaitNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, nodeParams)
    }
    pub unsafe fn cuGraphAddBatchMemOpNode(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphAddBatchMemOpNode
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
            nodeParams,
        )
    }
    pub unsafe fn cuGraphBatchMemOpNodeGetParams(
        &self,
        hNode: CUgraphNode,
        nodeParams_out: *mut CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphBatchMemOpNodeGetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, nodeParams_out)
    }
    pub unsafe fn cuGraphBatchMemOpNodeSetParams(
        &self,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphBatchMemOpNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, nodeParams)
    }
    pub unsafe fn cuGraphExecBatchMemOpNodeSetParams(
        &self,
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_BATCH_MEM_OP_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphExecBatchMemOpNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, nodeParams)
    }
    pub unsafe fn cuGraphAddMemAllocNode(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphAddMemAllocNode
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
            nodeParams,
        )
    }
    pub unsafe fn cuGraphMemAllocNodeGetParams(
        &self,
        hNode: CUgraphNode,
        params_out: *mut CUDA_MEM_ALLOC_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphMemAllocNodeGetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, params_out)
    }
    pub unsafe fn cuGraphAddMemFreeNode(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        dptr: CUdeviceptr,
    ) -> CUresult {
        (self
            .cuGraphAddMemFreeNode
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
            dptr,
        )
    }
    pub unsafe fn cuGraphMemFreeNodeGetParams(
        &self,
        hNode: CUgraphNode,
        dptr_out: *mut CUdeviceptr,
    ) -> CUresult {
        (self
            .cuGraphMemFreeNodeGetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, dptr_out)
    }
    pub unsafe fn cuDeviceGraphMemTrim(&self, device: CUdevice) -> CUresult {
        (self
            .cuDeviceGraphMemTrim
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn cuDeviceGetGraphMemAttribute(
        &self,
        device: CUdevice,
        attr: CUgraphMem_attribute,
        value: *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuDeviceGetGraphMemAttribute
            .as_ref()
            .expect("Expected function, got error."))(device, attr, value)
    }
    pub unsafe fn cuDeviceSetGraphMemAttribute(
        &self,
        device: CUdevice,
        attr: CUgraphMem_attribute,
        value: *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuDeviceSetGraphMemAttribute
            .as_ref()
            .expect("Expected function, got error."))(device, attr, value)
    }
    pub unsafe fn cuGraphClone(
        &self,
        phGraphClone: *mut CUgraph,
        originalGraph: CUgraph,
    ) -> CUresult {
        (self
            .cuGraphClone
            .as_ref()
            .expect("Expected function, got error."))(phGraphClone, originalGraph)
    }
    pub unsafe fn cuGraphNodeFindInClone(
        &self,
        phNode: *mut CUgraphNode,
        hOriginalNode: CUgraphNode,
        hClonedGraph: CUgraph,
    ) -> CUresult {
        (self
            .cuGraphNodeFindInClone
            .as_ref()
            .expect("Expected function, got error."))(phNode, hOriginalNode, hClonedGraph)
    }
    pub unsafe fn cuGraphNodeGetType(
        &self,
        hNode: CUgraphNode,
        type_: *mut CUgraphNodeType,
    ) -> CUresult {
        (self
            .cuGraphNodeGetType
            .as_ref()
            .expect("Expected function, got error."))(hNode, type_)
    }
    pub unsafe fn cuGraphGetNodes(
        &self,
        hGraph: CUgraph,
        nodes: *mut CUgraphNode,
        numNodes: *mut usize,
    ) -> CUresult {
        (self
            .cuGraphGetNodes
            .as_ref()
            .expect("Expected function, got error."))(hGraph, nodes, numNodes)
    }
    pub unsafe fn cuGraphGetRootNodes(
        &self,
        hGraph: CUgraph,
        rootNodes: *mut CUgraphNode,
        numRootNodes: *mut usize,
    ) -> CUresult {
        (self
            .cuGraphGetRootNodes
            .as_ref()
            .expect("Expected function, got error."))(hGraph, rootNodes, numRootNodes)
    }
    pub unsafe fn cuGraphGetEdges(
        &self,
        hGraph: CUgraph,
        from: *mut CUgraphNode,
        to: *mut CUgraphNode,
        numEdges: *mut usize,
    ) -> CUresult {
        (self
            .cuGraphGetEdges
            .as_ref()
            .expect("Expected function, got error."))(hGraph, from, to, numEdges)
    }
    pub unsafe fn cuGraphGetEdges_v2(
        &self,
        hGraph: CUgraph,
        from: *mut CUgraphNode,
        to: *mut CUgraphNode,
        edgeData: *mut CUgraphEdgeData,
        numEdges: *mut usize,
    ) -> CUresult {
        (self
            .cuGraphGetEdges_v2
            .as_ref()
            .expect("Expected function, got error."))(hGraph, from, to, edgeData, numEdges)
    }
    pub unsafe fn cuGraphNodeGetDependencies(
        &self,
        hNode: CUgraphNode,
        dependencies: *mut CUgraphNode,
        numDependencies: *mut usize,
    ) -> CUresult {
        (self
            .cuGraphNodeGetDependencies
            .as_ref()
            .expect("Expected function, got error."))(hNode, dependencies, numDependencies)
    }
    pub unsafe fn cuGraphNodeGetDependencies_v2(
        &self,
        hNode: CUgraphNode,
        dependencies: *mut CUgraphNode,
        edgeData: *mut CUgraphEdgeData,
        numDependencies: *mut usize,
    ) -> CUresult {
        (self
            .cuGraphNodeGetDependencies_v2
            .as_ref()
            .expect("Expected function, got error."))(
            hNode,
            dependencies,
            edgeData,
            numDependencies,
        )
    }
    pub unsafe fn cuGraphNodeGetDependentNodes(
        &self,
        hNode: CUgraphNode,
        dependentNodes: *mut CUgraphNode,
        numDependentNodes: *mut usize,
    ) -> CUresult {
        (self
            .cuGraphNodeGetDependentNodes
            .as_ref()
            .expect("Expected function, got error."))(
            hNode, dependentNodes, numDependentNodes
        )
    }
    pub unsafe fn cuGraphNodeGetDependentNodes_v2(
        &self,
        hNode: CUgraphNode,
        dependentNodes: *mut CUgraphNode,
        edgeData: *mut CUgraphEdgeData,
        numDependentNodes: *mut usize,
    ) -> CUresult {
        (self
            .cuGraphNodeGetDependentNodes_v2
            .as_ref()
            .expect("Expected function, got error."))(
            hNode,
            dependentNodes,
            edgeData,
            numDependentNodes,
        )
    }
    pub unsafe fn cuGraphAddDependencies(
        &self,
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        numDependencies: usize,
    ) -> CUresult {
        (self
            .cuGraphAddDependencies
            .as_ref()
            .expect("Expected function, got error."))(hGraph, from, to, numDependencies)
    }
    pub unsafe fn cuGraphAddDependencies_v2(
        &self,
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        edgeData: *const CUgraphEdgeData,
        numDependencies: usize,
    ) -> CUresult {
        (self
            .cuGraphAddDependencies_v2
            .as_ref()
            .expect("Expected function, got error."))(
            hGraph, from, to, edgeData, numDependencies
        )
    }
    pub unsafe fn cuGraphRemoveDependencies(
        &self,
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        numDependencies: usize,
    ) -> CUresult {
        (self
            .cuGraphRemoveDependencies
            .as_ref()
            .expect("Expected function, got error."))(hGraph, from, to, numDependencies)
    }
    pub unsafe fn cuGraphRemoveDependencies_v2(
        &self,
        hGraph: CUgraph,
        from: *const CUgraphNode,
        to: *const CUgraphNode,
        edgeData: *const CUgraphEdgeData,
        numDependencies: usize,
    ) -> CUresult {
        (self
            .cuGraphRemoveDependencies_v2
            .as_ref()
            .expect("Expected function, got error."))(
            hGraph, from, to, edgeData, numDependencies
        )
    }
    pub unsafe fn cuGraphDestroyNode(&self, hNode: CUgraphNode) -> CUresult {
        (self
            .cuGraphDestroyNode
            .as_ref()
            .expect("Expected function, got error."))(hNode)
    }
    pub unsafe fn cuGraphInstantiateWithFlags(
        &self,
        phGraphExec: *mut CUgraphExec,
        hGraph: CUgraph,
        flags: ::core::ffi::c_ulonglong,
    ) -> CUresult {
        (self
            .cuGraphInstantiateWithFlags
            .as_ref()
            .expect("Expected function, got error."))(phGraphExec, hGraph, flags)
    }
    pub unsafe fn cuGraphInstantiateWithParams(
        &self,
        phGraphExec: *mut CUgraphExec,
        hGraph: CUgraph,
        instantiateParams: *mut CUDA_GRAPH_INSTANTIATE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphInstantiateWithParams
            .as_ref()
            .expect("Expected function, got error."))(phGraphExec, hGraph, instantiateParams)
    }
    pub unsafe fn cuGraphExecGetFlags(
        &self,
        hGraphExec: CUgraphExec,
        flags: *mut cuuint64_t,
    ) -> CUresult {
        (self
            .cuGraphExecGetFlags
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, flags)
    }
    pub unsafe fn cuGraphExecKernelNodeSetParams_v2(
        &self,
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_KERNEL_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphExecKernelNodeSetParams_v2
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, nodeParams)
    }
    pub unsafe fn cuGraphExecMemcpyNodeSetParams(
        &self,
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        copyParams: *const CUDA_MEMCPY3D,
        ctx: CUcontext,
    ) -> CUresult {
        (self
            .cuGraphExecMemcpyNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, copyParams, ctx)
    }
    pub unsafe fn cuGraphExecMemsetNodeSetParams(
        &self,
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        memsetParams: *const CUDA_MEMSET_NODE_PARAMS,
        ctx: CUcontext,
    ) -> CUresult {
        (self
            .cuGraphExecMemsetNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, memsetParams, ctx)
    }
    pub unsafe fn cuGraphExecHostNodeSetParams(
        &self,
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_HOST_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphExecHostNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, nodeParams)
    }
    pub unsafe fn cuGraphExecChildGraphNodeSetParams(
        &self,
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        childGraph: CUgraph,
    ) -> CUresult {
        (self
            .cuGraphExecChildGraphNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, childGraph)
    }
    pub unsafe fn cuGraphExecEventRecordNodeSetEvent(
        &self,
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult {
        (self
            .cuGraphExecEventRecordNodeSetEvent
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, event)
    }
    pub unsafe fn cuGraphExecEventWaitNodeSetEvent(
        &self,
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        event: CUevent,
    ) -> CUresult {
        (self
            .cuGraphExecEventWaitNodeSetEvent
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, event)
    }
    pub unsafe fn cuGraphExecExternalSemaphoresSignalNodeSetParams(
        &self,
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphExecExternalSemaphoresSignalNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, nodeParams)
    }
    pub unsafe fn cuGraphExecExternalSemaphoresWaitNodeSetParams(
        &self,
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *const CUDA_EXT_SEM_WAIT_NODE_PARAMS,
    ) -> CUresult {
        (self
            .cuGraphExecExternalSemaphoresWaitNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, nodeParams)
    }
    pub unsafe fn cuGraphNodeSetEnabled(
        &self,
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        isEnabled: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuGraphNodeSetEnabled
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, isEnabled)
    }
    pub unsafe fn cuGraphNodeGetEnabled(
        &self,
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        isEnabled: *mut ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuGraphNodeGetEnabled
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, isEnabled)
    }
    pub unsafe fn cuGraphUpload(&self, hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult {
        (self
            .cuGraphUpload
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hStream)
    }
    pub unsafe fn cuGraphLaunch(&self, hGraphExec: CUgraphExec, hStream: CUstream) -> CUresult {
        (self
            .cuGraphLaunch
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hStream)
    }
    pub unsafe fn cuGraphExecDestroy(&self, hGraphExec: CUgraphExec) -> CUresult {
        (self
            .cuGraphExecDestroy
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec)
    }
    pub unsafe fn cuGraphDestroy(&self, hGraph: CUgraph) -> CUresult {
        (self
            .cuGraphDestroy
            .as_ref()
            .expect("Expected function, got error."))(hGraph)
    }
    pub unsafe fn cuGraphExecUpdate_v2(
        &self,
        hGraphExec: CUgraphExec,
        hGraph: CUgraph,
        resultInfo: *mut CUgraphExecUpdateResultInfo,
    ) -> CUresult {
        (self
            .cuGraphExecUpdate_v2
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hGraph, resultInfo)
    }
    pub unsafe fn cuGraphKernelNodeCopyAttributes(
        &self,
        dst: CUgraphNode,
        src: CUgraphNode,
    ) -> CUresult {
        (self
            .cuGraphKernelNodeCopyAttributes
            .as_ref()
            .expect("Expected function, got error."))(dst, src)
    }
    pub unsafe fn cuGraphKernelNodeGetAttribute(
        &self,
        hNode: CUgraphNode,
        attr: CUkernelNodeAttrID,
        value_out: *mut CUkernelNodeAttrValue,
    ) -> CUresult {
        (self
            .cuGraphKernelNodeGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(hNode, attr, value_out)
    }
    pub unsafe fn cuGraphKernelNodeSetAttribute(
        &self,
        hNode: CUgraphNode,
        attr: CUkernelNodeAttrID,
        value: *const CUkernelNodeAttrValue,
    ) -> CUresult {
        (self
            .cuGraphKernelNodeSetAttribute
            .as_ref()
            .expect("Expected function, got error."))(hNode, attr, value)
    }
    pub unsafe fn cuGraphDebugDotPrint(
        &self,
        hGraph: CUgraph,
        path: *const ::core::ffi::c_char,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuGraphDebugDotPrint
            .as_ref()
            .expect("Expected function, got error."))(hGraph, path, flags)
    }
    pub unsafe fn cuUserObjectCreate(
        &self,
        object_out: *mut CUuserObject,
        ptr: *mut ::core::ffi::c_void,
        destroy: CUhostFn,
        initialRefcount: ::core::ffi::c_uint,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuUserObjectCreate
            .as_ref()
            .expect("Expected function, got error."))(
            object_out,
            ptr,
            destroy,
            initialRefcount,
            flags,
        )
    }
    pub unsafe fn cuUserObjectRetain(
        &self,
        object: CUuserObject,
        count: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuUserObjectRetain
            .as_ref()
            .expect("Expected function, got error."))(object, count)
    }
    pub unsafe fn cuUserObjectRelease(
        &self,
        object: CUuserObject,
        count: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuUserObjectRelease
            .as_ref()
            .expect("Expected function, got error."))(object, count)
    }
    pub unsafe fn cuGraphRetainUserObject(
        &self,
        graph: CUgraph,
        object: CUuserObject,
        count: ::core::ffi::c_uint,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuGraphRetainUserObject
            .as_ref()
            .expect("Expected function, got error."))(graph, object, count, flags)
    }
    pub unsafe fn cuGraphReleaseUserObject(
        &self,
        graph: CUgraph,
        object: CUuserObject,
        count: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuGraphReleaseUserObject
            .as_ref()
            .expect("Expected function, got error."))(graph, object, count)
    }
    pub unsafe fn cuGraphAddNode(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        numDependencies: usize,
        nodeParams: *mut CUgraphNodeParams,
    ) -> CUresult {
        (self
            .cuGraphAddNode
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            numDependencies,
            nodeParams,
        )
    }
    pub unsafe fn cuGraphAddNode_v2(
        &self,
        phGraphNode: *mut CUgraphNode,
        hGraph: CUgraph,
        dependencies: *const CUgraphNode,
        dependencyData: *const CUgraphEdgeData,
        numDependencies: usize,
        nodeParams: *mut CUgraphNodeParams,
    ) -> CUresult {
        (self
            .cuGraphAddNode_v2
            .as_ref()
            .expect("Expected function, got error."))(
            phGraphNode,
            hGraph,
            dependencies,
            dependencyData,
            numDependencies,
            nodeParams,
        )
    }
    pub unsafe fn cuGraphNodeSetParams(
        &self,
        hNode: CUgraphNode,
        nodeParams: *mut CUgraphNodeParams,
    ) -> CUresult {
        (self
            .cuGraphNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hNode, nodeParams)
    }
    pub unsafe fn cuGraphExecNodeSetParams(
        &self,
        hGraphExec: CUgraphExec,
        hNode: CUgraphNode,
        nodeParams: *mut CUgraphNodeParams,
    ) -> CUresult {
        (self
            .cuGraphExecNodeSetParams
            .as_ref()
            .expect("Expected function, got error."))(hGraphExec, hNode, nodeParams)
    }
    pub unsafe fn cuGraphConditionalHandleCreate(
        &self,
        pHandle_out: *mut CUgraphConditionalHandle,
        hGraph: CUgraph,
        ctx: CUcontext,
        defaultLaunchValue: ::core::ffi::c_uint,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuGraphConditionalHandleCreate
            .as_ref()
            .expect("Expected function, got error."))(
            pHandle_out,
            hGraph,
            ctx,
            defaultLaunchValue,
            flags,
        )
    }
    pub unsafe fn cuOccupancyMaxActiveBlocksPerMultiprocessor(
        &self,
        numBlocks: *mut ::core::ffi::c_int,
        func: CUfunction,
        blockSize: ::core::ffi::c_int,
        dynamicSMemSize: usize,
    ) -> CUresult {
        (self
            .cuOccupancyMaxActiveBlocksPerMultiprocessor
            .as_ref()
            .expect("Expected function, got error."))(
            numBlocks, func, blockSize, dynamicSMemSize
        )
    }
    pub unsafe fn cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        &self,
        numBlocks: *mut ::core::ffi::c_int,
        func: CUfunction,
        blockSize: ::core::ffi::c_int,
        dynamicSMemSize: usize,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags
            .as_ref()
            .expect("Expected function, got error."))(
            numBlocks,
            func,
            blockSize,
            dynamicSMemSize,
            flags,
        )
    }
    pub unsafe fn cuOccupancyMaxPotentialBlockSize(
        &self,
        minGridSize: *mut ::core::ffi::c_int,
        blockSize: *mut ::core::ffi::c_int,
        func: CUfunction,
        blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
        dynamicSMemSize: usize,
        blockSizeLimit: ::core::ffi::c_int,
    ) -> CUresult {
        (self
            .cuOccupancyMaxPotentialBlockSize
            .as_ref()
            .expect("Expected function, got error."))(
            minGridSize,
            blockSize,
            func,
            blockSizeToDynamicSMemSize,
            dynamicSMemSize,
            blockSizeLimit,
        )
    }
    pub unsafe fn cuOccupancyMaxPotentialBlockSizeWithFlags(
        &self,
        minGridSize: *mut ::core::ffi::c_int,
        blockSize: *mut ::core::ffi::c_int,
        func: CUfunction,
        blockSizeToDynamicSMemSize: CUoccupancyB2DSize,
        dynamicSMemSize: usize,
        blockSizeLimit: ::core::ffi::c_int,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuOccupancyMaxPotentialBlockSizeWithFlags
            .as_ref()
            .expect("Expected function, got error."))(
            minGridSize,
            blockSize,
            func,
            blockSizeToDynamicSMemSize,
            dynamicSMemSize,
            blockSizeLimit,
            flags,
        )
    }
    pub unsafe fn cuOccupancyAvailableDynamicSMemPerBlock(
        &self,
        dynamicSmemSize: *mut usize,
        func: CUfunction,
        numBlocks: ::core::ffi::c_int,
        blockSize: ::core::ffi::c_int,
    ) -> CUresult {
        (self
            .cuOccupancyAvailableDynamicSMemPerBlock
            .as_ref()
            .expect("Expected function, got error."))(
            dynamicSmemSize, func, numBlocks, blockSize
        )
    }
    pub unsafe fn cuOccupancyMaxPotentialClusterSize(
        &self,
        clusterSize: *mut ::core::ffi::c_int,
        func: CUfunction,
        config: *const CUlaunchConfig,
    ) -> CUresult {
        (self
            .cuOccupancyMaxPotentialClusterSize
            .as_ref()
            .expect("Expected function, got error."))(clusterSize, func, config)
    }
    pub unsafe fn cuOccupancyMaxActiveClusters(
        &self,
        numClusters: *mut ::core::ffi::c_int,
        func: CUfunction,
        config: *const CUlaunchConfig,
    ) -> CUresult {
        (self
            .cuOccupancyMaxActiveClusters
            .as_ref()
            .expect("Expected function, got error."))(numClusters, func, config)
    }
    pub unsafe fn cuTexRefSetArray(
        &self,
        hTexRef: CUtexref,
        hArray: CUarray,
        Flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuTexRefSetArray
            .as_ref()
            .expect("Expected function, got error."))(hTexRef, hArray, Flags)
    }
    pub unsafe fn cuTexRefSetMipmappedArray(
        &self,
        hTexRef: CUtexref,
        hMipmappedArray: CUmipmappedArray,
        Flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuTexRefSetMipmappedArray
            .as_ref()
            .expect("Expected function, got error."))(hTexRef, hMipmappedArray, Flags)
    }
    pub unsafe fn cuTexRefSetAddress_v2(
        &self,
        ByteOffset: *mut usize,
        hTexRef: CUtexref,
        dptr: CUdeviceptr,
        bytes: usize,
    ) -> CUresult {
        (self
            .cuTexRefSetAddress_v2
            .as_ref()
            .expect("Expected function, got error."))(ByteOffset, hTexRef, dptr, bytes)
    }
    pub unsafe fn cuTexRefSetAddress2D_v3(
        &self,
        hTexRef: CUtexref,
        desc: *const CUDA_ARRAY_DESCRIPTOR,
        dptr: CUdeviceptr,
        Pitch: usize,
    ) -> CUresult {
        (self
            .cuTexRefSetAddress2D_v3
            .as_ref()
            .expect("Expected function, got error."))(hTexRef, desc, dptr, Pitch)
    }
    pub unsafe fn cuTexRefSetFormat(
        &self,
        hTexRef: CUtexref,
        fmt: CUarray_format,
        NumPackedComponents: ::core::ffi::c_int,
    ) -> CUresult {
        (self
            .cuTexRefSetFormat
            .as_ref()
            .expect("Expected function, got error."))(hTexRef, fmt, NumPackedComponents)
    }
    pub unsafe fn cuTexRefSetAddressMode(
        &self,
        hTexRef: CUtexref,
        dim: ::core::ffi::c_int,
        am: CUaddress_mode,
    ) -> CUresult {
        (self
            .cuTexRefSetAddressMode
            .as_ref()
            .expect("Expected function, got error."))(hTexRef, dim, am)
    }
    pub unsafe fn cuTexRefSetFilterMode(&self, hTexRef: CUtexref, fm: CUfilter_mode) -> CUresult {
        (self
            .cuTexRefSetFilterMode
            .as_ref()
            .expect("Expected function, got error."))(hTexRef, fm)
    }
    pub unsafe fn cuTexRefSetMipmapFilterMode(
        &self,
        hTexRef: CUtexref,
        fm: CUfilter_mode,
    ) -> CUresult {
        (self
            .cuTexRefSetMipmapFilterMode
            .as_ref()
            .expect("Expected function, got error."))(hTexRef, fm)
    }
    pub unsafe fn cuTexRefSetMipmapLevelBias(&self, hTexRef: CUtexref, bias: f32) -> CUresult {
        (self
            .cuTexRefSetMipmapLevelBias
            .as_ref()
            .expect("Expected function, got error."))(hTexRef, bias)
    }
    pub unsafe fn cuTexRefSetMipmapLevelClamp(
        &self,
        hTexRef: CUtexref,
        minMipmapLevelClamp: f32,
        maxMipmapLevelClamp: f32,
    ) -> CUresult {
        (self
            .cuTexRefSetMipmapLevelClamp
            .as_ref()
            .expect("Expected function, got error."))(
            hTexRef,
            minMipmapLevelClamp,
            maxMipmapLevelClamp,
        )
    }
    pub unsafe fn cuTexRefSetMaxAnisotropy(
        &self,
        hTexRef: CUtexref,
        maxAniso: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuTexRefSetMaxAnisotropy
            .as_ref()
            .expect("Expected function, got error."))(hTexRef, maxAniso)
    }
    pub unsafe fn cuTexRefSetBorderColor(
        &self,
        hTexRef: CUtexref,
        pBorderColor: *mut f32,
    ) -> CUresult {
        (self
            .cuTexRefSetBorderColor
            .as_ref()
            .expect("Expected function, got error."))(hTexRef, pBorderColor)
    }
    pub unsafe fn cuTexRefSetFlags(
        &self,
        hTexRef: CUtexref,
        Flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuTexRefSetFlags
            .as_ref()
            .expect("Expected function, got error."))(hTexRef, Flags)
    }
    pub unsafe fn cuTexRefGetAddress_v2(
        &self,
        pdptr: *mut CUdeviceptr,
        hTexRef: CUtexref,
    ) -> CUresult {
        (self
            .cuTexRefGetAddress_v2
            .as_ref()
            .expect("Expected function, got error."))(pdptr, hTexRef)
    }
    pub unsafe fn cuTexRefGetArray(&self, phArray: *mut CUarray, hTexRef: CUtexref) -> CUresult {
        (self
            .cuTexRefGetArray
            .as_ref()
            .expect("Expected function, got error."))(phArray, hTexRef)
    }
    pub unsafe fn cuTexRefGetMipmappedArray(
        &self,
        phMipmappedArray: *mut CUmipmappedArray,
        hTexRef: CUtexref,
    ) -> CUresult {
        (self
            .cuTexRefGetMipmappedArray
            .as_ref()
            .expect("Expected function, got error."))(phMipmappedArray, hTexRef)
    }
    pub unsafe fn cuTexRefGetAddressMode(
        &self,
        pam: *mut CUaddress_mode,
        hTexRef: CUtexref,
        dim: ::core::ffi::c_int,
    ) -> CUresult {
        (self
            .cuTexRefGetAddressMode
            .as_ref()
            .expect("Expected function, got error."))(pam, hTexRef, dim)
    }
    pub unsafe fn cuTexRefGetFilterMode(
        &self,
        pfm: *mut CUfilter_mode,
        hTexRef: CUtexref,
    ) -> CUresult {
        (self
            .cuTexRefGetFilterMode
            .as_ref()
            .expect("Expected function, got error."))(pfm, hTexRef)
    }
    pub unsafe fn cuTexRefGetFormat(
        &self,
        pFormat: *mut CUarray_format,
        pNumChannels: *mut ::core::ffi::c_int,
        hTexRef: CUtexref,
    ) -> CUresult {
        (self
            .cuTexRefGetFormat
            .as_ref()
            .expect("Expected function, got error."))(pFormat, pNumChannels, hTexRef)
    }
    pub unsafe fn cuTexRefGetMipmapFilterMode(
        &self,
        pfm: *mut CUfilter_mode,
        hTexRef: CUtexref,
    ) -> CUresult {
        (self
            .cuTexRefGetMipmapFilterMode
            .as_ref()
            .expect("Expected function, got error."))(pfm, hTexRef)
    }
    pub unsafe fn cuTexRefGetMipmapLevelBias(
        &self,
        pbias: *mut f32,
        hTexRef: CUtexref,
    ) -> CUresult {
        (self
            .cuTexRefGetMipmapLevelBias
            .as_ref()
            .expect("Expected function, got error."))(pbias, hTexRef)
    }
    pub unsafe fn cuTexRefGetMipmapLevelClamp(
        &self,
        pminMipmapLevelClamp: *mut f32,
        pmaxMipmapLevelClamp: *mut f32,
        hTexRef: CUtexref,
    ) -> CUresult {
        (self
            .cuTexRefGetMipmapLevelClamp
            .as_ref()
            .expect("Expected function, got error."))(
            pminMipmapLevelClamp,
            pmaxMipmapLevelClamp,
            hTexRef,
        )
    }
    pub unsafe fn cuTexRefGetMaxAnisotropy(
        &self,
        pmaxAniso: *mut ::core::ffi::c_int,
        hTexRef: CUtexref,
    ) -> CUresult {
        (self
            .cuTexRefGetMaxAnisotropy
            .as_ref()
            .expect("Expected function, got error."))(pmaxAniso, hTexRef)
    }
    pub unsafe fn cuTexRefGetBorderColor(
        &self,
        pBorderColor: *mut f32,
        hTexRef: CUtexref,
    ) -> CUresult {
        (self
            .cuTexRefGetBorderColor
            .as_ref()
            .expect("Expected function, got error."))(pBorderColor, hTexRef)
    }
    pub unsafe fn cuTexRefGetFlags(
        &self,
        pFlags: *mut ::core::ffi::c_uint,
        hTexRef: CUtexref,
    ) -> CUresult {
        (self
            .cuTexRefGetFlags
            .as_ref()
            .expect("Expected function, got error."))(pFlags, hTexRef)
    }
    pub unsafe fn cuTexRefCreate(&self, pTexRef: *mut CUtexref) -> CUresult {
        (self
            .cuTexRefCreate
            .as_ref()
            .expect("Expected function, got error."))(pTexRef)
    }
    pub unsafe fn cuTexRefDestroy(&self, hTexRef: CUtexref) -> CUresult {
        (self
            .cuTexRefDestroy
            .as_ref()
            .expect("Expected function, got error."))(hTexRef)
    }
    pub unsafe fn cuSurfRefSetArray(
        &self,
        hSurfRef: CUsurfref,
        hArray: CUarray,
        Flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuSurfRefSetArray
            .as_ref()
            .expect("Expected function, got error."))(hSurfRef, hArray, Flags)
    }
    pub unsafe fn cuSurfRefGetArray(&self, phArray: *mut CUarray, hSurfRef: CUsurfref) -> CUresult {
        (self
            .cuSurfRefGetArray
            .as_ref()
            .expect("Expected function, got error."))(phArray, hSurfRef)
    }
    pub unsafe fn cuTexObjectCreate(
        &self,
        pTexObject: *mut CUtexObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
        pTexDesc: *const CUDA_TEXTURE_DESC,
        pResViewDesc: *const CUDA_RESOURCE_VIEW_DESC,
    ) -> CUresult {
        (self
            .cuTexObjectCreate
            .as_ref()
            .expect("Expected function, got error."))(
            pTexObject, pResDesc, pTexDesc, pResViewDesc
        )
    }
    pub unsafe fn cuTexObjectDestroy(&self, texObject: CUtexObject) -> CUresult {
        (self
            .cuTexObjectDestroy
            .as_ref()
            .expect("Expected function, got error."))(texObject)
    }
    pub unsafe fn cuTexObjectGetResourceDesc(
        &self,
        pResDesc: *mut CUDA_RESOURCE_DESC,
        texObject: CUtexObject,
    ) -> CUresult {
        (self
            .cuTexObjectGetResourceDesc
            .as_ref()
            .expect("Expected function, got error."))(pResDesc, texObject)
    }
    pub unsafe fn cuTexObjectGetTextureDesc(
        &self,
        pTexDesc: *mut CUDA_TEXTURE_DESC,
        texObject: CUtexObject,
    ) -> CUresult {
        (self
            .cuTexObjectGetTextureDesc
            .as_ref()
            .expect("Expected function, got error."))(pTexDesc, texObject)
    }
    pub unsafe fn cuTexObjectGetResourceViewDesc(
        &self,
        pResViewDesc: *mut CUDA_RESOURCE_VIEW_DESC,
        texObject: CUtexObject,
    ) -> CUresult {
        (self
            .cuTexObjectGetResourceViewDesc
            .as_ref()
            .expect("Expected function, got error."))(pResViewDesc, texObject)
    }
    pub unsafe fn cuSurfObjectCreate(
        &self,
        pSurfObject: *mut CUsurfObject,
        pResDesc: *const CUDA_RESOURCE_DESC,
    ) -> CUresult {
        (self
            .cuSurfObjectCreate
            .as_ref()
            .expect("Expected function, got error."))(pSurfObject, pResDesc)
    }
    pub unsafe fn cuSurfObjectDestroy(&self, surfObject: CUsurfObject) -> CUresult {
        (self
            .cuSurfObjectDestroy
            .as_ref()
            .expect("Expected function, got error."))(surfObject)
    }
    pub unsafe fn cuSurfObjectGetResourceDesc(
        &self,
        pResDesc: *mut CUDA_RESOURCE_DESC,
        surfObject: CUsurfObject,
    ) -> CUresult {
        (self
            .cuSurfObjectGetResourceDesc
            .as_ref()
            .expect("Expected function, got error."))(pResDesc, surfObject)
    }
    pub unsafe fn cuTensorMapEncodeTiled(
        &self,
        tensorMap: *mut CUtensorMap,
        tensorDataType: CUtensorMapDataType,
        tensorRank: cuuint32_t,
        globalAddress: *mut ::core::ffi::c_void,
        globalDim: *const cuuint64_t,
        globalStrides: *const cuuint64_t,
        boxDim: *const cuuint32_t,
        elementStrides: *const cuuint32_t,
        interleave: CUtensorMapInterleave,
        swizzle: CUtensorMapSwizzle,
        l2Promotion: CUtensorMapL2promotion,
        oobFill: CUtensorMapFloatOOBfill,
    ) -> CUresult {
        (self
            .cuTensorMapEncodeTiled
            .as_ref()
            .expect("Expected function, got error."))(
            tensorMap,
            tensorDataType,
            tensorRank,
            globalAddress,
            globalDim,
            globalStrides,
            boxDim,
            elementStrides,
            interleave,
            swizzle,
            l2Promotion,
            oobFill,
        )
    }
    pub unsafe fn cuTensorMapEncodeIm2col(
        &self,
        tensorMap: *mut CUtensorMap,
        tensorDataType: CUtensorMapDataType,
        tensorRank: cuuint32_t,
        globalAddress: *mut ::core::ffi::c_void,
        globalDim: *const cuuint64_t,
        globalStrides: *const cuuint64_t,
        pixelBoxLowerCorner: *const ::core::ffi::c_int,
        pixelBoxUpperCorner: *const ::core::ffi::c_int,
        channelsPerPixel: cuuint32_t,
        pixelsPerColumn: cuuint32_t,
        elementStrides: *const cuuint32_t,
        interleave: CUtensorMapInterleave,
        swizzle: CUtensorMapSwizzle,
        l2Promotion: CUtensorMapL2promotion,
        oobFill: CUtensorMapFloatOOBfill,
    ) -> CUresult {
        (self
            .cuTensorMapEncodeIm2col
            .as_ref()
            .expect("Expected function, got error."))(
            tensorMap,
            tensorDataType,
            tensorRank,
            globalAddress,
            globalDim,
            globalStrides,
            pixelBoxLowerCorner,
            pixelBoxUpperCorner,
            channelsPerPixel,
            pixelsPerColumn,
            elementStrides,
            interleave,
            swizzle,
            l2Promotion,
            oobFill,
        )
    }
    pub unsafe fn cuTensorMapReplaceAddress(
        &self,
        tensorMap: *mut CUtensorMap,
        globalAddress: *mut ::core::ffi::c_void,
    ) -> CUresult {
        (self
            .cuTensorMapReplaceAddress
            .as_ref()
            .expect("Expected function, got error."))(tensorMap, globalAddress)
    }
    pub unsafe fn cuDeviceCanAccessPeer(
        &self,
        canAccessPeer: *mut ::core::ffi::c_int,
        dev: CUdevice,
        peerDev: CUdevice,
    ) -> CUresult {
        (self
            .cuDeviceCanAccessPeer
            .as_ref()
            .expect("Expected function, got error."))(canAccessPeer, dev, peerDev)
    }
    pub unsafe fn cuCtxEnablePeerAccess(
        &self,
        peerContext: CUcontext,
        Flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuCtxEnablePeerAccess
            .as_ref()
            .expect("Expected function, got error."))(peerContext, Flags)
    }
    pub unsafe fn cuCtxDisablePeerAccess(&self, peerContext: CUcontext) -> CUresult {
        (self
            .cuCtxDisablePeerAccess
            .as_ref()
            .expect("Expected function, got error."))(peerContext)
    }
    pub unsafe fn cuDeviceGetP2PAttribute(
        &self,
        value: *mut ::core::ffi::c_int,
        attrib: CUdevice_P2PAttribute,
        srcDevice: CUdevice,
        dstDevice: CUdevice,
    ) -> CUresult {
        (self
            .cuDeviceGetP2PAttribute
            .as_ref()
            .expect("Expected function, got error."))(value, attrib, srcDevice, dstDevice)
    }
    pub unsafe fn cuGraphicsUnregisterResource(&self, resource: CUgraphicsResource) -> CUresult {
        (self
            .cuGraphicsUnregisterResource
            .as_ref()
            .expect("Expected function, got error."))(resource)
    }
    pub unsafe fn cuGraphicsSubResourceGetMappedArray(
        &self,
        pArray: *mut CUarray,
        resource: CUgraphicsResource,
        arrayIndex: ::core::ffi::c_uint,
        mipLevel: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuGraphicsSubResourceGetMappedArray
            .as_ref()
            .expect("Expected function, got error."))(pArray, resource, arrayIndex, mipLevel)
    }
    pub unsafe fn cuGraphicsResourceGetMappedMipmappedArray(
        &self,
        pMipmappedArray: *mut CUmipmappedArray,
        resource: CUgraphicsResource,
    ) -> CUresult {
        (self
            .cuGraphicsResourceGetMappedMipmappedArray
            .as_ref()
            .expect("Expected function, got error."))(pMipmappedArray, resource)
    }
    pub unsafe fn cuGraphicsResourceGetMappedPointer_v2(
        &self,
        pDevPtr: *mut CUdeviceptr,
        pSize: *mut usize,
        resource: CUgraphicsResource,
    ) -> CUresult {
        (self
            .cuGraphicsResourceGetMappedPointer_v2
            .as_ref()
            .expect("Expected function, got error."))(pDevPtr, pSize, resource)
    }
    pub unsafe fn cuGraphicsResourceSetMapFlags_v2(
        &self,
        resource: CUgraphicsResource,
        flags: ::core::ffi::c_uint,
    ) -> CUresult {
        (self
            .cuGraphicsResourceSetMapFlags_v2
            .as_ref()
            .expect("Expected function, got error."))(resource, flags)
    }
    pub unsafe fn cuGraphicsMapResources(
        &self,
        count: ::core::ffi::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuGraphicsMapResources
            .as_ref()
            .expect("Expected function, got error."))(count, resources, hStream)
    }
    pub unsafe fn cuGraphicsUnmapResources(
        &self,
        count: ::core::ffi::c_uint,
        resources: *mut CUgraphicsResource,
        hStream: CUstream,
    ) -> CUresult {
        (self
            .cuGraphicsUnmapResources
            .as_ref()
            .expect("Expected function, got error."))(count, resources, hStream)
    }
    pub unsafe fn cuGetProcAddress_v2(
        &self,
        symbol: *const ::core::ffi::c_char,
        pfn: *mut *mut ::core::ffi::c_void,
        cudaVersion: ::core::ffi::c_int,
        flags: cuuint64_t,
        symbolStatus: *mut CUdriverProcAddressQueryResult,
    ) -> CUresult {
        (self
            .cuGetProcAddress_v2
            .as_ref()
            .expect("Expected function, got error."))(
            symbol, pfn, cudaVersion, flags, symbolStatus
        )
    }
    pub unsafe fn cuCoredumpGetAttribute(
        &self,
        attrib: CUcoredumpSettings,
        value: *mut ::core::ffi::c_void,
        size: *mut usize,
    ) -> CUresult {
        (self
            .cuCoredumpGetAttribute
            .as_ref()
            .expect("Expected function, got error."))(attrib, value, size)
    }
    pub unsafe fn cuCoredumpGetAttributeGlobal(
        &self,
        attrib: CUcoredumpSettings,
        value: *mut ::core::ffi::c_void,
        size: *mut usize,
    ) -> CUresult {
        (self
            .cuCoredumpGetAttributeGlobal
            .as_ref()
            .expect("Expected function, got error."))(attrib, value, size)
    }
    pub unsafe fn cuCoredumpSetAttribute(
        &self,
        attrib: CUcoredumpSettings,
        value: *mut ::core::ffi::c_void,
        size: *mut usize,
    ) -> CUresult {
        (self
            .cuCoredumpSetAttribute
            .as_ref()
            .expect("Expected function, got error."))(attrib, value, size)
    }
    pub unsafe fn cuCoredumpSetAttributeGlobal(
        &self,
        attrib: CUcoredumpSettings,
        value: *mut ::core::ffi::c_void,
        size: *mut usize,
    ) -> CUresult {
        (self
            .cuCoredumpSetAttributeGlobal
            .as_ref()
            .expect("Expected function, got error."))(attrib, value, size)
    }
    pub unsafe fn cuGetExportTable(
        &self,
        ppExportTable: *mut *const ::core::ffi::c_void,
        pExportTableId: *const CUuuid,
    ) -> CUresult {
        (self
            .cuGetExportTable
            .as_ref()
            .expect("Expected function, got error."))(ppExportTable, pExportTableId)
    }
    pub unsafe fn cuProfilerInitialize(
        &self,
        configFile: *const ::core::ffi::c_char,
        outputFile: *const ::core::ffi::c_char,
        outputMode: CUoutput_mode,
    ) -> CUresult {
        (self
            .cuProfilerInitialize
            .as_ref()
            .expect("Expected function, got error."))(configFile, outputFile, outputMode)
    }
    pub unsafe fn cuProfilerStart(&self) -> CUresult {
        (self
            .cuProfilerStart
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn cuProfilerStop(&self) -> CUresult {
        (self
            .cuProfilerStop
            .as_ref()
            .expect("Expected function, got error."))()
    }
}
